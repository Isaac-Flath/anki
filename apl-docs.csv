Plus Sign,+
Monadic: Conjugate,+
"If Y is complex, R is Y with the imaginary part of all elements negated.<br/>If Y is real or non-numeric, R is the same array unchanged, although ⊣ is faster. See Same. ",+
+,"If Y is complex, R is Y with the imaginary part of all elements negated.<br/>If Y is real or non-numeric, R is the same array unchanged, although ⊣ is faster. See Same. "
Conjugate,"If Y is complex, R is Y with the imaginary part of all elements negated.<br/>If Y is real or non-numeric, R is the same array unchanged, although ⊣ is faster. See Same. "
"If Y is complex, R is Y with the imaginary part of all elements negated.<br/>If Y is real or non-numeric, R is the same array unchanged, although ⊣ is faster. See Same. ",Conjugate
Dyadic: Plus,+
Y must be numeric.  X must be numeric.  R is the arithmetic sum of X and Y.  R is numeric. This function is also known as Plus.,+
+,Y must be numeric.  X must be numeric.  R is the arithmetic sum of X and Y.  R is numeric. This function is also known as Plus.
Add,+
Add,Y must be numeric.  X must be numeric.  R is the arithmetic sum of X and Y.  R is numeric. This function is also known as Plus.
Y must be numeric.  X must be numeric.  R is the arithmetic sum of X and Y.  R is numeric. This function is also known as Plus.,Add
+,Plus Sign<br/>Monadic: Conjugate<br/>Dyadic: Plus
Minus Sign;Bar,-
Monadic: Negate,-
Y may be any numeric array. R is numeric and is the negative value of Y. For complex numbers both the real and imaginary parts are negated.,-
-,Y may be any numeric array. R is numeric and is the negative value of Y. For complex numbers both the real and imaginary parts are negated.
Negative,-
Negative,Y may be any numeric array. R is numeric and is the negative value of Y. For complex numbers both the real and imaginary parts are negated.
Y may be any numeric array. R is numeric and is the negative value of Y. For complex numbers both the real and imaginary parts are negated.,Negative
Dyadic: Minus;Subtract,-
Y may be any numeric array.  X may be any numeric array. R is numeric. The value of R is the difference between X and Y.<br/>This function is also known as Minus.,-
-,Y may be any numeric array.  X may be any numeric array. R is numeric. The value of R is the difference between X and Y.<br/>This function is also known as Minus.
Subtract,Y may be any numeric array.  X may be any numeric array. R is numeric. The value of R is the difference between X and Y.<br/>This function is also known as Minus.
Y may be any numeric array.  X may be any numeric array. R is numeric. The value of R is the difference between X and Y.<br/>This function is also known as Minus.,Subtract
-,Minus Sign;Bar<br/>Monadic: Negate<br/>Dyadic: Minus;Subtract
Times Sign,×
Monadic: Direction,×
"Y may be any numeric array. <br/>Where an element of Y is real, the corresponding element of R is an integer whose value indicates whether the value is negative (¯1), zero (0) or positive (1).<br/>Where an element of Y is complex, the corresponding element of R is a number with the same phase but with magnitude (absolute value) 1. It is equivalent to Y÷|Y. ",×
×,"Y may be any numeric array. <br/>Where an element of Y is real, the corresponding element of R is an integer whose value indicates whether the value is negative (¯1), zero (0) or positive (1).<br/>Where an element of Y is complex, the corresponding element of R is a number with the same phase but with magnitude (absolute value) 1. It is equivalent to Y÷|Y. "
Direction(Signum),×
Direction(Signum),"Y may be any numeric array. <br/>Where an element of Y is real, the corresponding element of R is an integer whose value indicates whether the value is negative (¯1), zero (0) or positive (1).<br/>Where an element of Y is complex, the corresponding element of R is a number with the same phase but with magnitude (absolute value) 1. It is equivalent to Y÷|Y. "
"Y may be any numeric array. <br/>Where an element of Y is real, the corresponding element of R is an integer whose value indicates whether the value is negative (¯1), zero (0) or positive (1).<br/>Where an element of Y is complex, the corresponding element of R is a number with the same phase but with magnitude (absolute value) 1. It is equivalent to Y÷|Y. ",Direction(Signum)
Dyadic: Times,×
Y may be any numeric array.  X may be any numeric array.  R is the arithmetic product of X and Y.<br/>This function is also known as Times.,×
×,Y may be any numeric array.  X may be any numeric array.  R is the arithmetic product of X and Y.<br/>This function is also known as Times.
Multiply,×
Multiply,Y may be any numeric array.  X may be any numeric array.  R is the arithmetic product of X and Y.<br/>This function is also known as Times.
Y may be any numeric array.  X may be any numeric array.  R is the arithmetic product of X and Y.<br/>This function is also known as Times.,Multiply
×,Times Sign<br/>Monadic: Direction<br/>Dyadic: Times
Divide Sign,÷
Monadic: Reciprocal,÷
"Y must be a numeric array.  R is numeric.  R is the reciprocal of Y; that is 1÷Y.  If ⎕DIV=0, ÷0 results in a DOMAIN ERROR.  If ⎕DIV=1, ÷0 returns 0.<br/>⎕DIV is an implicit argument of Reciprocal.",÷
÷,"Y must be a numeric array.  R is numeric.  R is the reciprocal of Y; that is 1÷Y.  If ⎕DIV=0, ÷0 results in a DOMAIN ERROR.  If ⎕DIV=1, ÷0 returns 0.<br/>⎕DIV is an implicit argument of Reciprocal."
Reciprocal,"Y must be a numeric array.  R is numeric.  R is the reciprocal of Y; that is 1÷Y.  If ⎕DIV=0, ÷0 results in a DOMAIN ERROR.  If ⎕DIV=1, ÷0 returns 0.<br/>⎕DIV is an implicit argument of Reciprocal."
"Y must be a numeric array.  R is numeric.  R is the reciprocal of Y; that is 1÷Y.  If ⎕DIV=0, ÷0 results in a DOMAIN ERROR.  If ⎕DIV=1, ÷0 returns 0.<br/>⎕DIV is an implicit argument of Reciprocal.",Reciprocal
Dyadic: Divided By,÷
"Y must be a numeric array.  X must be a numeric array.  R is the numeric array resulting from X divided by Y.  System variable ⎕DIV is an implicit argument of Divide.<br/>If ⎕DIV=0 and Y=0 then if X=0, the result of X÷Y is 1; if X≠0 then X÷Y is a DOMAIN ERROR.<br/>If ⎕DIV=1 and Y=0, the result of X÷Y is 0 for all values of X.",÷
÷,"Y must be a numeric array.  X must be a numeric array.  R is the numeric array resulting from X divided by Y.  System variable ⎕DIV is an implicit argument of Divide.<br/>If ⎕DIV=0 and Y=0 then if X=0, the result of X÷Y is 1; if X≠0 then X÷Y is a DOMAIN ERROR.<br/>If ⎕DIV=1 and Y=0, the result of X÷Y is 0 for all values of X."
Divide,"Y must be a numeric array.  X must be a numeric array.  R is the numeric array resulting from X divided by Y.  System variable ⎕DIV is an implicit argument of Divide.<br/>If ⎕DIV=0 and Y=0 then if X=0, the result of X÷Y is 1; if X≠0 then X÷Y is a DOMAIN ERROR.<br/>If ⎕DIV=1 and Y=0, the result of X÷Y is 0 for all values of X."
"Y must be a numeric array.  X must be a numeric array.  R is the numeric array resulting from X divided by Y.  System variable ⎕DIV is an implicit argument of Divide.<br/>If ⎕DIV=0 and Y=0 then if X=0, the result of X÷Y is 1; if X≠0 then X÷Y is a DOMAIN ERROR.<br/>If ⎕DIV=1 and Y=0, the result of X÷Y is 0 for all values of X.",Divide
÷,Divide Sign<br/>Monadic: Reciprocal<br/>Dyadic: Divided By
Stile;Vertical Bar,|
Monadic: Magnitude,|
Y may be any numeric array. R is numeric composed of the absolute (unsigned) values of Y.<br/>Note that the magnitude of a complex number  is defined to be <br/>⎕IO is an implicit argument of magnitude.,|
|,Y may be any numeric array. R is numeric composed of the absolute (unsigned) values of Y.<br/>Note that the magnitude of a complex number  is defined to be <br/>⎕IO is an implicit argument of magnitude.
Magnitude,Y may be any numeric array. R is numeric composed of the absolute (unsigned) values of Y.<br/>Note that the magnitude of a complex number  is defined to be <br/>⎕IO is an implicit argument of magnitude.
Y may be any numeric array. R is numeric composed of the absolute (unsigned) values of Y.<br/>Note that the magnitude of a complex number  is defined to be <br/>⎕IO is an implicit argument of magnitude.,Magnitude
Dyadic: Residue;Modulus,|
"Y may be any numeric array.  X may be any numeric array.<br/>For positive arguments, R is the remainder when Y is divided by X. If X=0, R is Y.<br/>For other argument values, R is given by the expression Y-X×⌊Y÷X+0=X. This expression also applies when X and/or Y are complex if the simple ⌊ is replaced by the CpxFloor function. See Complex Floor.<br/>⎕CT and ⎕DCT are  implicit arguments of Residue.<br/>Note that the ASCII Broken Bar (⎕UCS 166, U+00A6) is not interpreted as Residue.",|
|,"Y may be any numeric array.  X may be any numeric array.<br/>For positive arguments, R is the remainder when Y is divided by X. If X=0, R is Y.<br/>For other argument values, R is given by the expression Y-X×⌊Y÷X+0=X. This expression also applies when X and/or Y are complex if the simple ⌊ is replaced by the CpxFloor function. See Complex Floor.<br/>⎕CT and ⎕DCT are  implicit arguments of Residue.<br/>Note that the ASCII Broken Bar (⎕UCS 166, U+00A6) is not interpreted as Residue."
Residue,"Y may be any numeric array.  X may be any numeric array.<br/>For positive arguments, R is the remainder when Y is divided by X. If X=0, R is Y.<br/>For other argument values, R is given by the expression Y-X×⌊Y÷X+0=X. This expression also applies when X and/or Y are complex if the simple ⌊ is replaced by the CpxFloor function. See Complex Floor.<br/>⎕CT and ⎕DCT are  implicit arguments of Residue.<br/>Note that the ASCII Broken Bar (⎕UCS 166, U+00A6) is not interpreted as Residue."
"Y may be any numeric array.  X may be any numeric array.<br/>For positive arguments, R is the remainder when Y is divided by X. If X=0, R is Y.<br/>For other argument values, R is given by the expression Y-X×⌊Y÷X+0=X. This expression also applies when X and/or Y are complex if the simple ⌊ is replaced by the CpxFloor function. See Complex Floor.<br/>⎕CT and ⎕DCT are  implicit arguments of Residue.<br/>Note that the ASCII Broken Bar (⎕UCS 166, U+00A6) is not interpreted as Residue.",Residue
|,Stile;Vertical Bar<br/>Monadic: Magnitude<br/>Dyadic: Residue;Modulus
Upstile,⌈
Monadic: Ceiling,⌈
"Ceiling is defined in terms of Floor as ⌈Y←→-⌊-Y<br/>Y must be numeric.<br/>If an element of Y is real, the corresponding element of R is the least integer greater than or equal to the value of Y. <br/>If an element of Y is complex, the corresponding element of R depends on the relationship between the real and imaginary parts of the numbers in Y.<br/>For further explanation, see Floor.<br/>⎕CT is an implied argument of Ceiling. ",⌈
⌈,"Ceiling is defined in terms of Floor as ⌈Y←→-⌊-Y<br/>Y must be numeric.<br/>If an element of Y is real, the corresponding element of R is the least integer greater than or equal to the value of Y. <br/>If an element of Y is complex, the corresponding element of R depends on the relationship between the real and imaginary parts of the numbers in Y.<br/>For further explanation, see Floor.<br/>⎕CT is an implied argument of Ceiling. "
Ceiling,"Ceiling is defined in terms of Floor as ⌈Y←→-⌊-Y<br/>Y must be numeric.<br/>If an element of Y is real, the corresponding element of R is the least integer greater than or equal to the value of Y. <br/>If an element of Y is complex, the corresponding element of R depends on the relationship between the real and imaginary parts of the numbers in Y.<br/>For further explanation, see Floor.<br/>⎕CT is an implied argument of Ceiling. "
"Ceiling is defined in terms of Floor as ⌈Y←→-⌊-Y<br/>Y must be numeric.<br/>If an element of Y is real, the corresponding element of R is the least integer greater than or equal to the value of Y. <br/>If an element of Y is complex, the corresponding element of R depends on the relationship between the real and imaginary parts of the numbers in Y.<br/>For further explanation, see Floor.<br/>⎕CT is an implied argument of Ceiling. ",Ceiling
Dyadic: Maximum,⌈
Y may be any numeric array.  X may be any numeric array.  R is numeric.  R is the larger of the numbers X and Y.,⌈
⌈,Y may be any numeric array.  X may be any numeric array.  R is numeric.  R is the larger of the numbers X and Y.
Maximum,Y may be any numeric array.  X may be any numeric array.  R is numeric.  R is the larger of the numbers X and Y.
Y may be any numeric array.  X may be any numeric array.  R is numeric.  R is the larger of the numbers X and Y.,Maximum
⌈,Upstile<br/>Monadic: Ceiling<br/>Dyadic: Maximum
Downstile,⌊
Monadic: Floor,⌊
"Y must be numeric.<br/>For real numbers, R is the largest integer value less than or equal to Y within the comparison tolerance ⎕CT.<br/>For complex numbers, R depends on the relationship between the real and imaginary parts of the numbers in Y.<br/>The following (deliberately) simple function illustrates one way to express the rules for evaluating complex Floor.<br/>⎕CT and ⎕DCT are  implicit arguments of Floor.",⌊
⌊,"Y must be numeric.<br/>For real numbers, R is the largest integer value less than or equal to Y within the comparison tolerance ⎕CT.<br/>For complex numbers, R depends on the relationship between the real and imaginary parts of the numbers in Y.<br/>The following (deliberately) simple function illustrates one way to express the rules for evaluating complex Floor.<br/>⎕CT and ⎕DCT are  implicit arguments of Floor."
Floor,"Y must be numeric.<br/>For real numbers, R is the largest integer value less than or equal to Y within the comparison tolerance ⎕CT.<br/>For complex numbers, R depends on the relationship between the real and imaginary parts of the numbers in Y.<br/>The following (deliberately) simple function illustrates one way to express the rules for evaluating complex Floor.<br/>⎕CT and ⎕DCT are  implicit arguments of Floor."
"Y must be numeric.<br/>For real numbers, R is the largest integer value less than or equal to Y within the comparison tolerance ⎕CT.<br/>For complex numbers, R depends on the relationship between the real and imaginary parts of the numbers in Y.<br/>The following (deliberately) simple function illustrates one way to express the rules for evaluating complex Floor.<br/>⎕CT and ⎕DCT are  implicit arguments of Floor.",Floor
Dyadic: Minimum,⌊
Y may be any numeric array.  X may be any numeric array.  R is numeric.  R is the smaller of X and Y.,⌊
⌊,Y may be any numeric array.  X may be any numeric array.  R is numeric.  R is the smaller of X and Y.
Minimum,Y may be any numeric array.  X may be any numeric array.  R is numeric.  R is the smaller of X and Y.
Y may be any numeric array.  X may be any numeric array.  R is numeric.  R is the smaller of X and Y.,Minimum
⌊,Downstile<br/>Monadic: Floor<br/>Dyadic: Minimum
Star,*
Monadic: Exponential,*
"Y must be numeric. R is numeric and is the Yth power of e, the base of natural logarithms.",*
*,"Y must be numeric. R is numeric and is the Yth power of e, the base of natural logarithms."
Exponential,"Y must be numeric. R is numeric and is the Yth power of e, the base of natural logarithms."
"Y must be numeric. R is numeric and is the Yth power of e, the base of natural logarithms.",Exponential
Dyadic: Power,*
"Y must be a numeric array.  X must be a numeric array.  R is numeric.  The value of R is X raised to the power of Y.<br/>If Y is zero, R is defined to be 1.<br/>If X is zero, Y must be non-negative.<br/>In general, X*Y is defined as *Y×⍟X. If X is negative, the result R is likely to be complex.",*
*,"Y must be a numeric array.  X must be a numeric array.  R is numeric.  The value of R is X raised to the power of Y.<br/>If Y is zero, R is defined to be 1.<br/>If X is zero, Y must be non-negative.<br/>In general, X*Y is defined as *Y×⍟X. If X is negative, the result R is likely to be complex."
Power,"Y must be a numeric array.  X must be a numeric array.  R is numeric.  The value of R is X raised to the power of Y.<br/>If Y is zero, R is defined to be 1.<br/>If X is zero, Y must be non-negative.<br/>In general, X*Y is defined as *Y×⍟X. If X is negative, the result R is likely to be complex."
"Y must be a numeric array.  X must be a numeric array.  R is numeric.  The value of R is X raised to the power of Y.<br/>If Y is zero, R is defined to be 1.<br/>If X is zero, Y must be non-negative.<br/>In general, X*Y is defined as *Y×⍟X. If X is negative, the result R is likely to be complex.",Power
*,Star<br/>Monadic: Exponential<br/>Dyadic: Power
Log;Circle Star,⍟
Monadic: Natural Logarithm,⍟
Y must be a numeric array. R is numeric.  R is the natural (or Napierian) logarithm of Y whose base is the mathematical constant e=2.71828....,⍟
⍟,Y must be a numeric array. R is numeric.  R is the natural (or Napierian) logarithm of Y whose base is the mathematical constant e=2.71828....
NaturalLogarithm,⍟
NaturalLogarithm,Y must be a numeric array. R is numeric.  R is the natural (or Napierian) logarithm of Y whose base is the mathematical constant e=2.71828....
Y must be a numeric array. R is numeric.  R is the natural (or Napierian) logarithm of Y whose base is the mathematical constant e=2.71828....,NaturalLogarithm
Dyadic: Logarithm,⍟
X and Y must be numeric arrays. X cannot be 1 unless Y is also 1. R is the base X logarithm of Y.<br/>Note that Logarithm (dyadic ⍟) is defined in terms of Natural Logarithm (monadic ⍟) as:,⍟
⍟,X and Y must be numeric arrays. X cannot be 1 unless Y is also 1. R is the base X logarithm of Y.<br/>Note that Logarithm (dyadic ⍟) is defined in terms of Natural Logarithm (monadic ⍟) as:
Logarithm,X and Y must be numeric arrays. X cannot be 1 unless Y is also 1. R is the base X logarithm of Y.<br/>Note that Logarithm (dyadic ⍟) is defined in terms of Natural Logarithm (monadic ⍟) as:
X and Y must be numeric arrays. X cannot be 1 unless Y is also 1. R is the base X logarithm of Y.<br/>Note that Logarithm (dyadic ⍟) is defined in terms of Natural Logarithm (monadic ⍟) as:,Logarithm
⍟,Log;Circle Star<br/>Monadic: Natural Logarithm<br/>Dyadic: Logarithm
Circle,○
Monadic: Pi Times,○
"Y may be any numeric array. R is numeric. The value of R is the product of the mathematical constant π=3.14159... (Pi), and Y.",○
○,"Y may be any numeric array. R is numeric. The value of R is the product of the mathematical constant π=3.14159... (Pi), and Y."
PiTimes,○
PiTimes,"Y may be any numeric array. R is numeric. The value of R is the product of the mathematical constant π=3.14159... (Pi), and Y."
"Y may be any numeric array. R is numeric. The value of R is the product of the mathematical constant π=3.14159... (Pi), and Y.",PiTimes
Dyadic: Circular Function (Trig),○
"Y must be numeric.  X must be an integer in the range ¯12 ≤ X ≤ 12. R is numeric.<br/>X determines which of a family of trigonometric, hyperbolic, Pythagorean  and complex functions to apply to Y, from the following table. Note that when Y is complex, a and  b are used to represent its real and imaginary parts, while θ represents its phase.",○
○,"Y must be numeric.  X must be an integer in the range ¯12 ≤ X ≤ 12. R is numeric.<br/>X determines which of a family of trigonometric, hyperbolic, Pythagorean  and complex functions to apply to Y, from the following table. Note that when Y is complex, a and  b are used to represent its real and imaginary parts, while θ represents its phase."
Circular,"Y must be numeric.  X must be an integer in the range ¯12 ≤ X ≤ 12. R is numeric.<br/>X determines which of a family of trigonometric, hyperbolic, Pythagorean  and complex functions to apply to Y, from the following table. Note that when Y is complex, a and  b are used to represent its real and imaginary parts, while θ represents its phase."
"Y must be numeric.  X must be an integer in the range ¯12 ≤ X ≤ 12. R is numeric.<br/>X determines which of a family of trigonometric, hyperbolic, Pythagorean  and complex functions to apply to Y, from the following table. Note that when Y is complex, a and  b are used to represent its real and imaginary parts, while θ represents its phase.",Circular
○,Circle<br/>Monadic: Pi Times<br/>Dyadic: Circular Function (Trig)
Exclamation Mark;Quote Dot,!
Monadic: Factorial,!
"Y must be numeric excluding negative integers.  R is numeric.  R is the product of the first Y integers for positive integer values of Y. In general, !Y is gamma Y+1.",!
!,"Y must be numeric excluding negative integers.  R is numeric.  R is the product of the first Y integers for positive integer values of Y. In general, !Y is gamma Y+1."
Factorial,"Y must be numeric excluding negative integers.  R is numeric.  R is the product of the first Y integers for positive integer values of Y. In general, !Y is gamma Y+1."
"Y must be numeric excluding negative integers.  R is numeric.  R is the product of the first Y integers for positive integer values of Y. In general, !Y is gamma Y+1.",Factorial
Dyadic: Binomial,!
"X and Y may be any numbers except that if Y is a negative integer then X must be an integer. R is numeric. An element of R is integer if corresponding elements of X and Y are integers. <br/>Binomial is defined in terms of the function Factorial: <br/>Results are derived smoothly from the Beta function:<br/>For positive integer arguments, R is the number of selections of X things from Y things.",!
!,"X and Y may be any numbers except that if Y is a negative integer then X must be an integer. R is numeric. An element of R is integer if corresponding elements of X and Y are integers. <br/>Binomial is defined in terms of the function Factorial: <br/>Results are derived smoothly from the Beta function:<br/>For positive integer arguments, R is the number of selections of X things from Y things."
Binomial,"X and Y may be any numbers except that if Y is a negative integer then X must be an integer. R is numeric. An element of R is integer if corresponding elements of X and Y are integers. <br/>Binomial is defined in terms of the function Factorial: <br/>Results are derived smoothly from the Beta function:<br/>For positive integer arguments, R is the number of selections of X things from Y things."
"X and Y may be any numbers except that if Y is a negative integer then X must be an integer. R is numeric. An element of R is integer if corresponding elements of X and Y are integers. <br/>Binomial is defined in terms of the function Factorial: <br/>Results are derived smoothly from the Beta function:<br/>For positive integer arguments, R is the number of selections of X things from Y things.",Binomial
!,Exclamation Mark;Quote Dot<br/>Monadic: Factorial<br/>Dyadic: Binomial
Question Mark;Query,?
Monadic: Roll,?
"Y may be any non-negative integer array. R has the same shape as Y at each depth.<br/>For each positive element of Y the corresponding element of R is an integer, pseudo-randomly selected from the integers ⍳Y with each integer in this population having an equal chance of being selected.<br/>For each zero element of Y, the corresponding element of R is a pseudo-random floating-point value in the range 0 - 1, but excluding 0 and 1, i.e. (0<R[I]<1).<br/>⎕IO and ⎕RL are implicit arguments of Roll. A side effect of Roll is to change the value of ⎕RL. <br/>Note that different random number generators are available; see ⎕RL for more information.",?
?,"Y may be any non-negative integer array. R has the same shape as Y at each depth.<br/>For each positive element of Y the corresponding element of R is an integer, pseudo-randomly selected from the integers ⍳Y with each integer in this population having an equal chance of being selected.<br/>For each zero element of Y, the corresponding element of R is a pseudo-random floating-point value in the range 0 - 1, but excluding 0 and 1, i.e. (0<R[I]<1).<br/>⎕IO and ⎕RL are implicit arguments of Roll. A side effect of Roll is to change the value of ⎕RL. <br/>Note that different random number generators are available; see ⎕RL for more information."
Roll,"Y may be any non-negative integer array. R has the same shape as Y at each depth.<br/>For each positive element of Y the corresponding element of R is an integer, pseudo-randomly selected from the integers ⍳Y with each integer in this population having an equal chance of being selected.<br/>For each zero element of Y, the corresponding element of R is a pseudo-random floating-point value in the range 0 - 1, but excluding 0 and 1, i.e. (0<R[I]<1).<br/>⎕IO and ⎕RL are implicit arguments of Roll. A side effect of Roll is to change the value of ⎕RL. <br/>Note that different random number generators are available; see ⎕RL for more information."
"Y may be any non-negative integer array. R has the same shape as Y at each depth.<br/>For each positive element of Y the corresponding element of R is an integer, pseudo-randomly selected from the integers ⍳Y with each integer in this population having an equal chance of being selected.<br/>For each zero element of Y, the corresponding element of R is a pseudo-random floating-point value in the range 0 - 1, but excluding 0 and 1, i.e. (0<R[I]<1).<br/>⎕IO and ⎕RL are implicit arguments of Roll. A side effect of Roll is to change the value of ⎕RL. <br/>Note that different random number generators are available; see ⎕RL for more information.",Roll
Dyadic: Deal,?
Y must be a simple scalar or 1-element vector containing a non-negative integer. X must be a simple scalar or 1-element vector containing a non-negative integer and X≤Y.<br/>R is an integer  vector obtained by making X random selections from ⍳Y without repetition. <br/>⎕IO and ⎕RL are implicit arguments of Deal. A side effect of Deal is to change the value of ⎕RL. See Random Number Seed.,?
?,Y must be a simple scalar or 1-element vector containing a non-negative integer. X must be a simple scalar or 1-element vector containing a non-negative integer and X≤Y.<br/>R is an integer  vector obtained by making X random selections from ⍳Y without repetition. <br/>⎕IO and ⎕RL are implicit arguments of Deal. A side effect of Deal is to change the value of ⎕RL. See Random Number Seed.
Deal,Y must be a simple scalar or 1-element vector containing a non-negative integer. X must be a simple scalar or 1-element vector containing a non-negative integer and X≤Y.<br/>R is an integer  vector obtained by making X random selections from ⍳Y without repetition. <br/>⎕IO and ⎕RL are implicit arguments of Deal. A side effect of Deal is to change the value of ⎕RL. See Random Number Seed.
Y must be a simple scalar or 1-element vector containing a non-negative integer. X must be a simple scalar or 1-element vector containing a non-negative integer and X≤Y.<br/>R is an integer  vector obtained by making X random selections from ⍳Y without repetition. <br/>⎕IO and ⎕RL are implicit arguments of Deal. A side effect of Deal is to change the value of ⎕RL. See Random Number Seed.,Deal
?,Question Mark;Query<br/>Monadic: Roll<br/>Dyadic: Deal
Tilde,~
Monadic: Not,~
"Y must be a Boolean array.  R is Boolean.  The value of R is 0 if Y is 1, and R is 1 if Y is 0.",~
~,"Y must be a Boolean array.  R is Boolean.  The value of R is 0 if Y is 1, and R is 1 if Y is 0."
Not,"Y must be a Boolean array.  R is Boolean.  The value of R is 0 if Y is 1, and R is 1 if Y is 0."
"Y must be a Boolean array.  R is Boolean.  The value of R is 0 if Y is 1, and R is 1 if Y is 0.",Not
Dyadic: Without;Excluding,~
"X must be a scalar or vector.  R is a vector of the elements of X excluding those elements which occur in Y taken in the order in which they occur in X.<br/>Elements of X and Y are considered the same if X≡Y returns 1 for those elements.<br/>⎕CT and ⎕DCT are  implicit arguments of Excluding. Excluding is also known as Without.<br/>For performance information, see Search Functions and Hash Tables.",~
~,"X must be a scalar or vector.  R is a vector of the elements of X excluding those elements which occur in Y taken in the order in which they occur in X.<br/>Elements of X and Y are considered the same if X≡Y returns 1 for those elements.<br/>⎕CT and ⎕DCT are  implicit arguments of Excluding. Excluding is also known as Without.<br/>For performance information, see Search Functions and Hash Tables."
Excluding,"X must be a scalar or vector.  R is a vector of the elements of X excluding those elements which occur in Y taken in the order in which they occur in X.<br/>Elements of X and Y are considered the same if X≡Y returns 1 for those elements.<br/>⎕CT and ⎕DCT are  implicit arguments of Excluding. Excluding is also known as Without.<br/>For performance information, see Search Functions and Hash Tables."
"X must be a scalar or vector.  R is a vector of the elements of X excluding those elements which occur in Y taken in the order in which they occur in X.<br/>Elements of X and Y are considered the same if X≡Y returns 1 for those elements.<br/>⎕CT and ⎕DCT are  implicit arguments of Excluding. Excluding is also known as Without.<br/>For performance information, see Search Functions and Hash Tables.",Excluding
~,Tilde<br/>Monadic: Not<br/>Dyadic: Without;Excluding
Logical AND,∧
Dyadic: Lowest Common Multiple (AND),∧
"R is Boolean is determined as follows:<br/>Note that the ASCII caret (^) will also be interpreted as an APL And (^).<br/>R is the lowest common multiple of X and Y. Note that in this case, ⎕CT and ⎕DCT are implicit arguments.",∧
∧,"R is Boolean is determined as follows:<br/>Note that the ASCII caret (^) will also be interpreted as an APL And (^).<br/>R is the lowest common multiple of X and Y. Note that in this case, ⎕CT and ⎕DCT are implicit arguments."
AndLowestCommonMultiple,∧
AndLowestCommonMultiple,"R is Boolean is determined as follows:<br/>Note that the ASCII caret (^) will also be interpreted as an APL And (^).<br/>R is the lowest common multiple of X and Y. Note that in this case, ⎕CT and ⎕DCT are implicit arguments."
"R is Boolean is determined as follows:<br/>Note that the ASCII caret (^) will also be interpreted as an APL And (^).<br/>R is the lowest common multiple of X and Y. Note that in this case, ⎕CT and ⎕DCT are implicit arguments.",AndLowestCommonMultiple
∧,Logical AND<br/>Dyadic: Lowest Common Multiple (AND)
Logical Or,∨
Dyadic: Greatest Common Divisor (Or),∨
" R is Boolean and is determined as follows:<br/>R is the Greatest Common Divisor of X and Y. Note that in this case, ⎕CT and ⎕DCT are implicit arguments.",∨
∨," R is Boolean and is determined as follows:<br/>R is the Greatest Common Divisor of X and Y. Note that in this case, ⎕CT and ⎕DCT are implicit arguments."
OrGCD,∨
OrGCD," R is Boolean and is determined as follows:<br/>R is the Greatest Common Divisor of X and Y. Note that in this case, ⎕CT and ⎕DCT are implicit arguments."
" R is Boolean and is determined as follows:<br/>R is the Greatest Common Divisor of X and Y. Note that in this case, ⎕CT and ⎕DCT are implicit arguments.",OrGCD
∨,Logical Or<br/>Dyadic: Greatest Common Divisor (Or)
Logical NAND,⍲
Dyadic: NAND,⍲
"Y must be a Boolean array.  X must be a Boolean array.  R is Boolean.  The value of R is the truth value of the proposition ""not both X and Y"", and is determined as follows:",⍲
⍲,"Y must be a Boolean array.  X must be a Boolean array.  R is Boolean.  The value of R is the truth value of the proposition ""not both X and Y"", and is determined as follows:"
Nand,⍲
Nand,"Y must be a Boolean array.  X must be a Boolean array.  R is Boolean.  The value of R is the truth value of the proposition ""not both X and Y"", and is determined as follows:"
"Y must be a Boolean array.  X must be a Boolean array.  R is Boolean.  The value of R is the truth value of the proposition ""not both X and Y"", and is determined as follows:",Nand
⍲,Logical NAND<br/>Dyadic: NAND
Logical NOR,⍱
Dyadic: NOR,⍱
"Y must be a Boolean array.  X must be a Boolean array.  R is Boolean.  The value of R is the truth value of the proposition ""neither X nor Y"", and is determined as follows:",⍱
⍱,"Y must be a Boolean array.  X must be a Boolean array.  R is Boolean.  The value of R is the truth value of the proposition ""neither X nor Y"", and is determined as follows:"
Nor,⍱
Nor,"Y must be a Boolean array.  X must be a Boolean array.  R is Boolean.  The value of R is the truth value of the proposition ""neither X nor Y"", and is determined as follows:"
"Y must be a Boolean array.  X must be a Boolean array.  R is Boolean.  The value of R is the truth value of the proposition ""neither X nor Y"", and is determined as follows:",Nor
⍱,Logical NOR<br/>Dyadic: NOR
Less Than Sign,<
Dyadic: Less Than,<
Y may be any numeric array.  X may be any numeric array.  R is Boolean.  R is 1 if X is less than Y and X=Y is 0.  Otherwise R is 0.<br/>⎕CT and ⎕DCT are  implicit arguments of Less.,<
<,Y may be any numeric array.  X may be any numeric array.  R is Boolean.  R is 1 if X is less than Y and X=Y is 0.  Otherwise R is 0.<br/>⎕CT and ⎕DCT are  implicit arguments of Less.
Less,Y may be any numeric array.  X may be any numeric array.  R is Boolean.  R is 1 if X is less than Y and X=Y is 0.  Otherwise R is 0.<br/>⎕CT and ⎕DCT are  implicit arguments of Less.
Y may be any numeric array.  X may be any numeric array.  R is Boolean.  R is 1 if X is less than Y and X=Y is 0.  Otherwise R is 0.<br/>⎕CT and ⎕DCT are  implicit arguments of Less.,Less
<,Less Than Sign<br/>Dyadic: Less Than
Less Than Or Equal To Sign,≤
Dyadic: Is Less Or Equal To,≤
Y may be any numeric array.  X may be any numeric array.  R is Boolean.  R is 1 if X is less than Y or X=Y.  Otherwise R is 0.<br/>⎕CT and ⎕DCT are  implicit arguments of Less Or Equal.,≤
≤,Y may be any numeric array.  X may be any numeric array.  R is Boolean.  R is 1 if X is less than Y or X=Y.  Otherwise R is 0.<br/>⎕CT and ⎕DCT are  implicit arguments of Less Or Equal.
LessOrEqual,≤
LessOrEqual,Y may be any numeric array.  X may be any numeric array.  R is Boolean.  R is 1 if X is less than Y or X=Y.  Otherwise R is 0.<br/>⎕CT and ⎕DCT are  implicit arguments of Less Or Equal.
Y may be any numeric array.  X may be any numeric array.  R is Boolean.  R is 1 if X is less than Y or X=Y.  Otherwise R is 0.<br/>⎕CT and ⎕DCT are  implicit arguments of Less Or Equal.,LessOrEqual
≤,Less Than Or Equal To Sign<br/>Dyadic: Is Less Or Equal To
Equal Sign,=
Dyadic: Equal To,=
"Y may be any array. X may be any array. R is Boolean.<br/> ⎕CT and ⎕DCT are  implicit arguments of Equal. <br/>If X and Y are refs, then R is 1 if they are refs to the same object. If X is a ref and Y is not, or vice-versa, then R is 0.<br/>If X and Y are character, then R is 1 if they are the same character. If X is character and Y is numeric, or vice-versa, then R is 0.<br/>If X and Y are numeric, then R is 1 if X and Y are within comparison tolerance of each other.<br/>For real numbers X and Y, X is considered equal to Y if (|X-Y) is not greater than ⎕CT×(|X)⌈|Y.<br/>For complex numbers X=Y is 1 if the magnitude of X-Y does not exceed ⎕CT times the larger of the magnitudes of X and Y; geometrically, X=Y if the number smaller in magnitude lies on or within a circle centred on the one with larger magnitude, having radius ⎕CT times the larger magnitude.",=
=,"Y may be any array. X may be any array. R is Boolean.<br/> ⎕CT and ⎕DCT are  implicit arguments of Equal. <br/>If X and Y are refs, then R is 1 if they are refs to the same object. If X is a ref and Y is not, or vice-versa, then R is 0.<br/>If X and Y are character, then R is 1 if they are the same character. If X is character and Y is numeric, or vice-versa, then R is 0.<br/>If X and Y are numeric, then R is 1 if X and Y are within comparison tolerance of each other.<br/>For real numbers X and Y, X is considered equal to Y if (|X-Y) is not greater than ⎕CT×(|X)⌈|Y.<br/>For complex numbers X=Y is 1 if the magnitude of X-Y does not exceed ⎕CT times the larger of the magnitudes of X and Y; geometrically, X=Y if the number smaller in magnitude lies on or within a circle centred on the one with larger magnitude, having radius ⎕CT times the larger magnitude."
Equal,"Y may be any array. X may be any array. R is Boolean.<br/> ⎕CT and ⎕DCT are  implicit arguments of Equal. <br/>If X and Y are refs, then R is 1 if they are refs to the same object. If X is a ref and Y is not, or vice-versa, then R is 0.<br/>If X and Y are character, then R is 1 if they are the same character. If X is character and Y is numeric, or vice-versa, then R is 0.<br/>If X and Y are numeric, then R is 1 if X and Y are within comparison tolerance of each other.<br/>For real numbers X and Y, X is considered equal to Y if (|X-Y) is not greater than ⎕CT×(|X)⌈|Y.<br/>For complex numbers X=Y is 1 if the magnitude of X-Y does not exceed ⎕CT times the larger of the magnitudes of X and Y; geometrically, X=Y if the number smaller in magnitude lies on or within a circle centred on the one with larger magnitude, having radius ⎕CT times the larger magnitude."
"Y may be any array. X may be any array. R is Boolean.<br/> ⎕CT and ⎕DCT are  implicit arguments of Equal. <br/>If X and Y are refs, then R is 1 if they are refs to the same object. If X is a ref and Y is not, or vice-versa, then R is 0.<br/>If X and Y are character, then R is 1 if they are the same character. If X is character and Y is numeric, or vice-versa, then R is 0.<br/>If X and Y are numeric, then R is 1 if X and Y are within comparison tolerance of each other.<br/>For real numbers X and Y, X is considered equal to Y if (|X-Y) is not greater than ⎕CT×(|X)⌈|Y.<br/>For complex numbers X=Y is 1 if the magnitude of X-Y does not exceed ⎕CT times the larger of the magnitudes of X and Y; geometrically, X=Y if the number smaller in magnitude lies on or within a circle centred on the one with larger magnitude, having radius ⎕CT times the larger magnitude.",Equal
=,Equal Sign<br/>Dyadic: Equal To
Greater Than Sign,>
Dyadic: Greater Than,>
Y must be numeric.  X must be numeric.  R is Boolean.  R is 1 if X is greater than Y and X=Y is 0.  Otherwise R is 0.<br/>⎕CT and ⎕DCT are  implicit arguments of Greater.,>
>,Y must be numeric.  X must be numeric.  R is Boolean.  R is 1 if X is greater than Y and X=Y is 0.  Otherwise R is 0.<br/>⎕CT and ⎕DCT are  implicit arguments of Greater.
Greater,Y must be numeric.  X must be numeric.  R is Boolean.  R is 1 if X is greater than Y and X=Y is 0.  Otherwise R is 0.<br/>⎕CT and ⎕DCT are  implicit arguments of Greater.
Y must be numeric.  X must be numeric.  R is Boolean.  R is 1 if X is greater than Y and X=Y is 0.  Otherwise R is 0.<br/>⎕CT and ⎕DCT are  implicit arguments of Greater.,Greater
>,Greater Than Sign<br/>Dyadic: Greater Than
Greater Than Or Equal To Sign,≥
Dyadic: Is Greater Or Equal To,≥
Y must be numeric.  X must be numeric.  R is Boolean.  R is 1 if X is greater than Y or X=Y.  Otherwise R is 0.<br/>⎕CT and ⎕DCT are  implicit arguments of Greater Or Equal.,≥
≥,Y must be numeric.  X must be numeric.  R is Boolean.  R is 1 if X is greater than Y or X=Y.  Otherwise R is 0.<br/>⎕CT and ⎕DCT are  implicit arguments of Greater Or Equal.
GreaterOrEqual,≥
GreaterOrEqual,Y must be numeric.  X must be numeric.  R is Boolean.  R is 1 if X is greater than Y or X=Y.  Otherwise R is 0.<br/>⎕CT and ⎕DCT are  implicit arguments of Greater Or Equal.
Y must be numeric.  X must be numeric.  R is Boolean.  R is 1 if X is greater than Y or X=Y.  Otherwise R is 0.<br/>⎕CT and ⎕DCT are  implicit arguments of Greater Or Equal.,GreaterOrEqual
≥,Greater Than Or Equal To Sign<br/>Dyadic: Is Greater Or Equal To
Not Equal,≠
Monadic: Unique Mask,≠
"Y may be any array.<br/>R is a Boolean vector whose length is the number of major cells
in Y. For each major cell of Y, the corresponding element of  R is 1 if it is the first occurrence of that value, and 0 if it is a duplicate of an earlier major cell.<br/>⎕CT and ⎕DCT are  implicit arguments of Unique.",≠
≠,"Y may be any array.<br/>R is a Boolean vector whose length is the number of major cells
in Y. For each major cell of Y, the corresponding element of  R is 1 if it is the first occurrence of that value, and 0 if it is a duplicate of an earlier major cell.<br/>⎕CT and ⎕DCT are  implicit arguments of Unique."
Unique_Mask,≠
Unique_Mask,"Y may be any array.<br/>R is a Boolean vector whose length is the number of major cells
in Y. For each major cell of Y, the corresponding element of  R is 1 if it is the first occurrence of that value, and 0 if it is a duplicate of an earlier major cell.<br/>⎕CT and ⎕DCT are  implicit arguments of Unique."
"Y may be any array.<br/>R is a Boolean vector whose length is the number of major cells
in Y. For each major cell of Y, the corresponding element of  R is 1 if it is the first occurrence of that value, and 0 if it is a duplicate of an earlier major cell.<br/>⎕CT and ⎕DCT are  implicit arguments of Unique.",Unique_Mask
Dyadic: Not Equal To,≠
"Y may be any array.  X may be any array.  R is Boolean.  R is 0 if X=Y.  Otherwise R is 1.<br/>For Boolean X and Y, the value of R is the exclusive or (XOR)  result, determined as follows:<br/>⎕CT and ⎕DCT are  implicit arguments of Not Equal.",≠
≠,"Y may be any array.  X may be any array.  R is Boolean.  R is 0 if X=Y.  Otherwise R is 1.<br/>For Boolean X and Y, the value of R is the exclusive or (XOR)  result, determined as follows:<br/>⎕CT and ⎕DCT are  implicit arguments of Not Equal."
NotEqual,≠
NotEqual,"Y may be any array.  X may be any array.  R is Boolean.  R is 0 if X=Y.  Otherwise R is 1.<br/>For Boolean X and Y, the value of R is the exclusive or (XOR)  result, determined as follows:<br/>⎕CT and ⎕DCT are  implicit arguments of Not Equal."
"Y may be any array.  X may be any array.  R is Boolean.  R is 0 if X=Y.  Otherwise R is 1.<br/>For Boolean X and Y, the value of R is the exclusive or (XOR)  result, determined as follows:<br/>⎕CT and ⎕DCT are  implicit arguments of Not Equal.",NotEqual
≠,Not Equal<br/>Monadic: Unique Mask<br/>Dyadic: Not Equal To
Equal Underbar,≡
Monadic: Depth,≡
"Y may be any array. R is the maximum number of levels of nesting of Y. A simple scalar (rank-0 number, character or namespace-reference) has a depth of 0.<br/>A higher rank array, all of whose items are simple scalars, is termed a simple array and has a depth of 1. An array whose items are not all simple scalars is nested and has a depth 1 greater than that of its most deeply nested item.<br/>Y is of uniform depth if it is simple or if all of its items have the same uniform depth.<br/>If ⎕ML<2 and Y is not of uniform depth then R is negated (therefore, when ⎕ML<2, a negative value of R indicates non-uniform depth).",≡
≡,"Y may be any array. R is the maximum number of levels of nesting of Y. A simple scalar (rank-0 number, character or namespace-reference) has a depth of 0.<br/>A higher rank array, all of whose items are simple scalars, is termed a simple array and has a depth of 1. An array whose items are not all simple scalars is nested and has a depth 1 greater than that of its most deeply nested item.<br/>Y is of uniform depth if it is simple or if all of its items have the same uniform depth.<br/>If ⎕ML<2 and Y is not of uniform depth then R is negated (therefore, when ⎕ML<2, a negative value of R indicates non-uniform depth)."
Depth,"Y may be any array. R is the maximum number of levels of nesting of Y. A simple scalar (rank-0 number, character or namespace-reference) has a depth of 0.<br/>A higher rank array, all of whose items are simple scalars, is termed a simple array and has a depth of 1. An array whose items are not all simple scalars is nested and has a depth 1 greater than that of its most deeply nested item.<br/>Y is of uniform depth if it is simple or if all of its items have the same uniform depth.<br/>If ⎕ML<2 and Y is not of uniform depth then R is negated (therefore, when ⎕ML<2, a negative value of R indicates non-uniform depth)."
"Y may be any array. R is the maximum number of levels of nesting of Y. A simple scalar (rank-0 number, character or namespace-reference) has a depth of 0.<br/>A higher rank array, all of whose items are simple scalars, is termed a simple array and has a depth of 1. An array whose items are not all simple scalars is nested and has a depth 1 greater than that of its most deeply nested item.<br/>Y is of uniform depth if it is simple or if all of its items have the same uniform depth.<br/>If ⎕ML<2 and Y is not of uniform depth then R is negated (therefore, when ⎕ML<2, a negative value of R indicates non-uniform depth).",Depth
Dyadic: Match,≡
"Y may be any array.  X may be any array.  R is a simple Boolean scalar.  If X is identical to Y, then R is 1.  Otherwise R is 0.<br/>Non-empty arrays are identical if they have the same structure and the same values in all corresponding locations.  Empty arrays are identical if they have the same shape and the same prototype (disclosed nested structure).<br/>⎕CT and ⎕DCT are  implicit arguments of Match.",≡
≡,"Y may be any array.  X may be any array.  R is a simple Boolean scalar.  If X is identical to Y, then R is 1.  Otherwise R is 0.<br/>Non-empty arrays are identical if they have the same structure and the same values in all corresponding locations.  Empty arrays are identical if they have the same shape and the same prototype (disclosed nested structure).<br/>⎕CT and ⎕DCT are  implicit arguments of Match."
Match,"Y may be any array.  X may be any array.  R is a simple Boolean scalar.  If X is identical to Y, then R is 1.  Otherwise R is 0.<br/>Non-empty arrays are identical if they have the same structure and the same values in all corresponding locations.  Empty arrays are identical if they have the same shape and the same prototype (disclosed nested structure).<br/>⎕CT and ⎕DCT are  implicit arguments of Match."
"Y may be any array.  X may be any array.  R is a simple Boolean scalar.  If X is identical to Y, then R is 1.  Otherwise R is 0.<br/>Non-empty arrays are identical if they have the same structure and the same values in all corresponding locations.  Empty arrays are identical if they have the same shape and the same prototype (disclosed nested structure).<br/>⎕CT and ⎕DCT are  implicit arguments of Match.",Match
≡,Equal Underbar<br/>Monadic: Depth<br/>Dyadic: Match
Equal Underbar Slash,≢
Monadic: Tally,≢
"Y may be any array.  R is a simple numeric scalar.<br/>Tally returns the number of major cells of Y. See Cells and Sub-arrays. <br/>This can also be expressed as the length of the leading axis or 1 if Y is a scalar. Tally is equivalent to the function {⍬⍴(⍴⍵),1}.<br/>Note that ≢V is useful for returning the length of vector V as a scalar.  (In contrast, ⍴V is a one-element vector.)",≢
≢,"Y may be any array.  R is a simple numeric scalar.<br/>Tally returns the number of major cells of Y. See Cells and Sub-arrays. <br/>This can also be expressed as the length of the leading axis or 1 if Y is a scalar. Tally is equivalent to the function {⍬⍴(⍴⍵),1}.<br/>Note that ≢V is useful for returning the length of vector V as a scalar.  (In contrast, ⍴V is a one-element vector.)"
Tally,"Y may be any array.  R is a simple numeric scalar.<br/>Tally returns the number of major cells of Y. See Cells and Sub-arrays. <br/>This can also be expressed as the length of the leading axis or 1 if Y is a scalar. Tally is equivalent to the function {⍬⍴(⍴⍵),1}.<br/>Note that ≢V is useful for returning the length of vector V as a scalar.  (In contrast, ⍴V is a one-element vector.)"
"Y may be any array.  R is a simple numeric scalar.<br/>Tally returns the number of major cells of Y. See Cells and Sub-arrays. <br/>This can also be expressed as the length of the leading axis or 1 if Y is a scalar. Tally is equivalent to the function {⍬⍴(⍴⍵),1}.<br/>Note that ≢V is useful for returning the length of vector V as a scalar.  (In contrast, ⍴V is a one-element vector.)",Tally
Dyadic: Not Match,≢
"Y may be any array.  X may be any array.  R is a simple Boolean scalar.  If X is identical to Y, then R is 0.  Otherwise R is 1.<br/>Non-empty arrays are identical if they have the same structure and the same values in all corresponding locations.  Empty arrays are identical if they have the same shape and the same prototype (disclosed nested structure).<br/>⎕CT and ⎕DCT are  implicit arguments of Not Match.",≢
≢,"Y may be any array.  X may be any array.  R is a simple Boolean scalar.  If X is identical to Y, then R is 0.  Otherwise R is 1.<br/>Non-empty arrays are identical if they have the same structure and the same values in all corresponding locations.  Empty arrays are identical if they have the same shape and the same prototype (disclosed nested structure).<br/>⎕CT and ⎕DCT are  implicit arguments of Not Match."
NotMatch,≢
NotMatch,"Y may be any array.  X may be any array.  R is a simple Boolean scalar.  If X is identical to Y, then R is 0.  Otherwise R is 1.<br/>Non-empty arrays are identical if they have the same structure and the same values in all corresponding locations.  Empty arrays are identical if they have the same shape and the same prototype (disclosed nested structure).<br/>⎕CT and ⎕DCT are  implicit arguments of Not Match."
"Y may be any array.  X may be any array.  R is a simple Boolean scalar.  If X is identical to Y, then R is 0.  Otherwise R is 1.<br/>Non-empty arrays are identical if they have the same structure and the same values in all corresponding locations.  Empty arrays are identical if they have the same shape and the same prototype (disclosed nested structure).<br/>⎕CT and ⎕DCT are  implicit arguments of Not Match.",NotMatch
≢,Equal Underbar Slash<br/>Monadic: Tally<br/>Dyadic: Not Match
Rho,⍴
Monadic: Shape Of,⍴
"Y may be any array.  R is a non-negative integer vector whose elements are the dimensions of Y.  If Y is a scalar, then R is an empty vector.  The rank of Y is given by ⍴⍴Y.",⍴
⍴,"Y may be any array.  R is a non-negative integer vector whose elements are the dimensions of Y.  If Y is a scalar, then R is an empty vector.  The rank of Y is given by ⍴⍴Y."
Shape,"Y may be any array.  R is a non-negative integer vector whose elements are the dimensions of Y.  If Y is a scalar, then R is an empty vector.  The rank of Y is given by ⍴⍴Y."
"Y may be any array.  R is a non-negative integer vector whose elements are the dimensions of Y.  If Y is a scalar, then R is an empty vector.  The rank of Y is given by ⍴⍴Y.",Shape
Dyadic: Reshape,⍴
"Y may be any array.  X must be a simple scalar or vector of non-negative integers.  R is an array of shape X whose elements are taken from Y in row-major sequence and repeated cyclically if required.  If Y is empty, R is composed of fill elements of Y (⊂∊⊃Y with ⎕ml←0).  If X contains at least one zero, then R is empty.  If X is an empty vector, then R is scalar.",⍴
⍴,"Y may be any array.  X must be a simple scalar or vector of non-negative integers.  R is an array of shape X whose elements are taken from Y in row-major sequence and repeated cyclically if required.  If Y is empty, R is composed of fill elements of Y (⊂∊⊃Y with ⎕ml←0).  If X contains at least one zero, then R is empty.  If X is an empty vector, then R is scalar."
Reshape,"Y may be any array.  X must be a simple scalar or vector of non-negative integers.  R is an array of shape X whose elements are taken from Y in row-major sequence and repeated cyclically if required.  If Y is empty, R is composed of fill elements of Y (⊂∊⊃Y with ⎕ml←0).  If X contains at least one zero, then R is empty.  If X is an empty vector, then R is scalar."
"Y may be any array.  X must be a simple scalar or vector of non-negative integers.  R is an array of shape X whose elements are taken from Y in row-major sequence and repeated cyclically if required.  If Y is empty, R is composed of fill elements of Y (⊂∊⊃Y with ⎕ml←0).  If X contains at least one zero, then R is empty.  If X is an empty vector, then R is scalar.",Reshape
⍴,Rho<br/>Monadic: Shape Of<br/>Dyadic: Reshape
Comma,","
Monadic: Ravel,","
Y may be any array.  R is a vector of the elements of Y taken in row-major order.<br/>See also: Ravel with Axes.,","
",",Y may be any array.  R is a vector of the elements of Y taken in row-major order.<br/>See also: Ravel with Axes.
Ravel,Y may be any array.  R is a vector of the elements of Y taken in row-major order.<br/>See also: Ravel with Axes.
Y may be any array.  R is a vector of the elements of Y taken in row-major order.<br/>See also: Ravel with Axes.,Ravel
"Dyadic: Catenate/Laminate
(Join)",","
"Y may be any array.  X may be any array.  The axis specification is optional.  If specified, K must be a numeric scalar or 1-element vector which may have a fractional value.  If not specified, the last axis is implied.<br/>The form R←X⍪Y may be used to imply catenation along the first axis.<br/>Two cases of the function catenate  are permitted:<br/>The arrays X and Y are joined along the required axis to form array R.  A scalar is extended to the shape of the other argument except that the required axis is restricted to a unit dimension.  X and Y must have the same shape (after extension) except along the required axis, or one of the arguments may have rank one less than the other, provided that their shapes conform to the prior rule after augmenting the array of lower rank to have a unit dimension along the required axis. The rank of R is the greater of the ranks of the arguments, but not less than 1.<br/>If, after extension, exactly one of X and Y have a length of zero along the joined axis, then the data type of R will be that of the argument with a non-zero length. Otherwise, the data type of R will be that of X.<br/>The arrays X and Y are joined along a new axis created before the ⌈Kth axis.  The new axis has a length of 2.  K must exceed ⎕IO (the index origin) minus 1, and K must be less than ⎕IO plus the greater of the ranks of X and Y.  A scalar  argument is extended to the shape of the other argument.  Otherwise X and Y must have the same shape.<br/>The rank of R is one plus the greater of the ranks of X and Y.",","
",","Y may be any array.  X may be any array.  The axis specification is optional.  If specified, K must be a numeric scalar or 1-element vector which may have a fractional value.  If not specified, the last axis is implied.<br/>The form R←X⍪Y may be used to imply catenation along the first axis.<br/>Two cases of the function catenate  are permitted:<br/>The arrays X and Y are joined along the required axis to form array R.  A scalar is extended to the shape of the other argument except that the required axis is restricted to a unit dimension.  X and Y must have the same shape (after extension) except along the required axis, or one of the arguments may have rank one less than the other, provided that their shapes conform to the prior rule after augmenting the array of lower rank to have a unit dimension along the required axis. The rank of R is the greater of the ranks of the arguments, but not less than 1.<br/>If, after extension, exactly one of X and Y have a length of zero along the joined axis, then the data type of R will be that of the argument with a non-zero length. Otherwise, the data type of R will be that of X.<br/>The arrays X and Y are joined along a new axis created before the ⌈Kth axis.  The new axis has a length of 2.  K must exceed ⎕IO (the index origin) minus 1, and K must be less than ⎕IO plus the greater of the ranks of X and Y.  A scalar  argument is extended to the shape of the other argument.  Otherwise X and Y must have the same shape.<br/>The rank of R is one plus the greater of the ranks of X and Y."
Catenate/Laminate,"Y may be any array.  X may be any array.  The axis specification is optional.  If specified, K must be a numeric scalar or 1-element vector which may have a fractional value.  If not specified, the last axis is implied.<br/>The form R←X⍪Y may be used to imply catenation along the first axis.<br/>Two cases of the function catenate  are permitted:<br/>The arrays X and Y are joined along the required axis to form array R.  A scalar is extended to the shape of the other argument except that the required axis is restricted to a unit dimension.  X and Y must have the same shape (after extension) except along the required axis, or one of the arguments may have rank one less than the other, provided that their shapes conform to the prior rule after augmenting the array of lower rank to have a unit dimension along the required axis. The rank of R is the greater of the ranks of the arguments, but not less than 1.<br/>If, after extension, exactly one of X and Y have a length of zero along the joined axis, then the data type of R will be that of the argument with a non-zero length. Otherwise, the data type of R will be that of X.<br/>The arrays X and Y are joined along a new axis created before the ⌈Kth axis.  The new axis has a length of 2.  K must exceed ⎕IO (the index origin) minus 1, and K must be less than ⎕IO plus the greater of the ranks of X and Y.  A scalar  argument is extended to the shape of the other argument.  Otherwise X and Y must have the same shape.<br/>The rank of R is one plus the greater of the ranks of X and Y."
"Y may be any array.  X may be any array.  The axis specification is optional.  If specified, K must be a numeric scalar or 1-element vector which may have a fractional value.  If not specified, the last axis is implied.<br/>The form R←X⍪Y may be used to imply catenation along the first axis.<br/>Two cases of the function catenate  are permitted:<br/>The arrays X and Y are joined along the required axis to form array R.  A scalar is extended to the shape of the other argument except that the required axis is restricted to a unit dimension.  X and Y must have the same shape (after extension) except along the required axis, or one of the arguments may have rank one less than the other, provided that their shapes conform to the prior rule after augmenting the array of lower rank to have a unit dimension along the required axis. The rank of R is the greater of the ranks of the arguments, but not less than 1.<br/>If, after extension, exactly one of X and Y have a length of zero along the joined axis, then the data type of R will be that of the argument with a non-zero length. Otherwise, the data type of R will be that of X.<br/>The arrays X and Y are joined along a new axis created before the ⌈Kth axis.  The new axis has a length of 2.  K must exceed ⎕IO (the index origin) minus 1, and K must be less than ⎕IO plus the greater of the ranks of X and Y.  A scalar  argument is extended to the shape of the other argument.  Otherwise X and Y must have the same shape.<br/>The rank of R is one plus the greater of the ranks of X and Y.",Catenate/Laminate
",","Comma<br/>Monadic: Ravel<br/>Dyadic: Catenate/Laminate
(Join)"
Comma Bar,⍪
Monadic: Table,⍪
"Y may be any array. R is a 2-dimensional matrix of the elements of Y taken in row-major order, preserving the shape of the first dimension of Y if it exists <br/>Table has been implemented according to the Extended APL Standard (ISO/IEC 13751:2001).",⍪
⍪,"Y may be any array. R is a 2-dimensional matrix of the elements of Y taken in row-major order, preserving the shape of the first dimension of Y if it exists <br/>Table has been implemented according to the Extended APL Standard (ISO/IEC 13751:2001)."
Table,"Y may be any array. R is a 2-dimensional matrix of the elements of Y taken in row-major order, preserving the shape of the first dimension of Y if it exists <br/>Table has been implemented according to the Extended APL Standard (ISO/IEC 13751:2001)."
"Y may be any array. R is a 2-dimensional matrix of the elements of Y taken in row-major order, preserving the shape of the first dimension of Y if it exists <br/>Table has been implemented according to the Extended APL Standard (ISO/IEC 13751:2001).",Table
Dyadic: Catenate First,⍪
"The form R←X⍪Y implies catenation along the first axis whereas the form R←X,Y implies catenation along the last axis (columns).  See Catenate/Laminate.",⍪
⍪,"The form R←X⍪Y implies catenation along the first axis whereas the form R←X,Y implies catenation along the last axis (columns).  See Catenate/Laminate."
CatenateFirst,⍪
CatenateFirst,"The form R←X⍪Y implies catenation along the first axis whereas the form R←X,Y implies catenation along the last axis (columns).  See Catenate/Laminate."
"The form R←X⍪Y implies catenation along the first axis whereas the form R←X,Y implies catenation along the last axis (columns).  See Catenate/Laminate.",CatenateFirst
⍪,Comma Bar<br/>Monadic: Table<br/>Dyadic: Catenate First
Circle Stile,⌽
Monadic: Reverse,⌽
"Y may be any array.  The axis specification is optional.  If present, K must be an integer scalar or one-element vector.  The value of K must be an axis of Y.  If absent, the last axis is implied.  The form R←⊖Y implies the first axis.<br/>R is the array Y reversed on the Kth or implied axis.",⌽
⌽,"Y may be any array.  The axis specification is optional.  If present, K must be an integer scalar or one-element vector.  The value of K must be an axis of Y.  If absent, the last axis is implied.  The form R←⊖Y implies the first axis.<br/>R is the array Y reversed on the Kth or implied axis."
Reverse,"Y may be any array.  The axis specification is optional.  If present, K must be an integer scalar or one-element vector.  The value of K must be an axis of Y.  If absent, the last axis is implied.  The form R←⊖Y implies the first axis.<br/>R is the array Y reversed on the Kth or implied axis."
"Y may be any array.  The axis specification is optional.  If present, K must be an integer scalar or one-element vector.  The value of K must be an axis of Y.  If absent, the last axis is implied.  The form R←⊖Y implies the first axis.<br/>R is the array Y reversed on the Kth or implied axis.",Reverse
Dyadic: Rotate,⌽
"Y may be any array.  X must be a simple integer array.  The axis specification is optional.  If present, K must be a simple integer scalar or one-element vector.<br/>The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⊖Y implies the first axis.<br/>X must have the same shape as Y, excluding Y's Kth axis. Otherwise, if X is a one-element array, it will be extended to conform.<br/>R is an array with the same shape as Y, with the elements of each of the vectors along the Kth axis of Y rotated by the value of the corresponding element of X.  If the value is positive, the rotation is in the sense of right to left.  If the value is negative, the rotation is in the sense of left to right.",⌽
⌽,"Y may be any array.  X must be a simple integer array.  The axis specification is optional.  If present, K must be a simple integer scalar or one-element vector.<br/>The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⊖Y implies the first axis.<br/>X must have the same shape as Y, excluding Y's Kth axis. Otherwise, if X is a one-element array, it will be extended to conform.<br/>R is an array with the same shape as Y, with the elements of each of the vectors along the Kth axis of Y rotated by the value of the corresponding element of X.  If the value is positive, the rotation is in the sense of right to left.  If the value is negative, the rotation is in the sense of left to right."
Rotate,"Y may be any array.  X must be a simple integer array.  The axis specification is optional.  If present, K must be a simple integer scalar or one-element vector.<br/>The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⊖Y implies the first axis.<br/>X must have the same shape as Y, excluding Y's Kth axis. Otherwise, if X is a one-element array, it will be extended to conform.<br/>R is an array with the same shape as Y, with the elements of each of the vectors along the Kth axis of Y rotated by the value of the corresponding element of X.  If the value is positive, the rotation is in the sense of right to left.  If the value is negative, the rotation is in the sense of left to right."
"Y may be any array.  X must be a simple integer array.  The axis specification is optional.  If present, K must be a simple integer scalar or one-element vector.<br/>The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⊖Y implies the first axis.<br/>X must have the same shape as Y, excluding Y's Kth axis. Otherwise, if X is a one-element array, it will be extended to conform.<br/>R is an array with the same shape as Y, with the elements of each of the vectors along the Kth axis of Y rotated by the value of the corresponding element of X.  If the value is positive, the rotation is in the sense of right to left.  If the value is negative, the rotation is in the sense of left to right.",Rotate
⌽,Circle Stile<br/>Monadic: Reverse<br/>Dyadic: Rotate
Circle Bar,⊖
Monadic: Reverse First,⊖
The form R←⊖Y implies reversal along the first axis.  See Reverse.,⊖
⊖,The form R←⊖Y implies reversal along the first axis.  See Reverse.
ReverseFirst,⊖
ReverseFirst,The form R←⊖Y implies reversal along the first axis.  See Reverse.
The form R←⊖Y implies reversal along the first axis.  See Reverse.,ReverseFirst
Dyadic: Rotate First,⊖
The form R←X⊖Y implies rotation along the first axis.  See Rotate.,⊖
⊖,The form R←X⊖Y implies rotation along the first axis.  See Rotate.
RotateFirst,⊖
RotateFirst,The form R←X⊖Y implies rotation along the first axis.  See Rotate.
The form R←X⊖Y implies rotation along the first axis.  See Rotate.,RotateFirst
⊖,Circle Bar<br/>Monadic: Reverse First<br/>Dyadic: Rotate First
Circle Backslash,⍉
Monadic: Transpose,⍉
"Y may be any array.  R is an array of shape ⌽⍴Y, similar to Y with the order of the axes reversed.",⍉
⍉,"Y may be any array.  R is an array of shape ⌽⍴Y, similar to Y with the order of the axes reversed."
Transpose(Monadic),⍉
Transpose(Monadic),"Y may be any array.  R is an array of shape ⌽⍴Y, similar to Y with the order of the axes reversed."
"Y may be any array.  R is an array of shape ⌽⍴Y, similar to Y with the order of the axes reversed.",Transpose(Monadic)
Dyadic: DyadicTranspose,⍉
"Y may be any array.  X must be a simple scalar or vector whose elements are included in the set ⍳⍴⍴Y.  Integer values in X may be repeated but all integers in the set ⍳⌈/X must be included.  The length of X must equal the rank of Y.<br/>R is an array formed by the transposition of the axes of Y as specified by X.  The Ith element of X gives the new position for the Ith axis of Y.  If X repositions two or more axes of Y to the same axis, the elements used to fill this axis are those whose indices on the relevant axes of Y are equal.<br/>⎕IO is an implicit argument of Dyadic Transpose.<br/>Assign a distinct letter for each unique integer in X :<br/>If R←X⍉Y, then R[i;j;k;…] equals Y indexed by the letters corresponding to elements of X .<br/>From the above it can be seen that:",⍉
⍉,"Y may be any array.  X must be a simple scalar or vector whose elements are included in the set ⍳⍴⍴Y.  Integer values in X may be repeated but all integers in the set ⍳⌈/X must be included.  The length of X must equal the rank of Y.<br/>R is an array formed by the transposition of the axes of Y as specified by X.  The Ith element of X gives the new position for the Ith axis of Y.  If X repositions two or more axes of Y to the same axis, the elements used to fill this axis are those whose indices on the relevant axes of Y are equal.<br/>⎕IO is an implicit argument of Dyadic Transpose.<br/>Assign a distinct letter for each unique integer in X :<br/>If R←X⍉Y, then R[i;j;k;…] equals Y indexed by the letters corresponding to elements of X .<br/>From the above it can be seen that:"
Transpose(Dyadic),⍉
Transpose(Dyadic),"Y may be any array.  X must be a simple scalar or vector whose elements are included in the set ⍳⍴⍴Y.  Integer values in X may be repeated but all integers in the set ⍳⌈/X must be included.  The length of X must equal the rank of Y.<br/>R is an array formed by the transposition of the axes of Y as specified by X.  The Ith element of X gives the new position for the Ith axis of Y.  If X repositions two or more axes of Y to the same axis, the elements used to fill this axis are those whose indices on the relevant axes of Y are equal.<br/>⎕IO is an implicit argument of Dyadic Transpose.<br/>Assign a distinct letter for each unique integer in X :<br/>If R←X⍉Y, then R[i;j;k;…] equals Y indexed by the letters corresponding to elements of X .<br/>From the above it can be seen that:"
"Y may be any array.  X must be a simple scalar or vector whose elements are included in the set ⍳⍴⍴Y.  Integer values in X may be repeated but all integers in the set ⍳⌈/X must be included.  The length of X must equal the rank of Y.<br/>R is an array formed by the transposition of the axes of Y as specified by X.  The Ith element of X gives the new position for the Ith axis of Y.  If X repositions two or more axes of Y to the same axis, the elements used to fill this axis are those whose indices on the relevant axes of Y are equal.<br/>⎕IO is an implicit argument of Dyadic Transpose.<br/>Assign a distinct letter for each unique integer in X :<br/>If R←X⍉Y, then R[i;j;k;…] equals Y indexed by the letters corresponding to elements of X .<br/>From the above it can be seen that:",Transpose(Dyadic)
⍉,Circle Backslash<br/>Monadic: Transpose<br/>Dyadic: DyadicTranspose
Up Arrow,↑
Monadic: If ⎕ML<2 Mix,↑
"The symbol chosen to represent Mix depends on the current Migration Level.<br/>If ‚éēML<2, Mix is represented by the symbol: ‚ÜĎ.<br/>If ‚éēML‚Č•2, Mix is represented by the symbol: ‚äÉ.<br/>Y may be any array whose items may be uniform in rank and shape, or differ in rank and shape. If the items of Y are non-uniform, they are extended prior to the application of the function as follows:<br/>For the purposes of the following narrative,  y represents the virtual item in Y with the greatest rank and shape, with which all other items are extended to conform.<br/>R is an array composed from the items of  Y assembled into a higher-rank array with one less level of nesting. ‚ćīR will be some permutation of (‚ćīY),‚ćīy.<br/>K is an optional axis specification whose value(s)  indicate where in the result the axes of y appear. There are three cases:<br/>If K is absent, the axes of y appear as the last axes of the result.<br/>In this example, the shape of Y is 3, and the shape of  y is 2. So the shape of the result will be a permutation of 2 and 3, i.e. in this simple example, either (2 3) or (3 2).<br/>If K is omitted, the shape of the result is (‚ćīY),‚ćīy.<br/>If K is between 0 and 1, the shape of the result is (‚ćīy),‚ćīY because (‚ćīy) is inserted between the 0th and the 1st axis of the result, i.e. at the beginning.<br/>If K is between 1 and 2, the shape of the result is (‚ćīY),‚ćīy because (‚ćīy) is inserted between the 1st and 2nd axis of the result, i.e. at the end. This is the same as the case when K is omitted.<br/>An integer K may be used instead. If ‚éēML‚Č•2,  ‚äÉ is used instead of ‚ÜĎ).<br/>If the items of Y are unequal in shape, the shorter ones are extended:<br/>Notice that in the last statement, the shape of the third item was extended by catenating it with its prototype.<br/>In the following examples, Y is a matrix of shape (5 4) and each item of Y (y) is a matrix of shape (3 2). The shape of the result will be some permutation of (5 4 3 2).<br/>By default, the axes of y appear in the last position in the shape of the result, but this position is altered by specifying the axis K. Notice where the (3 2) appears in the following results:<br/>Note that ‚äÉ[4]Y generates an INDEX ERROR because 4 is greater than the length of the result.<br/> The axes of y do not have to be contiguous in the shape of the result. By specifying a vector K, they can be distributed. Notice where the 3 and the 2 appear in the following results:<br/>If the items of Y are unequal in rank, the lower rank items are extended in rank by prefixing their shapes with 1s. Each additional 1 may then be increased to match the maximum shape of the other items along that axis.<br/>In the above example, the first item (1) becomes (1 1‚ćī1) to conform with the 3rd item which is rank 2. It is then extended in shape to become (2 4‚ÜĎ1 1‚ćī1) to conform with the 2-row 3rd item, and 4-column 2nd item.. Likewise, the 2nd item becomes a 2-row matrix, and the 3rd item gains another column.",↑
↑,"The symbol chosen to represent Mix depends on the current Migration Level.<br/>If ‚éēML<2, Mix is represented by the symbol: ‚ÜĎ.<br/>If ‚éēML‚Č•2, Mix is represented by the symbol: ‚äÉ.<br/>Y may be any array whose items may be uniform in rank and shape, or differ in rank and shape. If the items of Y are non-uniform, they are extended prior to the application of the function as follows:<br/>For the purposes of the following narrative,  y represents the virtual item in Y with the greatest rank and shape, with which all other items are extended to conform.<br/>R is an array composed from the items of  Y assembled into a higher-rank array with one less level of nesting. ‚ćīR will be some permutation of (‚ćīY),‚ćīy.<br/>K is an optional axis specification whose value(s)  indicate where in the result the axes of y appear. There are three cases:<br/>If K is absent, the axes of y appear as the last axes of the result.<br/>In this example, the shape of Y is 3, and the shape of  y is 2. So the shape of the result will be a permutation of 2 and 3, i.e. in this simple example, either (2 3) or (3 2).<br/>If K is omitted, the shape of the result is (‚ćīY),‚ćīy.<br/>If K is between 0 and 1, the shape of the result is (‚ćīy),‚ćīY because (‚ćīy) is inserted between the 0th and the 1st axis of the result, i.e. at the beginning.<br/>If K is between 1 and 2, the shape of the result is (‚ćīY),‚ćīy because (‚ćīy) is inserted between the 1st and 2nd axis of the result, i.e. at the end. This is the same as the case when K is omitted.<br/>An integer K may be used instead. If ‚éēML‚Č•2,  ‚äÉ is used instead of ‚ÜĎ).<br/>If the items of Y are unequal in shape, the shorter ones are extended:<br/>Notice that in the last statement, the shape of the third item was extended by catenating it with its prototype.<br/>In the following examples, Y is a matrix of shape (5 4) and each item of Y (y) is a matrix of shape (3 2). The shape of the result will be some permutation of (5 4 3 2).<br/>By default, the axes of y appear in the last position in the shape of the result, but this position is altered by specifying the axis K. Notice where the (3 2) appears in the following results:<br/>Note that ‚äÉ[4]Y generates an INDEX ERROR because 4 is greater than the length of the result.<br/> The axes of y do not have to be contiguous in the shape of the result. By specifying a vector K, they can be distributed. Notice where the 3 and the 2 appear in the following results:<br/>If the items of Y are unequal in rank, the lower rank items are extended in rank by prefixing their shapes with 1s. Each additional 1 may then be increased to match the maximum shape of the other items along that axis.<br/>In the above example, the first item (1) becomes (1 1‚ćī1) to conform with the 3rd item which is rank 2. It is then extended in shape to become (2 4‚ÜĎ1 1‚ćī1) to conform with the 2-row 3rd item, and 4-column 2nd item.. Likewise, the 2nd item becomes a 2-row matrix, and the 3rd item gains another column."
Mix,"The symbol chosen to represent Mix depends on the current Migration Level.<br/>If ‚éēML<2, Mix is represented by the symbol: ‚ÜĎ.<br/>If ‚éēML‚Č•2, Mix is represented by the symbol: ‚äÉ.<br/>Y may be any array whose items may be uniform in rank and shape, or differ in rank and shape. If the items of Y are non-uniform, they are extended prior to the application of the function as follows:<br/>For the purposes of the following narrative,  y represents the virtual item in Y with the greatest rank and shape, with which all other items are extended to conform.<br/>R is an array composed from the items of  Y assembled into a higher-rank array with one less level of nesting. ‚ćīR will be some permutation of (‚ćīY),‚ćīy.<br/>K is an optional axis specification whose value(s)  indicate where in the result the axes of y appear. There are three cases:<br/>If K is absent, the axes of y appear as the last axes of the result.<br/>In this example, the shape of Y is 3, and the shape of  y is 2. So the shape of the result will be a permutation of 2 and 3, i.e. in this simple example, either (2 3) or (3 2).<br/>If K is omitted, the shape of the result is (‚ćīY),‚ćīy.<br/>If K is between 0 and 1, the shape of the result is (‚ćīy),‚ćīY because (‚ćīy) is inserted between the 0th and the 1st axis of the result, i.e. at the beginning.<br/>If K is between 1 and 2, the shape of the result is (‚ćīY),‚ćīy because (‚ćīy) is inserted between the 1st and 2nd axis of the result, i.e. at the end. This is the same as the case when K is omitted.<br/>An integer K may be used instead. If ‚éēML‚Č•2,  ‚äÉ is used instead of ‚ÜĎ).<br/>If the items of Y are unequal in shape, the shorter ones are extended:<br/>Notice that in the last statement, the shape of the third item was extended by catenating it with its prototype.<br/>In the following examples, Y is a matrix of shape (5 4) and each item of Y (y) is a matrix of shape (3 2). The shape of the result will be some permutation of (5 4 3 2).<br/>By default, the axes of y appear in the last position in the shape of the result, but this position is altered by specifying the axis K. Notice where the (3 2) appears in the following results:<br/>Note that ‚äÉ[4]Y generates an INDEX ERROR because 4 is greater than the length of the result.<br/> The axes of y do not have to be contiguous in the shape of the result. By specifying a vector K, they can be distributed. Notice where the 3 and the 2 appear in the following results:<br/>If the items of Y are unequal in rank, the lower rank items are extended in rank by prefixing their shapes with 1s. Each additional 1 may then be increased to match the maximum shape of the other items along that axis.<br/>In the above example, the first item (1) becomes (1 1‚ćī1) to conform with the 3rd item which is rank 2. It is then extended in shape to become (2 4‚ÜĎ1 1‚ćī1) to conform with the 2-row 3rd item, and 4-column 2nd item.. Likewise, the 2nd item becomes a 2-row matrix, and the 3rd item gains another column."
"The symbol chosen to represent Mix depends on the current Migration Level.<br/>If ‚éēML<2, Mix is represented by the symbol: ‚ÜĎ.<br/>If ‚éēML‚Č•2, Mix is represented by the symbol: ‚äÉ.<br/>Y may be any array whose items may be uniform in rank and shape, or differ in rank and shape. If the items of Y are non-uniform, they are extended prior to the application of the function as follows:<br/>For the purposes of the following narrative,  y represents the virtual item in Y with the greatest rank and shape, with which all other items are extended to conform.<br/>R is an array composed from the items of  Y assembled into a higher-rank array with one less level of nesting. ‚ćīR will be some permutation of (‚ćīY),‚ćīy.<br/>K is an optional axis specification whose value(s)  indicate where in the result the axes of y appear. There are three cases:<br/>If K is absent, the axes of y appear as the last axes of the result.<br/>In this example, the shape of Y is 3, and the shape of  y is 2. So the shape of the result will be a permutation of 2 and 3, i.e. in this simple example, either (2 3) or (3 2).<br/>If K is omitted, the shape of the result is (‚ćīY),‚ćīy.<br/>If K is between 0 and 1, the shape of the result is (‚ćīy),‚ćīY because (‚ćīy) is inserted between the 0th and the 1st axis of the result, i.e. at the beginning.<br/>If K is between 1 and 2, the shape of the result is (‚ćīY),‚ćīy because (‚ćīy) is inserted between the 1st and 2nd axis of the result, i.e. at the end. This is the same as the case when K is omitted.<br/>An integer K may be used instead. If ‚éēML‚Č•2,  ‚äÉ is used instead of ‚ÜĎ).<br/>If the items of Y are unequal in shape, the shorter ones are extended:<br/>Notice that in the last statement, the shape of the third item was extended by catenating it with its prototype.<br/>In the following examples, Y is a matrix of shape (5 4) and each item of Y (y) is a matrix of shape (3 2). The shape of the result will be some permutation of (5 4 3 2).<br/>By default, the axes of y appear in the last position in the shape of the result, but this position is altered by specifying the axis K. Notice where the (3 2) appears in the following results:<br/>Note that ‚äÉ[4]Y generates an INDEX ERROR because 4 is greater than the length of the result.<br/> The axes of y do not have to be contiguous in the shape of the result. By specifying a vector K, they can be distributed. Notice where the 3 and the 2 appear in the following results:<br/>If the items of Y are unequal in rank, the lower rank items are extended in rank by prefixing their shapes with 1s. Each additional 1 may then be increased to match the maximum shape of the other items along that axis.<br/>In the above example, the first item (1) becomes (1 1‚ćī1) to conform with the 3rd item which is rank 2. It is then extended in shape to become (2 4‚ÜĎ1 1‚ćī1) to conform with the 2-row 3rd item, and 4-column 2nd item.. Likewise, the 2nd item becomes a 2-row matrix, and the 3rd item gains another column.",Mix
Dyadic: Take,↑
"Y may be any array.  X must be a simple integer scalar or vector.<br/>If Y is a scalar, it is treated as a one-element array of shape (⍴,X)⍴1.  The length of X must be the same as or less than the rank of Y. If the length of X is less than the rank of Y, the missing elements of X default to the length of the corresponding axis of Y.<br/>R is an array of the same rank as Y (after possible extension), and of shape |X.  If X[I] (an element of X) is positive, then X[I] sub-arrays are taken from the beginning of the Ith axis of Y.  If X[I] is negative, then X[I] sub-arrays are taken from the end of the Ith axis of Y.<br/>If more elements are taken than exist on axis I, the extra positions in R are filled with the fill element of Y (⊂∊⊃Y with ⎕ml←0).",↑
↑,"Y may be any array.  X must be a simple integer scalar or vector.<br/>If Y is a scalar, it is treated as a one-element array of shape (⍴,X)⍴1.  The length of X must be the same as or less than the rank of Y. If the length of X is less than the rank of Y, the missing elements of X default to the length of the corresponding axis of Y.<br/>R is an array of the same rank as Y (after possible extension), and of shape |X.  If X[I] (an element of X) is positive, then X[I] sub-arrays are taken from the beginning of the Ith axis of Y.  If X[I] is negative, then X[I] sub-arrays are taken from the end of the Ith axis of Y.<br/>If more elements are taken than exist on axis I, the extra positions in R are filled with the fill element of Y (⊂∊⊃Y with ⎕ml←0)."
Take,"Y may be any array.  X must be a simple integer scalar or vector.<br/>If Y is a scalar, it is treated as a one-element array of shape (⍴,X)⍴1.  The length of X must be the same as or less than the rank of Y. If the length of X is less than the rank of Y, the missing elements of X default to the length of the corresponding axis of Y.<br/>R is an array of the same rank as Y (after possible extension), and of shape |X.  If X[I] (an element of X) is positive, then X[I] sub-arrays are taken from the beginning of the Ith axis of Y.  If X[I] is negative, then X[I] sub-arrays are taken from the end of the Ith axis of Y.<br/>If more elements are taken than exist on axis I, the extra positions in R are filled with the fill element of Y (⊂∊⊃Y with ⎕ml←0)."
"Y may be any array.  X must be a simple integer scalar or vector.<br/>If Y is a scalar, it is treated as a one-element array of shape (⍴,X)⍴1.  The length of X must be the same as or less than the rank of Y. If the length of X is less than the rank of Y, the missing elements of X default to the length of the corresponding axis of Y.<br/>R is an array of the same rank as Y (after possible extension), and of shape |X.  If X[I] (an element of X) is positive, then X[I] sub-arrays are taken from the beginning of the Ith axis of Y.  If X[I] is negative, then X[I] sub-arrays are taken from the end of the Ith axis of Y.<br/>If more elements are taken than exist on axis I, the extra positions in R are filled with the fill element of Y (⊂∊⊃Y with ⎕ml←0).",Take
↑,Up Arrow<br/>Monadic: If ⎕ML<2 Mix<br/>Dyadic: Take
Down Arrow,↓
Monadic: Split,↓
"Y may be any array.  The axis specification is optional.  If present, K must be a simple integer scalar or one-element vector.  The value of K must be an axis of Y.  If absent, the last axis is implied.<br/>The items of R are the sub-arrays of Y along the Kth axis.  R is a scalar if Y is a scalar.  Otherwise R is an array whose rank is ¯1+⍴⍴Y and whose shape is (K≠⍳⍴⍴Y)/⍴Y.",↓
↓,"Y may be any array.  The axis specification is optional.  If present, K must be a simple integer scalar or one-element vector.  The value of K must be an axis of Y.  If absent, the last axis is implied.<br/>The items of R are the sub-arrays of Y along the Kth axis.  R is a scalar if Y is a scalar.  Otherwise R is an array whose rank is ¯1+⍴⍴Y and whose shape is (K≠⍳⍴⍴Y)/⍴Y."
Split,"Y may be any array.  The axis specification is optional.  If present, K must be a simple integer scalar or one-element vector.  The value of K must be an axis of Y.  If absent, the last axis is implied.<br/>The items of R are the sub-arrays of Y along the Kth axis.  R is a scalar if Y is a scalar.  Otherwise R is an array whose rank is ¯1+⍴⍴Y and whose shape is (K≠⍳⍴⍴Y)/⍴Y."
"Y may be any array.  The axis specification is optional.  If present, K must be a simple integer scalar or one-element vector.  The value of K must be an axis of Y.  If absent, the last axis is implied.<br/>The items of R are the sub-arrays of Y along the Kth axis.  R is a scalar if Y is a scalar.  Otherwise R is an array whose rank is ¯1+⍴⍴Y and whose shape is (K≠⍳⍴⍴Y)/⍴Y.",Split
Dyadic: Drop,↓
"Y may be any array.  X must be a simple scalar or vector of integers. If X is a scalar, it is treated as a one-element vector.  If Y is a scalar, it is treated as an array whose shape is (⍴X)⍴1. After any scalar extensions, the shape of X must be less than or equal to the rank of Y. Any missing trailing items in X default to 0.<br/>R is an array with the same rank as Y but with elements removed from the vectors along each of the axes of Y. For the Ith axis:<br/>If the magnitude of X[I] exceeds the length of the Ith axis, the result is an empty array with zero length along that axis.",↓
↓,"Y may be any array.  X must be a simple scalar or vector of integers. If X is a scalar, it is treated as a one-element vector.  If Y is a scalar, it is treated as an array whose shape is (⍴X)⍴1. After any scalar extensions, the shape of X must be less than or equal to the rank of Y. Any missing trailing items in X default to 0.<br/>R is an array with the same rank as Y but with elements removed from the vectors along each of the axes of Y. For the Ith axis:<br/>If the magnitude of X[I] exceeds the length of the Ith axis, the result is an empty array with zero length along that axis."
Drop,"Y may be any array.  X must be a simple scalar or vector of integers. If X is a scalar, it is treated as a one-element vector.  If Y is a scalar, it is treated as an array whose shape is (⍴X)⍴1. After any scalar extensions, the shape of X must be less than or equal to the rank of Y. Any missing trailing items in X default to 0.<br/>R is an array with the same rank as Y but with elements removed from the vectors along each of the axes of Y. For the Ith axis:<br/>If the magnitude of X[I] exceeds the length of the Ith axis, the result is an empty array with zero length along that axis."
"Y may be any array.  X must be a simple scalar or vector of integers. If X is a scalar, it is treated as a one-element vector.  If Y is a scalar, it is treated as an array whose shape is (⍴X)⍴1. After any scalar extensions, the shape of X must be less than or equal to the rank of Y. Any missing trailing items in X default to 0.<br/>R is an array with the same rank as Y but with elements removed from the vectors along each of the axes of Y. For the Ith axis:<br/>If the magnitude of X[I] exceeds the length of the Ith axis, the result is an empty array with zero length along that axis.",Drop
↓,Down Arrow<br/>Monadic: Split<br/>Dyadic: Drop
Left Shoe,⊂
Monadic: Enclose,⊂
"Y may be any array.  R is a scalar array whose item is the array Y.  If Y is a simple scalar, R is the simple scalar unchanged.  Otherwise, R has a depth whose magnitude is one greater than the magnitude of the depth of Y.<br/>See also: Enclose with Axes.",⊂
⊂,"Y may be any array.  R is a scalar array whose item is the array Y.  If Y is a simple scalar, R is the simple scalar unchanged.  Otherwise, R has a depth whose magnitude is one greater than the magnitude of the depth of Y.<br/>See also: Enclose with Axes."
Enclose,"Y may be any array.  R is a scalar array whose item is the array Y.  If Y is a simple scalar, R is the simple scalar unchanged.  Otherwise, R has a depth whose magnitude is one greater than the magnitude of the depth of Y.<br/>See also: Enclose with Axes."
"Y may be any array.  R is a scalar array whose item is the array Y.  If Y is a simple scalar, R is the simple scalar unchanged.  Otherwise, R has a depth whose magnitude is one greater than the magnitude of the depth of Y.<br/>See also: Enclose with Axes.",Enclose
Dyadic: If ⎕ML<3 Partitioned Enclose,⊂
"Y may be any array.  X must be a simple integer scalar or vector. If X is a scalar it is extended to (‚ČĘY)‚ćīX.<br/>The axis specification is optional.  If present, it must be a simple integer scalar or one-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.<br/>R is a vector of items selected from Y by inserting 0 or more dividers, specified by X, between its major cells.<br/>Each element of X specifies the number of dividers to insert before the corresponding major cell of Y. The maximum length of X is 1+‚ČĘY, when the last element of X specifies the number of trailing dividers. Note that major cells of Y that precede the first divider (identified by the first non-zero element of X) are excluded from the result.<br/>The length of R is +/X (after possible extension).<br/>The above examples may be explained pictorially by the diagram below.",⊂
⊂,"Y may be any array.  X must be a simple integer scalar or vector. If X is a scalar it is extended to (‚ČĘY)‚ćīX.<br/>The axis specification is optional.  If present, it must be a simple integer scalar or one-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.<br/>R is a vector of items selected from Y by inserting 0 or more dividers, specified by X, between its major cells.<br/>Each element of X specifies the number of dividers to insert before the corresponding major cell of Y. The maximum length of X is 1+‚ČĘY, when the last element of X specifies the number of trailing dividers. Note that major cells of Y that precede the first divider (identified by the first non-zero element of X) are excluded from the result.<br/>The length of R is +/X (after possible extension).<br/>The above examples may be explained pictorially by the diagram below."
PartitionedEnclose,⊂
PartitionedEnclose,"Y may be any array.  X must be a simple integer scalar or vector. If X is a scalar it is extended to (‚ČĘY)‚ćīX.<br/>The axis specification is optional.  If present, it must be a simple integer scalar or one-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.<br/>R is a vector of items selected from Y by inserting 0 or more dividers, specified by X, between its major cells.<br/>Each element of X specifies the number of dividers to insert before the corresponding major cell of Y. The maximum length of X is 1+‚ČĘY, when the last element of X specifies the number of trailing dividers. Note that major cells of Y that precede the first divider (identified by the first non-zero element of X) are excluded from the result.<br/>The length of R is +/X (after possible extension).<br/>The above examples may be explained pictorially by the diagram below."
"Y may be any array.  X must be a simple integer scalar or vector. If X is a scalar it is extended to (‚ČĘY)‚ćīX.<br/>The axis specification is optional.  If present, it must be a simple integer scalar or one-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.<br/>R is a vector of items selected from Y by inserting 0 or more dividers, specified by X, between its major cells.<br/>Each element of X specifies the number of dividers to insert before the corresponding major cell of Y. The maximum length of X is 1+‚ČĘY, when the last element of X specifies the number of trailing dividers. Note that major cells of Y that precede the first divider (identified by the first non-zero element of X) are excluded from the result.<br/>The length of R is +/X (after possible extension).<br/>The above examples may be explained pictorially by the diagram below.",PartitionedEnclose
⊂,Left Shoe<br/>Monadic: Enclose<br/>Dyadic: If ⎕ML<3 Partitioned Enclose
Left Shoe Underbar,⊆
Monadic: Nest,⊆
"Classic Edition: the symbol ⊆ (Left Shoe Underbar) is not available in Classic Edition, and Nest is instead represented by ⎕U2286.<br/>Y may be any array.<br/>If Y is simple, R is a scalar array whose item is the array Y.  If Y is a simple scalar or is already nested, R is Y unchanged. ",⊆
⊆,"Classic Edition: the symbol ⊆ (Left Shoe Underbar) is not available in Classic Edition, and Nest is instead represented by ⎕U2286.<br/>Y may be any array.<br/>If Y is simple, R is a scalar array whose item is the array Y.  If Y is a simple scalar or is already nested, R is Y unchanged. "
Nest,"Classic Edition: the symbol ⊆ (Left Shoe Underbar) is not available in Classic Edition, and Nest is instead represented by ⎕U2286.<br/>Y may be any array.<br/>If Y is simple, R is a scalar array whose item is the array Y.  If Y is a simple scalar or is already nested, R is Y unchanged. "
"Classic Edition: the symbol ⊆ (Left Shoe Underbar) is not available in Classic Edition, and Nest is instead represented by ⎕U2286.<br/>Y may be any array.<br/>If Y is simple, R is a scalar array whose item is the array Y.  If Y is a simple scalar or is already nested, R is Y unchanged. ",Nest
Dyadic: Partition,⊆
"Classic Edition: the symbol вҠҶ (Left Shoe Underbar) is not available in Classic Edition, and Partition is instead represented by вҺ•U2286.<br/>Y may be any non-scalar array.<br/>X must be a simple scalar or vector of non-negative integers.<br/>The axis specification is optional.  If present, it must be a simple integer scalar or one element array representing an axis of Y.  If absent, the last axis is implied.<br/>R is an array of the elements of Y partitioned according to X.<br/>A new partition is started in the result whenever the corresponding element in X is greater than the previous one. Items in Y corresponding to 0s in X are not included in the result.<br/>Note that if вҺ•MLвүҘ3, the symbol вҠӮ means the same as вҠҶ.",⊆
⊆,"Classic Edition: the symbol вҠҶ (Left Shoe Underbar) is not available in Classic Edition, and Partition is instead represented by вҺ•U2286.<br/>Y may be any non-scalar array.<br/>X must be a simple scalar or vector of non-negative integers.<br/>The axis specification is optional.  If present, it must be a simple integer scalar or one element array representing an axis of Y.  If absent, the last axis is implied.<br/>R is an array of the elements of Y partitioned according to X.<br/>A new partition is started in the result whenever the corresponding element in X is greater than the previous one. Items in Y corresponding to 0s in X are not included in the result.<br/>Note that if вҺ•MLвүҘ3, the symbol вҠӮ means the same as вҠҶ."
Partition,"Classic Edition: the symbol вҠҶ (Left Shoe Underbar) is not available in Classic Edition, and Partition is instead represented by вҺ•U2286.<br/>Y may be any non-scalar array.<br/>X must be a simple scalar or vector of non-negative integers.<br/>The axis specification is optional.  If present, it must be a simple integer scalar or one element array representing an axis of Y.  If absent, the last axis is implied.<br/>R is an array of the elements of Y partitioned according to X.<br/>A new partition is started in the result whenever the corresponding element in X is greater than the previous one. Items in Y corresponding to 0s in X are not included in the result.<br/>Note that if вҺ•MLвүҘ3, the symbol вҠӮ means the same as вҠҶ."
"Classic Edition: the symbol вҠҶ (Left Shoe Underbar) is not available in Classic Edition, and Partition is instead represented by вҺ•U2286.<br/>Y may be any non-scalar array.<br/>X must be a simple scalar or vector of non-negative integers.<br/>The axis specification is optional.  If present, it must be a simple integer scalar or one element array representing an axis of Y.  If absent, the last axis is implied.<br/>R is an array of the elements of Y partitioned according to X.<br/>A new partition is started in the result whenever the corresponding element in X is greater than the previous one. Items in Y corresponding to 0s in X are not included in the result.<br/>Note that if вҺ•MLвүҘ3, the symbol вҠӮ means the same as вҠҶ.",Partition
⊆,Left Shoe Underbar<br/>Monadic: Nest<br/>Dyadic: Partition
Right Shoe,⊃
Monadic: If ⎕ML<2Disclose;First,⊃
"The symbol chosen to represent Disclose depends on the current Migration Level.<br/>If  ⎕ML<2, Disclose is represented by the symbol: ⊃.<br/>If  ⎕ML≥2, Disclose is represented by the symbol: ↑.<br/>Y may be any array.  R is an array.  If Y is non-empty, R is the value of the first item of Y taken in ravel order.  If Y is empty, R is the prototype of Y.<br/>Disclose is the inverse of Enclose.  The identity R←→⊃⊂R holds for all R.  Disclose is also referred to as First.",⊃
⊃,"The symbol chosen to represent Disclose depends on the current Migration Level.<br/>If  ⎕ML<2, Disclose is represented by the symbol: ⊃.<br/>If  ⎕ML≥2, Disclose is represented by the symbol: ↑.<br/>Y may be any array.  R is an array.  If Y is non-empty, R is the value of the first item of Y taken in ravel order.  If Y is empty, R is the prototype of Y.<br/>Disclose is the inverse of Enclose.  The identity R←→⊃⊂R holds for all R.  Disclose is also referred to as First."
Disclose,"The symbol chosen to represent Disclose depends on the current Migration Level.<br/>If  ⎕ML<2, Disclose is represented by the symbol: ⊃.<br/>If  ⎕ML≥2, Disclose is represented by the symbol: ↑.<br/>Y may be any array.  R is an array.  If Y is non-empty, R is the value of the first item of Y taken in ravel order.  If Y is empty, R is the prototype of Y.<br/>Disclose is the inverse of Enclose.  The identity R←→⊃⊂R holds for all R.  Disclose is also referred to as First."
"The symbol chosen to represent Disclose depends on the current Migration Level.<br/>If  ⎕ML<2, Disclose is represented by the symbol: ⊃.<br/>If  ⎕ML≥2, Disclose is represented by the symbol: ↑.<br/>Y may be any array.  R is an array.  If Y is non-empty, R is the value of the first item of Y taken in ravel order.  If Y is empty, R is the prototype of Y.<br/>Disclose is the inverse of Enclose.  The identity R←→⊃⊂R holds for all R.  Disclose is also referred to as First.",Disclose
Dyadic: Pick,⊃
"Y may be any array.<br/> X is a scalar or vector of indices of Y.<br/> R is an item selected from the structure of Y according to X.<br/>Elements of X select from successively deeper levels in the structure of Y.  The items of X are simple integer scalars or vectors which identify a set of indices, one per axis at the particular level of nesting of Y in row-major order.  Simple scalar items in Y may be picked by empty vector items in X to any arbitrary depth.<br/>⎕IO is an implicit argument of Pick.",⊃
⊃,"Y may be any array.<br/> X is a scalar or vector of indices of Y.<br/> R is an item selected from the structure of Y according to X.<br/>Elements of X select from successively deeper levels in the structure of Y.  The items of X are simple integer scalars or vectors which identify a set of indices, one per axis at the particular level of nesting of Y in row-major order.  Simple scalar items in Y may be picked by empty vector items in X to any arbitrary depth.<br/>⎕IO is an implicit argument of Pick."
Pick,"Y may be any array.<br/> X is a scalar or vector of indices of Y.<br/> R is an item selected from the structure of Y according to X.<br/>Elements of X select from successively deeper levels in the structure of Y.  The items of X are simple integer scalars or vectors which identify a set of indices, one per axis at the particular level of nesting of Y in row-major order.  Simple scalar items in Y may be picked by empty vector items in X to any arbitrary depth.<br/>⎕IO is an implicit argument of Pick."
"Y may be any array.<br/> X is a scalar or vector of indices of Y.<br/> R is an item selected from the structure of Y according to X.<br/>Elements of X select from successively deeper levels in the structure of Y.  The items of X are simple integer scalars or vectors which identify a set of indices, one per axis at the particular level of nesting of Y in row-major order.  Simple scalar items in Y may be picked by empty vector items in X to any arbitrary depth.<br/>⎕IO is an implicit argument of Pick.",Pick
⊃,Right Shoe<br/>Monadic: If ⎕ML<2Disclose;First<br/>Dyadic: Pick
Epsilon,∊
Monadic: If ⎕ML=0 Type Of,∊
Migration level must be such that ⎕ML<1 (otherwise ∊ means Enlist. See Enlist).<br/>Y may be any array.  R is an array with the same shape and structure as Y in which a numeric value is replaced by 0 and a character value is replaced by ' '.,∊
∊,Migration level must be such that ⎕ML<1 (otherwise ∊ means Enlist. See Enlist).<br/>Y may be any array.  R is an array with the same shape and structure as Y in which a numeric value is replaced by 0 and a character value is replaced by ' '.
Type,Migration level must be such that ⎕ML<1 (otherwise ∊ means Enlist. See Enlist).<br/>Y may be any array.  R is an array with the same shape and structure as Y in which a numeric value is replaced by 0 and a character value is replaced by ' '.
Migration level must be such that ⎕ML<1 (otherwise ∊ means Enlist. See Enlist).<br/>Y may be any array.  R is an array with the same shape and structure as Y in which a numeric value is replaced by 0 and a character value is replaced by ' '.,Type
Dyadic: Member Of,∊
"Y may be any array.  X may be any array.  R is Boolean. An element of R is 1 if the corresponding element of X can be found in Y.<br/>An element of X is considered identical to an element in Y if X≡Y returns 1 for those elements.<br/>⎕CT and ⎕DCT are  implicit arguments of Membership.<br/>For performance information, see Search Functions and Hash Tables.",∊
∊,"Y may be any array.  X may be any array.  R is Boolean. An element of R is 1 if the corresponding element of X can be found in Y.<br/>An element of X is considered identical to an element in Y if X≡Y returns 1 for those elements.<br/>⎕CT and ⎕DCT are  implicit arguments of Membership.<br/>For performance information, see Search Functions and Hash Tables."
Membership,∊
Membership,"Y may be any array.  X may be any array.  R is Boolean. An element of R is 1 if the corresponding element of X can be found in Y.<br/>An element of X is considered identical to an element in Y if X≡Y returns 1 for those elements.<br/>⎕CT and ⎕DCT are  implicit arguments of Membership.<br/>For performance information, see Search Functions and Hash Tables."
"Y may be any array.  X may be any array.  R is Boolean. An element of R is 1 if the corresponding element of X can be found in Y.<br/>An element of X is considered identical to an element in Y if X≡Y returns 1 for those elements.<br/>⎕CT and ⎕DCT are  implicit arguments of Membership.<br/>For performance information, see Search Functions and Hash Tables.",Membership
∊,Epsilon<br/>Monadic: If ⎕ML=0 Type Of<br/>Dyadic: Member Of
Epsilon Underbar,⍷
Dyadic: Find,⍷
"X and Y may be any arrays.  R is a simple Boolean array the same shape as Y which identifies occurrences of X within Y.<br/>If the rank of X is smaller than the rank of Y, X is treated as if it were the same rank with leading axes of size 1.  For example a vector is treated as a 1-row matrix.<br/>If the rank of X is larger than the rank of Y, no occurrences of X are found in Y.<br/>⎕CT and ⎕DCT are implicit arguments of Find.",⍷
⍷,"X and Y may be any arrays.  R is a simple Boolean array the same shape as Y which identifies occurrences of X within Y.<br/>If the rank of X is smaller than the rank of Y, X is treated as if it were the same rank with leading axes of size 1.  For example a vector is treated as a 1-row matrix.<br/>If the rank of X is larger than the rank of Y, no occurrences of X are found in Y.<br/>⎕CT and ⎕DCT are implicit arguments of Find."
Find,"X and Y may be any arrays.  R is a simple Boolean array the same shape as Y which identifies occurrences of X within Y.<br/>If the rank of X is smaller than the rank of Y, X is treated as if it were the same rank with leading axes of size 1.  For example a vector is treated as a 1-row matrix.<br/>If the rank of X is larger than the rank of Y, no occurrences of X are found in Y.<br/>⎕CT and ⎕DCT are implicit arguments of Find."
"X and Y may be any arrays.  R is a simple Boolean array the same shape as Y which identifies occurrences of X within Y.<br/>If the rank of X is smaller than the rank of Y, X is treated as if it were the same rank with leading axes of size 1.  For example a vector is treated as a 1-row matrix.<br/>If the rank of X is larger than the rank of Y, no occurrences of X are found in Y.<br/>⎕CT and ⎕DCT are implicit arguments of Find.",Find
⍷,Epsilon Underbar<br/>Dyadic: Find
Slash,/
Dyadic: Replicate,/
"Y may be any array.  X is a simple integer vector or scalar.<br/>The axis specification is optional.  If present, K must be a simple integer scalar or 1-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⌿Y implies the first axis of Y.<br/>If Y has length 1 along the Kth (or implied) axis, it is extended along that axis to match the length of X. Otherwise, the length of X must be the length of the Kth (or implied) axis of Y. However, if X is a scalar or one-element vector, it will be extended to the length of the Kth axis.<br/>R is composed from sub-arrays along the Kth axis of Y.  If X[I] (an element of X) is positive, then the corresponding sub-array is replicated X[I] times.  If X[I] is zero, then the corresponding sub-array of Y is excluded.  If X[I] is negative, then the fill element of  Y is replicated |X[I] times.  Each of the (replicated) sub-arrays and fill items are joined along the Kth axis in the order of occurrence.  The shape of R is the shape of Y except that the length of the (implied) Kth axis is +/|X (after possible extension).<br/>This function is sometimes called Compress when X is Boolean.<br/>If Y is a singleton (1=×/⍴,Y) its value is notionally extended to the length of X along the specified axis.",/
/,"Y may be any array.  X is a simple integer vector or scalar.<br/>The axis specification is optional.  If present, K must be a simple integer scalar or 1-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⌿Y implies the first axis of Y.<br/>If Y has length 1 along the Kth (or implied) axis, it is extended along that axis to match the length of X. Otherwise, the length of X must be the length of the Kth (or implied) axis of Y. However, if X is a scalar or one-element vector, it will be extended to the length of the Kth axis.<br/>R is composed from sub-arrays along the Kth axis of Y.  If X[I] (an element of X) is positive, then the corresponding sub-array is replicated X[I] times.  If X[I] is zero, then the corresponding sub-array of Y is excluded.  If X[I] is negative, then the fill element of  Y is replicated |X[I] times.  Each of the (replicated) sub-arrays and fill items are joined along the Kth axis in the order of occurrence.  The shape of R is the shape of Y except that the length of the (implied) Kth axis is +/|X (after possible extension).<br/>This function is sometimes called Compress when X is Boolean.<br/>If Y is a singleton (1=×/⍴,Y) its value is notionally extended to the length of X along the specified axis."
Replicate,"Y may be any array.  X is a simple integer vector or scalar.<br/>The axis specification is optional.  If present, K must be a simple integer scalar or 1-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⌿Y implies the first axis of Y.<br/>If Y has length 1 along the Kth (or implied) axis, it is extended along that axis to match the length of X. Otherwise, the length of X must be the length of the Kth (or implied) axis of Y. However, if X is a scalar or one-element vector, it will be extended to the length of the Kth axis.<br/>R is composed from sub-arrays along the Kth axis of Y.  If X[I] (an element of X) is positive, then the corresponding sub-array is replicated X[I] times.  If X[I] is zero, then the corresponding sub-array of Y is excluded.  If X[I] is negative, then the fill element of  Y is replicated |X[I] times.  Each of the (replicated) sub-arrays and fill items are joined along the Kth axis in the order of occurrence.  The shape of R is the shape of Y except that the length of the (implied) Kth axis is +/|X (after possible extension).<br/>This function is sometimes called Compress when X is Boolean.<br/>If Y is a singleton (1=×/⍴,Y) its value is notionally extended to the length of X along the specified axis."
"Y may be any array.  X is a simple integer vector or scalar.<br/>The axis specification is optional.  If present, K must be a simple integer scalar or 1-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⌿Y implies the first axis of Y.<br/>If Y has length 1 along the Kth (or implied) axis, it is extended along that axis to match the length of X. Otherwise, the length of X must be the length of the Kth (or implied) axis of Y. However, if X is a scalar or one-element vector, it will be extended to the length of the Kth axis.<br/>R is composed from sub-arrays along the Kth axis of Y.  If X[I] (an element of X) is positive, then the corresponding sub-array is replicated X[I] times.  If X[I] is zero, then the corresponding sub-array of Y is excluded.  If X[I] is negative, then the fill element of  Y is replicated |X[I] times.  Each of the (replicated) sub-arrays and fill items are joined along the Kth axis in the order of occurrence.  The shape of R is the shape of Y except that the length of the (implied) Kth axis is +/|X (after possible extension).<br/>This function is sometimes called Compress when X is Boolean.<br/>If Y is a singleton (1=×/⍴,Y) its value is notionally extended to the length of X along the specified axis.",Replicate
": Reduce, N-Wise Reduce",/
"f must be a dyadic function.  Y may be any array whose items in the sub-arrays along the Kth axis are appropriate to function f.<br/>The axis specification is optional.  If present, K must identify an axis of Y.  If absent, the last axis of Y is implied.  The form R‚Üźf‚ĆŅY implies the first axis of Y.<br/>R is an array formed by applying function f between items of the vectors along the Kth (or implied) axis of Y. For a typical vector Y, the result R is:<br/>The shape S of R is the shape of Y excluding the Kth axis, i.e.<br/> If Y is a scalar then for any function f, R is Y.<br/>If the length of the Kth axis of Y is 1, or if the length of any other axis of Y is 0, then f is not applied and R is S‚ćīY.<br/>Otherwise, if the length of the Kth axis is 0 then the result depends on f and on ‚äÉY (the prototypical item of Y) as follows:<br/>If f is one of the functions listed in Table 39 then R is S‚ćī‚äāI, where I is formed from ‚äÉY by replacing each depth-zero item of ‚äÉY with the identity element from the table.<br/>Otherwise if f is Catenate, R is S‚ćī‚äā0/‚äÉY. If f is Catenate First, R is S‚ćī‚äā0‚ĆŅ‚äÉY. If f is Catenate along the Jth axis, R is S‚ćī‚äā0/[J]‚äÉY. See Catenate/Laminate.<br/>Otherwise, DOMAIN ERROR is reported.<br/>Table 39: Identity Elements",/
/,"f must be a dyadic function.  Y may be any array whose items in the sub-arrays along the Kth axis are appropriate to function f.<br/>The axis specification is optional.  If present, K must identify an axis of Y.  If absent, the last axis of Y is implied.  The form R‚Üźf‚ĆŅY implies the first axis of Y.<br/>R is an array formed by applying function f between items of the vectors along the Kth (or implied) axis of Y. For a typical vector Y, the result R is:<br/>The shape S of R is the shape of Y excluding the Kth axis, i.e.<br/> If Y is a scalar then for any function f, R is Y.<br/>If the length of the Kth axis of Y is 1, or if the length of any other axis of Y is 0, then f is not applied and R is S‚ćīY.<br/>Otherwise, if the length of the Kth axis is 0 then the result depends on f and on ‚äÉY (the prototypical item of Y) as follows:<br/>If f is one of the functions listed in Table 39 then R is S‚ćī‚äāI, where I is formed from ‚äÉY by replacing each depth-zero item of ‚äÉY with the identity element from the table.<br/>Otherwise if f is Catenate, R is S‚ćī‚äā0/‚äÉY. If f is Catenate First, R is S‚ćī‚äā0‚ĆŅ‚äÉY. If f is Catenate along the Jth axis, R is S‚ćī‚äā0/[J]‚äÉY. See Catenate/Laminate.<br/>Otherwise, DOMAIN ERROR is reported.<br/>Table 39: Identity Elements"
Reduce,"f must be a dyadic function.  Y may be any array whose items in the sub-arrays along the Kth axis are appropriate to function f.<br/>The axis specification is optional.  If present, K must identify an axis of Y.  If absent, the last axis of Y is implied.  The form R‚Üźf‚ĆŅY implies the first axis of Y.<br/>R is an array formed by applying function f between items of the vectors along the Kth (or implied) axis of Y. For a typical vector Y, the result R is:<br/>The shape S of R is the shape of Y excluding the Kth axis, i.e.<br/> If Y is a scalar then for any function f, R is Y.<br/>If the length of the Kth axis of Y is 1, or if the length of any other axis of Y is 0, then f is not applied and R is S‚ćīY.<br/>Otherwise, if the length of the Kth axis is 0 then the result depends on f and on ‚äÉY (the prototypical item of Y) as follows:<br/>If f is one of the functions listed in Table 39 then R is S‚ćī‚äāI, where I is formed from ‚äÉY by replacing each depth-zero item of ‚äÉY with the identity element from the table.<br/>Otherwise if f is Catenate, R is S‚ćī‚äā0/‚äÉY. If f is Catenate First, R is S‚ćī‚äā0‚ĆŅ‚äÉY. If f is Catenate along the Jth axis, R is S‚ćī‚äā0/[J]‚äÉY. See Catenate/Laminate.<br/>Otherwise, DOMAIN ERROR is reported.<br/>Table 39: Identity Elements"
"f must be a dyadic function.  Y may be any array whose items in the sub-arrays along the Kth axis are appropriate to function f.<br/>The axis specification is optional.  If present, K must identify an axis of Y.  If absent, the last axis of Y is implied.  The form R‚Üźf‚ĆŅY implies the first axis of Y.<br/>R is an array formed by applying function f between items of the vectors along the Kth (or implied) axis of Y. For a typical vector Y, the result R is:<br/>The shape S of R is the shape of Y excluding the Kth axis, i.e.<br/> If Y is a scalar then for any function f, R is Y.<br/>If the length of the Kth axis of Y is 1, or if the length of any other axis of Y is 0, then f is not applied and R is S‚ćīY.<br/>Otherwise, if the length of the Kth axis is 0 then the result depends on f and on ‚äÉY (the prototypical item of Y) as follows:<br/>If f is one of the functions listed in Table 39 then R is S‚ćī‚äāI, where I is formed from ‚äÉY by replacing each depth-zero item of ‚äÉY with the identity element from the table.<br/>Otherwise if f is Catenate, R is S‚ćī‚äā0/‚äÉY. If f is Catenate First, R is S‚ćī‚äā0‚ĆŅ‚äÉY. If f is Catenate along the Jth axis, R is S‚ćī‚äā0/[J]‚äÉY. See Catenate/Laminate.<br/>Otherwise, DOMAIN ERROR is reported.<br/>Table 39: Identity Elements",Reduce
/,"Slash<br/>Dyadic: Replicate<br/>: Reduce, N-Wise Reduce"
Slash Bar,⌿
Dyadic: Replicate First (Compress First),⌿
"Y may be any array.  X is a simple integer vector or scalar.<br/>The axis specification is optional.  If present, K must be a simple integer scalar or 1-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⌿Y implies the first axis of Y.<br/>If Y has length 1 along the Kth (or implied) axis, it is extended along that axis to match the length of X. Otherwise, the length of X must be the length of the Kth (or implied) axis of Y. However, if X is a scalar or one-element vector, it will be extended to the length of the Kth axis.<br/>R is composed from sub-arrays along the Kth axis of Y.  If X[I] (an element of X) is positive, then the corresponding sub-array is replicated X[I] times.  If X[I] is zero, then the corresponding sub-array of Y is excluded.  If X[I] is negative, then the fill element of  Y is replicated |X[I] times.  Each of the (replicated) sub-arrays and fill items are joined along the Kth axis in the order of occurrence.  The shape of R is the shape of Y except that the length of the (implied) Kth axis is +/|X (after possible extension).<br/>This function is sometimes called Compress when X is Boolean.<br/>If Y is a singleton (1=×/⍴,Y) its value is notionally extended to the length of X along the specified axis.",⌿
⌿,"Y may be any array.  X is a simple integer vector or scalar.<br/>The axis specification is optional.  If present, K must be a simple integer scalar or 1-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⌿Y implies the first axis of Y.<br/>If Y has length 1 along the Kth (or implied) axis, it is extended along that axis to match the length of X. Otherwise, the length of X must be the length of the Kth (or implied) axis of Y. However, if X is a scalar or one-element vector, it will be extended to the length of the Kth axis.<br/>R is composed from sub-arrays along the Kth axis of Y.  If X[I] (an element of X) is positive, then the corresponding sub-array is replicated X[I] times.  If X[I] is zero, then the corresponding sub-array of Y is excluded.  If X[I] is negative, then the fill element of  Y is replicated |X[I] times.  Each of the (replicated) sub-arrays and fill items are joined along the Kth axis in the order of occurrence.  The shape of R is the shape of Y except that the length of the (implied) Kth axis is +/|X (after possible extension).<br/>This function is sometimes called Compress when X is Boolean.<br/>If Y is a singleton (1=×/⍴,Y) its value is notionally extended to the length of X along the specified axis."
Replicate,"Y may be any array.  X is a simple integer vector or scalar.<br/>The axis specification is optional.  If present, K must be a simple integer scalar or 1-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⌿Y implies the first axis of Y.<br/>If Y has length 1 along the Kth (or implied) axis, it is extended along that axis to match the length of X. Otherwise, the length of X must be the length of the Kth (or implied) axis of Y. However, if X is a scalar or one-element vector, it will be extended to the length of the Kth axis.<br/>R is composed from sub-arrays along the Kth axis of Y.  If X[I] (an element of X) is positive, then the corresponding sub-array is replicated X[I] times.  If X[I] is zero, then the corresponding sub-array of Y is excluded.  If X[I] is negative, then the fill element of  Y is replicated |X[I] times.  Each of the (replicated) sub-arrays and fill items are joined along the Kth axis in the order of occurrence.  The shape of R is the shape of Y except that the length of the (implied) Kth axis is +/|X (after possible extension).<br/>This function is sometimes called Compress when X is Boolean.<br/>If Y is a singleton (1=×/⍴,Y) its value is notionally extended to the length of X along the specified axis."
"Y may be any array.  X is a simple integer vector or scalar.<br/>The axis specification is optional.  If present, K must be a simple integer scalar or 1-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⌿Y implies the first axis of Y.<br/>If Y has length 1 along the Kth (or implied) axis, it is extended along that axis to match the length of X. Otherwise, the length of X must be the length of the Kth (or implied) axis of Y. However, if X is a scalar or one-element vector, it will be extended to the length of the Kth axis.<br/>R is composed from sub-arrays along the Kth axis of Y.  If X[I] (an element of X) is positive, then the corresponding sub-array is replicated X[I] times.  If X[I] is zero, then the corresponding sub-array of Y is excluded.  If X[I] is negative, then the fill element of  Y is replicated |X[I] times.  Each of the (replicated) sub-arrays and fill items are joined along the Kth axis in the order of occurrence.  The shape of R is the shape of Y except that the length of the (implied) Kth axis is +/|X (after possible extension).<br/>This function is sometimes called Compress when X is Boolean.<br/>If Y is a singleton (1=×/⍴,Y) its value is notionally extended to the length of X along the specified axis.",Replicate
": Reduce First,  Reduce First N-Wise<![CDATA[     ]]>",⌿
The form R←f⌿Y implies reduction along the first axis of Y. See Reduce.,⌿
⌿,The form R←f⌿Y implies reduction along the first axis of Y. See Reduce.
ReduceFirst,⌿
ReduceFirst,The form R←f⌿Y implies reduction along the first axis of Y. See Reduce.
The form R←f⌿Y implies reduction along the first axis of Y. See Reduce.,ReduceFirst
⌿,"Slash Bar<br/>Dyadic: Replicate First (Compress First)<br/>: Reduce First,  Reduce First N-Wise<![CDATA[     ]]>"
Back Slash,\
Dyadic: Expand,\
"Y may be any array.  X is a simple integer scalar or vector.  The axis specification is optional.  If present, K must be a simple integer scalar or 1-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⍀Y implies the first axis.  If Y is a scalar, it is treated as a one-element vector.<br/>If Y has length 1 along the Kth (or implied) axis, it is extended along that axis to match the number of positive elements in X. Otherwise, the number of positive elements in X must be the length of the Kth (or implied) axis of Y.<br/>R is composed from the sub-arrays along the Kth axis of Y. If X[I] (an element of X) is the Jth positive element in X, then the Jth sub-array along the Kth axis of Y is replicated X[I] times. If X[I] is negative, then a sub-array of fill elements of Y is replicated |X[I] times and inserted in relative order along the Kth axis of the result. If X[I] is zero, it is treated as the value ¯1. The shape of R is the shape of Y except that the length of the Kth axis is +/1⌈|X.",\
\,"Y may be any array.  X is a simple integer scalar or vector.  The axis specification is optional.  If present, K must be a simple integer scalar or 1-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⍀Y implies the first axis.  If Y is a scalar, it is treated as a one-element vector.<br/>If Y has length 1 along the Kth (or implied) axis, it is extended along that axis to match the number of positive elements in X. Otherwise, the number of positive elements in X must be the length of the Kth (or implied) axis of Y.<br/>R is composed from the sub-arrays along the Kth axis of Y. If X[I] (an element of X) is the Jth positive element in X, then the Jth sub-array along the Kth axis of Y is replicated X[I] times. If X[I] is negative, then a sub-array of fill elements of Y is replicated |X[I] times and inserted in relative order along the Kth axis of the result. If X[I] is zero, it is treated as the value ¯1. The shape of R is the shape of Y except that the length of the Kth axis is +/1⌈|X."
Expand,"Y may be any array.  X is a simple integer scalar or vector.  The axis specification is optional.  If present, K must be a simple integer scalar or 1-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⍀Y implies the first axis.  If Y is a scalar, it is treated as a one-element vector.<br/>If Y has length 1 along the Kth (or implied) axis, it is extended along that axis to match the number of positive elements in X. Otherwise, the number of positive elements in X must be the length of the Kth (or implied) axis of Y.<br/>R is composed from the sub-arrays along the Kth axis of Y. If X[I] (an element of X) is the Jth positive element in X, then the Jth sub-array along the Kth axis of Y is replicated X[I] times. If X[I] is negative, then a sub-array of fill elements of Y is replicated |X[I] times and inserted in relative order along the Kth axis of the result. If X[I] is zero, it is treated as the value ¯1. The shape of R is the shape of Y except that the length of the Kth axis is +/1⌈|X."
"Y may be any array.  X is a simple integer scalar or vector.  The axis specification is optional.  If present, K must be a simple integer scalar or 1-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⍀Y implies the first axis.  If Y is a scalar, it is treated as a one-element vector.<br/>If Y has length 1 along the Kth (or implied) axis, it is extended along that axis to match the number of positive elements in X. Otherwise, the number of positive elements in X must be the length of the Kth (or implied) axis of Y.<br/>R is composed from the sub-arrays along the Kth axis of Y. If X[I] (an element of X) is the Jth positive element in X, then the Jth sub-array along the Kth axis of Y is replicated X[I] times. If X[I] is negative, then a sub-array of fill elements of Y is replicated |X[I] times and inserted in relative order along the Kth axis of the result. If X[I] is zero, it is treated as the value ¯1. The shape of R is the shape of Y except that the length of the Kth axis is +/1⌈|X.",Expand
: Scan,\
"f may be any dyadic function that returns a result.  Y may be any array whose items in the sub-arrays along the Kth axis are appropriate to the function f.<br/>The axis specification is optional.  If present, K must identify an axis of Y.  If absent, the last axis of Y is implied.  The form R←f⍀Y implies the first axis of Y.<br/>R is an array formed by successive reductions along the Kth axis of Y.  If V is a typical vector taken from the Kth axis of Y, then the Ith element of the result is determined as f/I↑V.<br/>The shape of R is the same as the shape of Y.  If Y is an empty array, then R is the same empty array.",\
\,"f may be any dyadic function that returns a result.  Y may be any array whose items in the sub-arrays along the Kth axis are appropriate to the function f.<br/>The axis specification is optional.  If present, K must identify an axis of Y.  If absent, the last axis of Y is implied.  The form R←f⍀Y implies the first axis of Y.<br/>R is an array formed by successive reductions along the Kth axis of Y.  If V is a typical vector taken from the Kth axis of Y, then the Ith element of the result is determined as f/I↑V.<br/>The shape of R is the same as the shape of Y.  If Y is an empty array, then R is the same empty array."
Scan,"f may be any dyadic function that returns a result.  Y may be any array whose items in the sub-arrays along the Kth axis are appropriate to the function f.<br/>The axis specification is optional.  If present, K must identify an axis of Y.  If absent, the last axis of Y is implied.  The form R←f⍀Y implies the first axis of Y.<br/>R is an array formed by successive reductions along the Kth axis of Y.  If V is a typical vector taken from the Kth axis of Y, then the Ith element of the result is determined as f/I↑V.<br/>The shape of R is the same as the shape of Y.  If Y is an empty array, then R is the same empty array."
"f may be any dyadic function that returns a result.  Y may be any array whose items in the sub-arrays along the Kth axis are appropriate to the function f.<br/>The axis specification is optional.  If present, K must identify an axis of Y.  If absent, the last axis of Y is implied.  The form R←f⍀Y implies the first axis of Y.<br/>R is an array formed by successive reductions along the Kth axis of Y.  If V is a typical vector taken from the Kth axis of Y, then the Ith element of the result is determined as f/I↑V.<br/>The shape of R is the same as the shape of Y.  If Y is an empty array, then R is the same empty array.",Scan
\,Back Slash<br/>Dyadic: Expand<br/>: Scan
Back Slash Bar,⍀
Dyadic: Expand  First,⍀
"Y may be any array.  X is a simple integer scalar or vector.  The axis specification is optional.  If present, K must be a simple integer scalar or 1-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⍀Y implies the first axis.  If Y is a scalar, it is treated as a one-element vector.<br/>If Y has length 1 along the Kth (or implied) axis, it is extended along that axis to match the number of positive elements in X. Otherwise, the number of positive elements in X must be the length of the Kth (or implied) axis of Y.<br/>R is composed from the sub-arrays along the Kth axis of Y. If X[I] (an element of X) is the Jth positive element in X, then the Jth sub-array along the Kth axis of Y is replicated X[I] times. If X[I] is negative, then a sub-array of fill elements of Y is replicated |X[I] times and inserted in relative order along the Kth axis of the result. If X[I] is zero, it is treated as the value ¯1. The shape of R is the shape of Y except that the length of the Kth axis is +/1⌈|X.",⍀
⍀,"Y may be any array.  X is a simple integer scalar or vector.  The axis specification is optional.  If present, K must be a simple integer scalar or 1-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⍀Y implies the first axis.  If Y is a scalar, it is treated as a one-element vector.<br/>If Y has length 1 along the Kth (or implied) axis, it is extended along that axis to match the number of positive elements in X. Otherwise, the number of positive elements in X must be the length of the Kth (or implied) axis of Y.<br/>R is composed from the sub-arrays along the Kth axis of Y. If X[I] (an element of X) is the Jth positive element in X, then the Jth sub-array along the Kth axis of Y is replicated X[I] times. If X[I] is negative, then a sub-array of fill elements of Y is replicated |X[I] times and inserted in relative order along the Kth axis of the result. If X[I] is zero, it is treated as the value ¯1. The shape of R is the shape of Y except that the length of the Kth axis is +/1⌈|X."
Expand,"Y may be any array.  X is a simple integer scalar or vector.  The axis specification is optional.  If present, K must be a simple integer scalar or 1-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⍀Y implies the first axis.  If Y is a scalar, it is treated as a one-element vector.<br/>If Y has length 1 along the Kth (or implied) axis, it is extended along that axis to match the number of positive elements in X. Otherwise, the number of positive elements in X must be the length of the Kth (or implied) axis of Y.<br/>R is composed from the sub-arrays along the Kth axis of Y. If X[I] (an element of X) is the Jth positive element in X, then the Jth sub-array along the Kth axis of Y is replicated X[I] times. If X[I] is negative, then a sub-array of fill elements of Y is replicated |X[I] times and inserted in relative order along the Kth axis of the result. If X[I] is zero, it is treated as the value ¯1. The shape of R is the shape of Y except that the length of the Kth axis is +/1⌈|X."
"Y may be any array.  X is a simple integer scalar or vector.  The axis specification is optional.  If present, K must be a simple integer scalar or 1-element vector.  The value of K must be an axis of Y.  If absent, the last axis of Y is implied.  The form R←X⍀Y implies the first axis.  If Y is a scalar, it is treated as a one-element vector.<br/>If Y has length 1 along the Kth (or implied) axis, it is extended along that axis to match the number of positive elements in X. Otherwise, the number of positive elements in X must be the length of the Kth (or implied) axis of Y.<br/>R is composed from the sub-arrays along the Kth axis of Y. If X[I] (an element of X) is the Jth positive element in X, then the Jth sub-array along the Kth axis of Y is replicated X[I] times. If X[I] is negative, then a sub-array of fill elements of Y is replicated |X[I] times and inserted in relative order along the Kth axis of the result. If X[I] is zero, it is treated as the value ¯1. The shape of R is the shape of Y except that the length of the Kth axis is +/1⌈|X.",Expand
: Scan First,⍀
The form R←f⍀Y implies scan along the first axis of Y.  See Scan.,⍀
⍀,The form R←f⍀Y implies scan along the first axis of Y.  See Scan.
ScanFirst,⍀
ScanFirst,The form R←f⍀Y implies scan along the first axis of Y.  See Scan.
The form R←f⍀Y implies scan along the first axis of Y.  See Scan.,ScanFirst
⍀,Back Slash Bar<br/>Dyadic: Expand  First<br/>: Scan First
Up Shoe,∩
Dyadic: Intersection,∩
"Y must be  a scalar or vector.  X must be a scalar or vector.  A scalar X or Y is treated as a one-element vector.  R is a vector composed of items occurring in both X and Y in the order of occurrence in X.  If an item is repeated in X and also occurs in Y, the item is also repeated in R.<br/>Items in X and Y are considered the same if X≡Y returns 1 for those items.<br/>⎕CT and ⎕DCT are  implicit arguments of Intersection.<br/>For performance information, see Search Functions and Hash Tables.",∩
∩,"Y must be  a scalar or vector.  X must be a scalar or vector.  A scalar X or Y is treated as a one-element vector.  R is a vector composed of items occurring in both X and Y in the order of occurrence in X.  If an item is repeated in X and also occurs in Y, the item is also repeated in R.<br/>Items in X and Y are considered the same if X≡Y returns 1 for those items.<br/>⎕CT and ⎕DCT are  implicit arguments of Intersection.<br/>For performance information, see Search Functions and Hash Tables."
Intersection,"Y must be  a scalar or vector.  X must be a scalar or vector.  A scalar X or Y is treated as a one-element vector.  R is a vector composed of items occurring in both X and Y in the order of occurrence in X.  If an item is repeated in X and also occurs in Y, the item is also repeated in R.<br/>Items in X and Y are considered the same if X≡Y returns 1 for those items.<br/>⎕CT and ⎕DCT are  implicit arguments of Intersection.<br/>For performance information, see Search Functions and Hash Tables."
"Y must be  a scalar or vector.  X must be a scalar or vector.  A scalar X or Y is treated as a one-element vector.  R is a vector composed of items occurring in both X and Y in the order of occurrence in X.  If an item is repeated in X and also occurs in Y, the item is also repeated in R.<br/>Items in X and Y are considered the same if X≡Y returns 1 for those items.<br/>⎕CT and ⎕DCT are  implicit arguments of Intersection.<br/>For performance information, see Search Functions and Hash Tables.",Intersection
∩,Up Shoe<br/>Dyadic: Intersection
Down Shoe,∪
Monadic: Unique,∪
"Y may be any array. R is a vector of the unique major cells of Y (the unique items of a vector, the unique rows of a matrix and so forth), in the order in which they first appear in Y.  For further information, see Major Cells.<br/>⎕CT and ⎕DCT are  implicit arguments of Unique.",∪
∪,"Y may be any array. R is a vector of the unique major cells of Y (the unique items of a vector, the unique rows of a matrix and so forth), in the order in which they first appear in Y.  For further information, see Major Cells.<br/>⎕CT and ⎕DCT are  implicit arguments of Unique."
Unique,"Y may be any array. R is a vector of the unique major cells of Y (the unique items of a vector, the unique rows of a matrix and so forth), in the order in which they first appear in Y.  For further information, see Major Cells.<br/>⎕CT and ⎕DCT are  implicit arguments of Unique."
"Y may be any array. R is a vector of the unique major cells of Y (the unique items of a vector, the unique rows of a matrix and so forth), in the order in which they first appear in Y.  For further information, see Major Cells.<br/>⎕CT and ⎕DCT are  implicit arguments of Unique.",Unique
Dyadic: Union,∪
"Y must be a vector.  X must be a vector.  If either argument is a scalar, it is treated as a one-element vector.  R is a vector of the elements of X catenated with the elements of Y which are not found in X.<br/>Items in X and Y are considered the same if X≡Y returns 1 for those items.<br/>⎕CT and ⎕DCT are  implicit arguments of Union.<br/>For performance information, see Search Functions and Hash Tables.",∪
∪,"Y must be a vector.  X must be a vector.  If either argument is a scalar, it is treated as a one-element vector.  R is a vector of the elements of X catenated with the elements of Y which are not found in X.<br/>Items in X and Y are considered the same if X≡Y returns 1 for those items.<br/>⎕CT and ⎕DCT are  implicit arguments of Union.<br/>For performance information, see Search Functions and Hash Tables."
Union,"Y must be a vector.  X must be a vector.  If either argument is a scalar, it is treated as a one-element vector.  R is a vector of the elements of X catenated with the elements of Y which are not found in X.<br/>Items in X and Y are considered the same if X≡Y returns 1 for those items.<br/>⎕CT and ⎕DCT are  implicit arguments of Union.<br/>For performance information, see Search Functions and Hash Tables."
"Y must be a vector.  X must be a vector.  If either argument is a scalar, it is treated as a one-element vector.  R is a vector of the elements of X catenated with the elements of Y which are not found in X.<br/>Items in X and Y are considered the same if X≡Y returns 1 for those items.<br/>⎕CT and ⎕DCT are  implicit arguments of Union.<br/>For performance information, see Search Functions and Hash Tables.",Union
∪,Down Shoe<br/>Monadic: Unique<br/>Dyadic: Union
Iota,⍳
Monadic: Index Generator,⍳
"Y must be a simple scalar or vector array of non-negative numbers. R is a numeric array composed of the set of all possible coordinates of an array of shape Y. The shape of R is Y and each element of R occurs in its self-indexing position in R. In particular, the following identity holds: <br/>⎕IO is an implicit argument of Index Generator. This function is also known as Interval.",⍳
⍳,"Y must be a simple scalar or vector array of non-negative numbers. R is a numeric array composed of the set of all possible coordinates of an array of shape Y. The shape of R is Y and each element of R occurs in its self-indexing position in R. In particular, the following identity holds: <br/>⎕IO is an implicit argument of Index Generator. This function is also known as Interval."
IndexGenerator,⍳
IndexGenerator,"Y must be a simple scalar or vector array of non-negative numbers. R is a numeric array composed of the set of all possible coordinates of an array of shape Y. The shape of R is Y and each element of R occurs in its self-indexing position in R. In particular, the following identity holds: <br/>⎕IO is an implicit argument of Index Generator. This function is also known as Interval."
"Y must be a simple scalar or vector array of non-negative numbers. R is a numeric array composed of the set of all possible coordinates of an array of shape Y. The shape of R is Y and each element of R occurs in its self-indexing position in R. In particular, the following identity holds: <br/>⎕IO is an implicit argument of Index Generator. This function is also known as Interval.",IndexGenerator
Dyadic: Index Of,⍳
"Y may be any array. X may be any array of rank 1 or more. <br/>In general, the function locates the first occurrence of sub-arrays in Y which match major cells of  X, where a major cell is  a sub-array on the leading dimension of X with shape 1↓⍴X. The shape of the result R is (1-⍴⍴X)↓⍴Y.<br/>If a sub-array of Y cannot be found in X, then the corresponding element of R will be ⎕IO+⊃⍴X.<br/>In particular, if X is a vector, the result R is a simple integer array with the same shape as Y identifying where elements of Y are first found in X. If an element of Y cannot be found in X, then the corresponding element of R will be ⎕IO+⊃⍴X.<br/>Elements of X and Y are considered the same if X≡Y returns 1 for those elements.<br/>⎕IO,  ⎕CT and ⎕DCT are implicit arguments of Index Of.<br/>Note that the expression y⍳x signals a LENGTH ERROR because it looks for major cells in the left argument, whose shape is 5 14 (that is 1↓⍴y), which is not the same as the trailing shape of x.<br/>For performance information, see Search Functions and Hash Tables.",⍳
⍳,"Y may be any array. X may be any array of rank 1 or more. <br/>In general, the function locates the first occurrence of sub-arrays in Y which match major cells of  X, where a major cell is  a sub-array on the leading dimension of X with shape 1↓⍴X. The shape of the result R is (1-⍴⍴X)↓⍴Y.<br/>If a sub-array of Y cannot be found in X, then the corresponding element of R will be ⎕IO+⊃⍴X.<br/>In particular, if X is a vector, the result R is a simple integer array with the same shape as Y identifying where elements of Y are first found in X. If an element of Y cannot be found in X, then the corresponding element of R will be ⎕IO+⊃⍴X.<br/>Elements of X and Y are considered the same if X≡Y returns 1 for those elements.<br/>⎕IO,  ⎕CT and ⎕DCT are implicit arguments of Index Of.<br/>Note that the expression y⍳x signals a LENGTH ERROR because it looks for major cells in the left argument, whose shape is 5 14 (that is 1↓⍴y), which is not the same as the trailing shape of x.<br/>For performance information, see Search Functions and Hash Tables."
IndexOf,⍳
IndexOf,"Y may be any array. X may be any array of rank 1 or more. <br/>In general, the function locates the first occurrence of sub-arrays in Y which match major cells of  X, where a major cell is  a sub-array on the leading dimension of X with shape 1↓⍴X. The shape of the result R is (1-⍴⍴X)↓⍴Y.<br/>If a sub-array of Y cannot be found in X, then the corresponding element of R will be ⎕IO+⊃⍴X.<br/>In particular, if X is a vector, the result R is a simple integer array with the same shape as Y identifying where elements of Y are first found in X. If an element of Y cannot be found in X, then the corresponding element of R will be ⎕IO+⊃⍴X.<br/>Elements of X and Y are considered the same if X≡Y returns 1 for those elements.<br/>⎕IO,  ⎕CT and ⎕DCT are implicit arguments of Index Of.<br/>Note that the expression y⍳x signals a LENGTH ERROR because it looks for major cells in the left argument, whose shape is 5 14 (that is 1↓⍴y), which is not the same as the trailing shape of x.<br/>For performance information, see Search Functions and Hash Tables."
"Y may be any array. X may be any array of rank 1 or more. <br/>In general, the function locates the first occurrence of sub-arrays in Y which match major cells of  X, where a major cell is  a sub-array on the leading dimension of X with shape 1↓⍴X. The shape of the result R is (1-⍴⍴X)↓⍴Y.<br/>If a sub-array of Y cannot be found in X, then the corresponding element of R will be ⎕IO+⊃⍴X.<br/>In particular, if X is a vector, the result R is a simple integer array with the same shape as Y identifying where elements of Y are first found in X. If an element of Y cannot be found in X, then the corresponding element of R will be ⎕IO+⊃⍴X.<br/>Elements of X and Y are considered the same if X≡Y returns 1 for those elements.<br/>⎕IO,  ⎕CT and ⎕DCT are implicit arguments of Index Of.<br/>Note that the expression y⍳x signals a LENGTH ERROR because it looks for major cells in the left argument, whose shape is 5 14 (that is 1↓⍴y), which is not the same as the trailing shape of x.<br/>For performance information, see Search Functions and Hash Tables.",IndexOf
⍳,Iota<br/>Monadic: Index Generator<br/>Dyadic: Index Of
Iota Underbar,⍸
Monadic: Where,⍸
"Classic Edition: the symbol вҚё (Iota Underbar) is not available in Classic Edition, and Where is instead represented by вҺ•U2378.<br/>Y must be a simple Boolean or numeric array of non-negative integers.<br/>The model for Where can be expressed as {(,вҚө)/,вҚівҚҙвҚө}.<br/>If Y is Boolean, R is a vector of the indices of all the 1s in Y. If Y is all zeros, R is an empty vector.<br/>вҺ•IO is an implicit argument of Where.",⍸
⍸,"Classic Edition: the symbol вҚё (Iota Underbar) is not available in Classic Edition, and Where is instead represented by вҺ•U2378.<br/>Y must be a simple Boolean or numeric array of non-negative integers.<br/>The model for Where can be expressed as {(,вҚө)/,вҚівҚҙвҚө}.<br/>If Y is Boolean, R is a vector of the indices of all the 1s in Y. If Y is all zeros, R is an empty vector.<br/>вҺ•IO is an implicit argument of Where."
Where,"Classic Edition: the symbol вҚё (Iota Underbar) is not available in Classic Edition, and Where is instead represented by вҺ•U2378.<br/>Y must be a simple Boolean or numeric array of non-negative integers.<br/>The model for Where can be expressed as {(,вҚө)/,вҚівҚҙвҚө}.<br/>If Y is Boolean, R is a vector of the indices of all the 1s in Y. If Y is all zeros, R is an empty vector.<br/>вҺ•IO is an implicit argument of Where."
"Classic Edition: the symbol вҚё (Iota Underbar) is not available in Classic Edition, and Where is instead represented by вҺ•U2378.<br/>Y must be a simple Boolean or numeric array of non-negative integers.<br/>The model for Where can be expressed as {(,вҚө)/,вҚівҚҙвҚө}.<br/>If Y is Boolean, R is a vector of the indices of all the 1s in Y. If Y is all zeros, R is an empty vector.<br/>вҺ•IO is an implicit argument of Where.",Where
Dyadic: Interval Index,⍸
"Classic Edition: the symbol ⍸ (Iota Underbar) is not available in Classic Edition, and Interval Index is instead represented by ⎕U2378.<br/>X is an ordered non-scalar array that represents a set of intervals or ranges.<br/>Note that the ith interval starts at  X[i], then includes all subsequent values up to but not including X[i+1]. <br/>For example, if X is  (1 3 5) it defines 4 intervals numbered 0 to 3 as follows.<br/>If X is 'AEIOU' it defines 6 intervals numbered 0 to 5 as follows:<br/>Y is an array of the same type (numeric or character) as X.<br/>The result R is an integer array that identifies into which interval  the corresponding value in Y falls.<br/>Like dyadic ⍳ (see Index Of), Interval Index works with major cells. For a vector these are its elements; for a matrix its rows, and so forth.<br/>X and Y are compared using  the same logic as monadic ⍋ (see Grade Up (Monadic)) which is independent of ⎕CT and ⎕DCT. <br/>⎕IO is an implicit argument of Interval Index. In all the following examples, ⎕IO is 1.<br/>In the above example:<br/>And in the alphabetic example above:<br/>Commercially, olive oil is graded as follows:<br/>x represents some data sampled in chronological order at timestamps t.<br/>
u represents timestamps for 5-minute intervals:<br/>
Therefore, the expression (u⍸t){+/⍵}⌸x summarises x in 5-minute intervals.<br/>If X is a higher rank array, the function compares sub-arrays in Y  with the major cells of  X, where a major cell is  a sub-array on the leading dimension of X with shape 1↓⍴X. In this case, the shape of the result R is (1-⍴⍴X)↓⍴Y.<br/>A card-player likes to sort a hand into suits spades, hearts, diamond, clubs (fortunately alphabetic) and high-to-low within each suit.<br/>Another card, the 10 of diamonds is dealt. Where must it go in the hand ?<br/>Note that if (∧/Y∊X) and X is sorted and ⎕CT=0 ,then x⍸y is the same as x⍳y.",⍸
⍸,"Classic Edition: the symbol ⍸ (Iota Underbar) is not available in Classic Edition, and Interval Index is instead represented by ⎕U2378.<br/>X is an ordered non-scalar array that represents a set of intervals or ranges.<br/>Note that the ith interval starts at  X[i], then includes all subsequent values up to but not including X[i+1]. <br/>For example, if X is  (1 3 5) it defines 4 intervals numbered 0 to 3 as follows.<br/>If X is 'AEIOU' it defines 6 intervals numbered 0 to 5 as follows:<br/>Y is an array of the same type (numeric or character) as X.<br/>The result R is an integer array that identifies into which interval  the corresponding value in Y falls.<br/>Like dyadic ⍳ (see Index Of), Interval Index works with major cells. For a vector these are its elements; for a matrix its rows, and so forth.<br/>X and Y are compared using  the same logic as monadic ⍋ (see Grade Up (Monadic)) which is independent of ⎕CT and ⎕DCT. <br/>⎕IO is an implicit argument of Interval Index. In all the following examples, ⎕IO is 1.<br/>In the above example:<br/>And in the alphabetic example above:<br/>Commercially, olive oil is graded as follows:<br/>x represents some data sampled in chronological order at timestamps t.<br/>
u represents timestamps for 5-minute intervals:<br/>
Therefore, the expression (u⍸t){+/⍵}⌸x summarises x in 5-minute intervals.<br/>If X is a higher rank array, the function compares sub-arrays in Y  with the major cells of  X, where a major cell is  a sub-array on the leading dimension of X with shape 1↓⍴X. In this case, the shape of the result R is (1-⍴⍴X)↓⍴Y.<br/>A card-player likes to sort a hand into suits spades, hearts, diamond, clubs (fortunately alphabetic) and high-to-low within each suit.<br/>Another card, the 10 of diamonds is dealt. Where must it go in the hand ?<br/>Note that if (∧/Y∊X) and X is sorted and ⎕CT=0 ,then x⍸y is the same as x⍳y."
IntervalIndex,⍸
IntervalIndex,"Classic Edition: the symbol ⍸ (Iota Underbar) is not available in Classic Edition, and Interval Index is instead represented by ⎕U2378.<br/>X is an ordered non-scalar array that represents a set of intervals or ranges.<br/>Note that the ith interval starts at  X[i], then includes all subsequent values up to but not including X[i+1]. <br/>For example, if X is  (1 3 5) it defines 4 intervals numbered 0 to 3 as follows.<br/>If X is 'AEIOU' it defines 6 intervals numbered 0 to 5 as follows:<br/>Y is an array of the same type (numeric or character) as X.<br/>The result R is an integer array that identifies into which interval  the corresponding value in Y falls.<br/>Like dyadic ⍳ (see Index Of), Interval Index works with major cells. For a vector these are its elements; for a matrix its rows, and so forth.<br/>X and Y are compared using  the same logic as monadic ⍋ (see Grade Up (Monadic)) which is independent of ⎕CT and ⎕DCT. <br/>⎕IO is an implicit argument of Interval Index. In all the following examples, ⎕IO is 1.<br/>In the above example:<br/>And in the alphabetic example above:<br/>Commercially, olive oil is graded as follows:<br/>x represents some data sampled in chronological order at timestamps t.<br/>
u represents timestamps for 5-minute intervals:<br/>
Therefore, the expression (u⍸t){+/⍵}⌸x summarises x in 5-minute intervals.<br/>If X is a higher rank array, the function compares sub-arrays in Y  with the major cells of  X, where a major cell is  a sub-array on the leading dimension of X with shape 1↓⍴X. In this case, the shape of the result R is (1-⍴⍴X)↓⍴Y.<br/>A card-player likes to sort a hand into suits spades, hearts, diamond, clubs (fortunately alphabetic) and high-to-low within each suit.<br/>Another card, the 10 of diamonds is dealt. Where must it go in the hand ?<br/>Note that if (∧/Y∊X) and X is sorted and ⎕CT=0 ,then x⍸y is the same as x⍳y."
"Classic Edition: the symbol ⍸ (Iota Underbar) is not available in Classic Edition, and Interval Index is instead represented by ⎕U2378.<br/>X is an ordered non-scalar array that represents a set of intervals or ranges.<br/>Note that the ith interval starts at  X[i], then includes all subsequent values up to but not including X[i+1]. <br/>For example, if X is  (1 3 5) it defines 4 intervals numbered 0 to 3 as follows.<br/>If X is 'AEIOU' it defines 6 intervals numbered 0 to 5 as follows:<br/>Y is an array of the same type (numeric or character) as X.<br/>The result R is an integer array that identifies into which interval  the corresponding value in Y falls.<br/>Like dyadic ⍳ (see Index Of), Interval Index works with major cells. For a vector these are its elements; for a matrix its rows, and so forth.<br/>X and Y are compared using  the same logic as monadic ⍋ (see Grade Up (Monadic)) which is independent of ⎕CT and ⎕DCT. <br/>⎕IO is an implicit argument of Interval Index. In all the following examples, ⎕IO is 1.<br/>In the above example:<br/>And in the alphabetic example above:<br/>Commercially, olive oil is graded as follows:<br/>x represents some data sampled in chronological order at timestamps t.<br/>
u represents timestamps for 5-minute intervals:<br/>
Therefore, the expression (u⍸t){+/⍵}⌸x summarises x in 5-minute intervals.<br/>If X is a higher rank array, the function compares sub-arrays in Y  with the major cells of  X, where a major cell is  a sub-array on the leading dimension of X with shape 1↓⍴X. In this case, the shape of the result R is (1-⍴⍴X)↓⍴Y.<br/>A card-player likes to sort a hand into suits spades, hearts, diamond, clubs (fortunately alphabetic) and high-to-low within each suit.<br/>Another card, the 10 of diamonds is dealt. Where must it go in the hand ?<br/>Note that if (∧/Y∊X) and X is sorted and ⎕CT=0 ,then x⍸y is the same as x⍳y.",IntervalIndex
⍸,Iota Underbar<br/>Monadic: Where<br/>Dyadic: Interval Index
Squad,⌷
: Materialise,⌷
"If Y is a ref to an instance of a Dyalog Class with a Default  property:<br/>If  Y is a ref to an instance of a COM or .NET Collection object, ⌷ returns a vector containing all its items.<br/>Otherwise, if Y is an array, Y is returned.<br/>The following example uses the sample ComponentFile Class.<br/>The following example shows how ⌷obtains the items in an Excel Sheets collection .<br/>Note that the values of the index set are obtained or assigned by calls to the corresponding PropertyGet and PropertySet functions. Furthermore, if there is a sequence of primitive functions to the left of the Index function, that operate on the index set itself (functions such as dyadic ⍴,↑,↓,⊃) as opposed to functions that operate on the values of the index set (functions such as +,⌈,⌊,⍴¨), calls to the PropertyGet and PropertySet functions are deferred until the required index set has been completely determined. The full set of functions that cause deferral of calls to the PropertyGet and PropertySet functions is the same as the set of functions that applies to selective specification.<br/>If for example, CompFile is an Instance of the ComponentFile Class:<br/>would only call the PropertyGet function (for CompFile) once, to get the value of the last element.<br/>Note that similarly, the expression <br/>would call the PropertyGet function 10000 times, on repeated indices if CompFile has less than 10000 elements. The deferral of access function calls is intended to be an optimisation, but can have the opposite effect. You can avoid unnecessary repetitive calls by assigning the result of ⌷ to a temporary variable.",⌷
⌷,"If Y is a ref to an instance of a Dyalog Class with a Default  property:<br/>If  Y is a ref to an instance of a COM or .NET Collection object, ⌷ returns a vector containing all its items.<br/>Otherwise, if Y is an array, Y is returned.<br/>The following example uses the sample ComponentFile Class.<br/>The following example shows how ⌷obtains the items in an Excel Sheets collection .<br/>Note that the values of the index set are obtained or assigned by calls to the corresponding PropertyGet and PropertySet functions. Furthermore, if there is a sequence of primitive functions to the left of the Index function, that operate on the index set itself (functions such as dyadic ⍴,↑,↓,⊃) as opposed to functions that operate on the values of the index set (functions such as +,⌈,⌊,⍴¨), calls to the PropertyGet and PropertySet functions are deferred until the required index set has been completely determined. The full set of functions that cause deferral of calls to the PropertyGet and PropertySet functions is the same as the set of functions that applies to selective specification.<br/>If for example, CompFile is an Instance of the ComponentFile Class:<br/>would only call the PropertyGet function (for CompFile) once, to get the value of the last element.<br/>Note that similarly, the expression <br/>would call the PropertyGet function 10000 times, on repeated indices if CompFile has less than 10000 elements. The deferral of access function calls is intended to be an optimisation, but can have the opposite effect. You can avoid unnecessary repetitive calls by assigning the result of ⌷ to a temporary variable."
Materialise,"If Y is a ref to an instance of a Dyalog Class with a Default  property:<br/>If  Y is a ref to an instance of a COM or .NET Collection object, ⌷ returns a vector containing all its items.<br/>Otherwise, if Y is an array, Y is returned.<br/>The following example uses the sample ComponentFile Class.<br/>The following example shows how ⌷obtains the items in an Excel Sheets collection .<br/>Note that the values of the index set are obtained or assigned by calls to the corresponding PropertyGet and PropertySet functions. Furthermore, if there is a sequence of primitive functions to the left of the Index function, that operate on the index set itself (functions such as dyadic ⍴,↑,↓,⊃) as opposed to functions that operate on the values of the index set (functions such as +,⌈,⌊,⍴¨), calls to the PropertyGet and PropertySet functions are deferred until the required index set has been completely determined. The full set of functions that cause deferral of calls to the PropertyGet and PropertySet functions is the same as the set of functions that applies to selective specification.<br/>If for example, CompFile is an Instance of the ComponentFile Class:<br/>would only call the PropertyGet function (for CompFile) once, to get the value of the last element.<br/>Note that similarly, the expression <br/>would call the PropertyGet function 10000 times, on repeated indices if CompFile has less than 10000 elements. The deferral of access function calls is intended to be an optimisation, but can have the opposite effect. You can avoid unnecessary repetitive calls by assigning the result of ⌷ to a temporary variable."
"If Y is a ref to an instance of a Dyalog Class with a Default  property:<br/>If  Y is a ref to an instance of a COM or .NET Collection object, ⌷ returns a vector containing all its items.<br/>Otherwise, if Y is an array, Y is returned.<br/>The following example uses the sample ComponentFile Class.<br/>The following example shows how ⌷obtains the items in an Excel Sheets collection .<br/>Note that the values of the index set are obtained or assigned by calls to the corresponding PropertyGet and PropertySet functions. Furthermore, if there is a sequence of primitive functions to the left of the Index function, that operate on the index set itself (functions such as dyadic ⍴,↑,↓,⊃) as opposed to functions that operate on the values of the index set (functions such as +,⌈,⌊,⍴¨), calls to the PropertyGet and PropertySet functions are deferred until the required index set has been completely determined. The full set of functions that cause deferral of calls to the PropertyGet and PropertySet functions is the same as the set of functions that applies to selective specification.<br/>If for example, CompFile is an Instance of the ComponentFile Class:<br/>would only call the PropertyGet function (for CompFile) once, to get the value of the last element.<br/>Note that similarly, the expression <br/>would call the PropertyGet function 10000 times, on repeated indices if CompFile has less than 10000 elements. The deferral of access function calls is intended to be an optimisation, but can have the opposite effect. You can avoid unnecessary repetitive calls by assigning the result of ⌷ to a temporary variable.",Materialise
: Index,⌷
"X must be a scalar or vector of depth ≤2, of integers each ≥⎕IO. Y may be any array. K is a simple scalar or vector specifying axes of Y. The length of K must be the same as the length of X:<br/>In general, the result R is similar to that obtained by square-bracket indexing with elided subscripts. Items of K distribute items of X along the axes of Y. For example:<br/>Note that index with axis may be used with selective specification. ⎕IO is an implicit argument of index with axis.",⌷
⌷,"X must be a scalar or vector of depth ≤2, of integers each ≥⎕IO. Y may be any array. K is a simple scalar or vector specifying axes of Y. The length of K must be the same as the length of X:<br/>In general, the result R is similar to that obtained by square-bracket indexing with elided subscripts. Items of K distribute items of X along the axes of Y. For example:<br/>Note that index with axis may be used with selective specification. ⎕IO is an implicit argument of index with axis."
IndexwithAxes,⌷
IndexwithAxes,"X must be a scalar or vector of depth ≤2, of integers each ≥⎕IO. Y may be any array. K is a simple scalar or vector specifying axes of Y. The length of K must be the same as the length of X:<br/>In general, the result R is similar to that obtained by square-bracket indexing with elided subscripts. Items of K distribute items of X along the axes of Y. For example:<br/>Note that index with axis may be used with selective specification. ⎕IO is an implicit argument of index with axis."
"X must be a scalar or vector of depth ≤2, of integers each ≥⎕IO. Y may be any array. K is a simple scalar or vector specifying axes of Y. The length of K must be the same as the length of X:<br/>In general, the result R is similar to that obtained by square-bracket indexing with elided subscripts. Items of K distribute items of X along the axes of Y. For example:<br/>Note that index with axis may be used with selective specification. ⎕IO is an implicit argument of index with axis.",IndexwithAxes
⌷,Squad<br/>: Materialise<br/>: Index
Grade Up,⍋
Monadic: Grade Up,⍋
"Y may be any array of rank greater than 0 but may not contain namespaces.  R is an integer vector being the permutation of ⍳1↑⍴Y that places the sub-arrays along the first axis in ascending order. The rules for comparing items of Y with one another are as follows:<br/>⎕IO is an implicit argument of Grade Up<br/>Note that character arrays sort differently in the Unicode and Classic Editions.
",⍋
⍋,"Y may be any array of rank greater than 0 but may not contain namespaces.  R is an integer vector being the permutation of ⍳1↑⍴Y that places the sub-arrays along the first axis in ascending order. The rules for comparing items of Y with one another are as follows:<br/>⎕IO is an implicit argument of Grade Up<br/>Note that character arrays sort differently in the Unicode and Classic Editions.
"
GradeUp(Monadic),⍋
GradeUp(Monadic),"Y may be any array of rank greater than 0 but may not contain namespaces.  R is an integer vector being the permutation of ⍳1↑⍴Y that places the sub-arrays along the first axis in ascending order. The rules for comparing items of Y with one another are as follows:<br/>⎕IO is an implicit argument of Grade Up<br/>Note that character arrays sort differently in the Unicode and Classic Editions.
"
"Y may be any array of rank greater than 0 but may not contain namespaces.  R is an integer vector being the permutation of ⍳1↑⍴Y that places the sub-arrays along the first axis in ascending order. The rules for comparing items of Y with one another are as follows:<br/>⎕IO is an implicit argument of Grade Up<br/>Note that character arrays sort differently in the Unicode and Classic Editions.
",GradeUp(Monadic)
Dyadic: Dyadic Grade Up,⍋
"Y must be a simple character array of rank greater than 0.  X must be a simple character array of rank 1 or greater.  R is a simple integer vector being the permutation of вҚі1вҶ‘вҚҙY that places the sub-arrays of Y along the first axis in ascending order according to the collation sequence X.<br/>If X is a vector, the following identity holds:<br/>If X is a higher-rank array, each axis of X represents a grading attribute in increasing order of importance (the first axis is the least significant and the last axis is the most significant).  If a character is repeated in X, it is treated as though it were located at the position in the array determined by the lowest index in each axis for all occurrences of the character.  The character has the same weighting as the character located at the derived position in X.",⍋
⍋,"Y must be a simple character array of rank greater than 0.  X must be a simple character array of rank 1 or greater.  R is a simple integer vector being the permutation of вҚі1вҶ‘вҚҙY that places the sub-arrays of Y along the first axis in ascending order according to the collation sequence X.<br/>If X is a vector, the following identity holds:<br/>If X is a higher-rank array, each axis of X represents a grading attribute in increasing order of importance (the first axis is the least significant and the last axis is the most significant).  If a character is repeated in X, it is treated as though it were located at the position in the array determined by the lowest index in each axis for all occurrences of the character.  The character has the same weighting as the character located at the derived position in X."
GradeUp(Dyadic),⍋
GradeUp(Dyadic),"Y must be a simple character array of rank greater than 0.  X must be a simple character array of rank 1 or greater.  R is a simple integer vector being the permutation of вҚі1вҶ‘вҚҙY that places the sub-arrays of Y along the first axis in ascending order according to the collation sequence X.<br/>If X is a vector, the following identity holds:<br/>If X is a higher-rank array, each axis of X represents a grading attribute in increasing order of importance (the first axis is the least significant and the last axis is the most significant).  If a character is repeated in X, it is treated as though it were located at the position in the array determined by the lowest index in each axis for all occurrences of the character.  The character has the same weighting as the character located at the derived position in X."
"Y must be a simple character array of rank greater than 0.  X must be a simple character array of rank 1 or greater.  R is a simple integer vector being the permutation of вҚі1вҶ‘вҚҙY that places the sub-arrays of Y along the first axis in ascending order according to the collation sequence X.<br/>If X is a vector, the following identity holds:<br/>If X is a higher-rank array, each axis of X represents a grading attribute in increasing order of importance (the first axis is the least significant and the last axis is the most significant).  If a character is repeated in X, it is treated as though it were located at the position in the array determined by the lowest index in each axis for all occurrences of the character.  The character has the same weighting as the character located at the derived position in X.",GradeUp(Dyadic)
⍋,Grade Up<br/>Monadic: Grade Up<br/>Dyadic: Dyadic Grade Up
Grade Down,⍒
Monadic: Grade Down,⍒
"Y may be any array of rank greater than 0 but may not contain namespaces.  R is an integer vector being the permutation of ⍳1↑⍴Y that places the sub-arrays along the first axis in descending order. For the rules for comparing items of Y with one another, see Grade Up (Monadic).<br/>⎕IO is an implicit argument of Grade Down.<br/>Note that character arrays sort differently in the Unicode and Classic Editions.
",⍒
⍒,"Y may be any array of rank greater than 0 but may not contain namespaces.  R is an integer vector being the permutation of ⍳1↑⍴Y that places the sub-arrays along the first axis in descending order. For the rules for comparing items of Y with one another, see Grade Up (Monadic).<br/>⎕IO is an implicit argument of Grade Down.<br/>Note that character arrays sort differently in the Unicode and Classic Editions.
"
GradeDown(Monadic),⍒
GradeDown(Monadic),"Y may be any array of rank greater than 0 but may not contain namespaces.  R is an integer vector being the permutation of ⍳1↑⍴Y that places the sub-arrays along the first axis in descending order. For the rules for comparing items of Y with one another, see Grade Up (Monadic).<br/>⎕IO is an implicit argument of Grade Down.<br/>Note that character arrays sort differently in the Unicode and Classic Editions.
"
"Y may be any array of rank greater than 0 but may not contain namespaces.  R is an integer vector being the permutation of ⍳1↑⍴Y that places the sub-arrays along the first axis in descending order. For the rules for comparing items of Y with one another, see Grade Up (Monadic).<br/>⎕IO is an implicit argument of Grade Down.<br/>Note that character arrays sort differently in the Unicode and Classic Editions.
",GradeDown(Monadic)
Dyadic: Dyadic Grade Down,⍒
"Y must be a simple character array of rank greater than 0.  X must be a simple character array of rank 1 or greater.  R is a simple integer vector of shape 1↑⍴Y containing the permutation of ⍳1↑⍴Y that places the sub-arrays of Y along the first axis in descending order according to the collation sequence X.  The indices of any set of identical sub-arrays in Y occur in R in ascending order.<br/>If X is a vector, the following identity holds:<br/>A left argument of rank greater than 1 allows successive resolution of duplicate orderings in the following way.<br/>Starting with the last axis:<br/>The process is repeated using each axis in turn, from the last to the first, resolving duplicates until either no duplicates result or all axes have been exhausted.<br/>For example, if index origin is 1:<br/>Along last axis:<br/>Duplicates exist, so resolve these with respect to the first axis:<br/>So the final row ordering is:<br/>That is, the order of rows is 4 2 1 3 which corresponds to a descending row sort of:<br/>The following results are tabulated for comparison:<br/>⎕IO is an implicit argument of Grade Down.",⍒
⍒,"Y must be a simple character array of rank greater than 0.  X must be a simple character array of rank 1 or greater.  R is a simple integer vector of shape 1↑⍴Y containing the permutation of ⍳1↑⍴Y that places the sub-arrays of Y along the first axis in descending order according to the collation sequence X.  The indices of any set of identical sub-arrays in Y occur in R in ascending order.<br/>If X is a vector, the following identity holds:<br/>A left argument of rank greater than 1 allows successive resolution of duplicate orderings in the following way.<br/>Starting with the last axis:<br/>The process is repeated using each axis in turn, from the last to the first, resolving duplicates until either no duplicates result or all axes have been exhausted.<br/>For example, if index origin is 1:<br/>Along last axis:<br/>Duplicates exist, so resolve these with respect to the first axis:<br/>So the final row ordering is:<br/>That is, the order of rows is 4 2 1 3 which corresponds to a descending row sort of:<br/>The following results are tabulated for comparison:<br/>⎕IO is an implicit argument of Grade Down."
GradeDown(Dyadic),⍒
GradeDown(Dyadic),"Y must be a simple character array of rank greater than 0.  X must be a simple character array of rank 1 or greater.  R is a simple integer vector of shape 1↑⍴Y containing the permutation of ⍳1↑⍴Y that places the sub-arrays of Y along the first axis in descending order according to the collation sequence X.  The indices of any set of identical sub-arrays in Y occur in R in ascending order.<br/>If X is a vector, the following identity holds:<br/>A left argument of rank greater than 1 allows successive resolution of duplicate orderings in the following way.<br/>Starting with the last axis:<br/>The process is repeated using each axis in turn, from the last to the first, resolving duplicates until either no duplicates result or all axes have been exhausted.<br/>For example, if index origin is 1:<br/>Along last axis:<br/>Duplicates exist, so resolve these with respect to the first axis:<br/>So the final row ordering is:<br/>That is, the order of rows is 4 2 1 3 which corresponds to a descending row sort of:<br/>The following results are tabulated for comparison:<br/>⎕IO is an implicit argument of Grade Down."
"Y must be a simple character array of rank greater than 0.  X must be a simple character array of rank 1 or greater.  R is a simple integer vector of shape 1↑⍴Y containing the permutation of ⍳1↑⍴Y that places the sub-arrays of Y along the first axis in descending order according to the collation sequence X.  The indices of any set of identical sub-arrays in Y occur in R in ascending order.<br/>If X is a vector, the following identity holds:<br/>A left argument of rank greater than 1 allows successive resolution of duplicate orderings in the following way.<br/>Starting with the last axis:<br/>The process is repeated using each axis in turn, from the last to the first, resolving duplicates until either no duplicates result or all axes have been exhausted.<br/>For example, if index origin is 1:<br/>Along last axis:<br/>Duplicates exist, so resolve these with respect to the first axis:<br/>So the final row ordering is:<br/>That is, the order of rows is 4 2 1 3 which corresponds to a descending row sort of:<br/>The following results are tabulated for comparison:<br/>⎕IO is an implicit argument of Grade Down.",GradeDown(Dyadic)
⍒,Grade Down<br/>Monadic: Grade Down<br/>Dyadic: Dyadic Grade Down
Hydrant,⍎
Monadic: Execute expression,⍎
"Y must be a simple character scalar or vector containing an APL expression to be executed. The expression may contain one or more sub-expressions separated by ⋄ (Diamond) characters.<br/>If the result of the expression is used or is assigned to a name,  R is the result (if any) of the last-executed sub-expression and the non-shy results of all preceding expressions (that are not assigned within the expression) are displayed. Otherwise the unassigned non-shy results of all of the sub-expressions are displayed.<br/> If the expression is an empty vector or a vector containing only blanks or one that does not produce a result, then ⍎Y has no value and using or assigning it to a name will generate VALUE ERROR.<br/>If Y contains a branch expression, the branch is effected in the environment from which the Execute was invoked, and ⍎Y does not return.<br/>If specified, X must be a namespace reference or a simple character scalar or vector representing the name of a namespace in which the expression is to be executed. If X is omitted or is an empty character vector, the expression is executed in the current space.",⍎
⍎,"Y must be a simple character scalar or vector containing an APL expression to be executed. The expression may contain one or more sub-expressions separated by ⋄ (Diamond) characters.<br/>If the result of the expression is used or is assigned to a name,  R is the result (if any) of the last-executed sub-expression and the non-shy results of all preceding expressions (that are not assigned within the expression) are displayed. Otherwise the unassigned non-shy results of all of the sub-expressions are displayed.<br/> If the expression is an empty vector or a vector containing only blanks or one that does not produce a result, then ⍎Y has no value and using or assigning it to a name will generate VALUE ERROR.<br/>If Y contains a branch expression, the branch is effected in the environment from which the Execute was invoked, and ⍎Y does not return.<br/>If specified, X must be a namespace reference or a simple character scalar or vector representing the name of a namespace in which the expression is to be executed. If X is omitted or is an empty character vector, the expression is executed in the current space."
Execute,"Y must be a simple character scalar or vector containing an APL expression to be executed. The expression may contain one or more sub-expressions separated by ⋄ (Diamond) characters.<br/>If the result of the expression is used or is assigned to a name,  R is the result (if any) of the last-executed sub-expression and the non-shy results of all preceding expressions (that are not assigned within the expression) are displayed. Otherwise the unassigned non-shy results of all of the sub-expressions are displayed.<br/> If the expression is an empty vector or a vector containing only blanks or one that does not produce a result, then ⍎Y has no value and using or assigning it to a name will generate VALUE ERROR.<br/>If Y contains a branch expression, the branch is effected in the environment from which the Execute was invoked, and ⍎Y does not return.<br/>If specified, X must be a namespace reference or a simple character scalar or vector representing the name of a namespace in which the expression is to be executed. If X is omitted or is an empty character vector, the expression is executed in the current space."
"Y must be a simple character scalar or vector containing an APL expression to be executed. The expression may contain one or more sub-expressions separated by ⋄ (Diamond) characters.<br/>If the result of the expression is used or is assigned to a name,  R is the result (if any) of the last-executed sub-expression and the non-shy results of all preceding expressions (that are not assigned within the expression) are displayed. Otherwise the unassigned non-shy results of all of the sub-expressions are displayed.<br/> If the expression is an empty vector or a vector containing only blanks or one that does not produce a result, then ⍎Y has no value and using or assigning it to a name will generate VALUE ERROR.<br/>If Y contains a branch expression, the branch is effected in the environment from which the Execute was invoked, and ⍎Y does not return.<br/>If specified, X must be a namespace reference or a simple character scalar or vector representing the name of a namespace in which the expression is to be executed. If X is omitted or is an empty character vector, the expression is executed in the current space.",Execute
Dyadic: Execute expression in given namespace,⍎
"Y must be a simple character scalar or vector containing an APL expression to be executed. The expression may contain one or more sub-expressions separated by ⋄ (Diamond) characters.<br/>If the result of the expression is used or is assigned to a name,  R is the result (if any) of the last-executed sub-expression and the non-shy results of all preceding expressions (that are not assigned within the expression) are displayed. Otherwise the unassigned non-shy results of all of the sub-expressions are displayed.<br/> If the expression is an empty vector or a vector containing only blanks or one that does not produce a result, then ⍎Y has no value and using or assigning it to a name will generate VALUE ERROR.<br/>If Y contains a branch expression, the branch is effected in the environment from which the Execute was invoked, and ⍎Y does not return.<br/>If specified, X must be a namespace reference or a simple character scalar or vector representing the name of a namespace in which the expression is to be executed. If X is omitted or is an empty character vector, the expression is executed in the current space.",⍎
⍎,"Y must be a simple character scalar or vector containing an APL expression to be executed. The expression may contain one or more sub-expressions separated by ⋄ (Diamond) characters.<br/>If the result of the expression is used or is assigned to a name,  R is the result (if any) of the last-executed sub-expression and the non-shy results of all preceding expressions (that are not assigned within the expression) are displayed. Otherwise the unassigned non-shy results of all of the sub-expressions are displayed.<br/> If the expression is an empty vector or a vector containing only blanks or one that does not produce a result, then ⍎Y has no value and using or assigning it to a name will generate VALUE ERROR.<br/>If Y contains a branch expression, the branch is effected in the environment from which the Execute was invoked, and ⍎Y does not return.<br/>If specified, X must be a namespace reference or a simple character scalar or vector representing the name of a namespace in which the expression is to be executed. If X is omitted or is an empty character vector, the expression is executed in the current space."
Execute,"Y must be a simple character scalar or vector containing an APL expression to be executed. The expression may contain one or more sub-expressions separated by ⋄ (Diamond) characters.<br/>If the result of the expression is used or is assigned to a name,  R is the result (if any) of the last-executed sub-expression and the non-shy results of all preceding expressions (that are not assigned within the expression) are displayed. Otherwise the unassigned non-shy results of all of the sub-expressions are displayed.<br/> If the expression is an empty vector or a vector containing only blanks or one that does not produce a result, then ⍎Y has no value and using or assigning it to a name will generate VALUE ERROR.<br/>If Y contains a branch expression, the branch is effected in the environment from which the Execute was invoked, and ⍎Y does not return.<br/>If specified, X must be a namespace reference or a simple character scalar or vector representing the name of a namespace in which the expression is to be executed. If X is omitted or is an empty character vector, the expression is executed in the current space."
"Y must be a simple character scalar or vector containing an APL expression to be executed. The expression may contain one or more sub-expressions separated by ⋄ (Diamond) characters.<br/>If the result of the expression is used or is assigned to a name,  R is the result (if any) of the last-executed sub-expression and the non-shy results of all preceding expressions (that are not assigned within the expression) are displayed. Otherwise the unassigned non-shy results of all of the sub-expressions are displayed.<br/> If the expression is an empty vector or a vector containing only blanks or one that does not produce a result, then ⍎Y has no value and using or assigning it to a name will generate VALUE ERROR.<br/>If Y contains a branch expression, the branch is effected in the environment from which the Execute was invoked, and ⍎Y does not return.<br/>If specified, X must be a namespace reference or a simple character scalar or vector representing the name of a namespace in which the expression is to be executed. If X is omitted or is an empty character vector, the expression is executed in the current space.",Execute
⍎,Hydrant<br/>Monadic: Execute expression<br/>Dyadic: Execute expression in given namespace
Thorn,⍕
Monadic: Format,⍕
"Y may be any array.  R is a simple character array which will display identically to the display produced by Y.  The result is independent of ⎕PW.  If Y is a simple character array, then R is Y.<br/>If Y is a simple numeric scalar, then R is a vector containing the formatted number without any spaces.  A floating point number is formatted according to the system variable ⎕PP.  ⎕PP is ignored when formatting integers.<br/>Scaled notation is used if the magnitude of the non-integer number is too large to represent with ⎕PP significant digits or if the number requires more than five leading zeroes after the decimal point.<br/>If Y is a simple numeric vector, then R is a character vector in which each element of Y is independently formatted with a single separating space between formatted elements.<br/>If Y is a simple numeric array rank higher than one, R is a character array with the same shape as Y except that the last dimension of Y is determined by the length of the formatted data.  The format width is determined independently for each column of Y, such that:<br/>If Y is non-simple, and all items of Y at any depth are scalars or vectors, then R is a vector.<br/>By replacing spaces with ^, it is clearer to see how the result of ⍕ is formed:<br/>If Y is non-simple, and all items of Y at any depth are not scalars, then R is a matrix.<br/>By replacing spaces with ^, it is clearer to see how the result of ⍕ is formed:<br/>⎕PP is an implicit argument of Monadic Format.",⍕
⍕,"Y may be any array.  R is a simple character array which will display identically to the display produced by Y.  The result is independent of ⎕PW.  If Y is a simple character array, then R is Y.<br/>If Y is a simple numeric scalar, then R is a vector containing the formatted number without any spaces.  A floating point number is formatted according to the system variable ⎕PP.  ⎕PP is ignored when formatting integers.<br/>Scaled notation is used if the magnitude of the non-integer number is too large to represent with ⎕PP significant digits or if the number requires more than five leading zeroes after the decimal point.<br/>If Y is a simple numeric vector, then R is a character vector in which each element of Y is independently formatted with a single separating space between formatted elements.<br/>If Y is a simple numeric array rank higher than one, R is a character array with the same shape as Y except that the last dimension of Y is determined by the length of the formatted data.  The format width is determined independently for each column of Y, such that:<br/>If Y is non-simple, and all items of Y at any depth are scalars or vectors, then R is a vector.<br/>By replacing spaces with ^, it is clearer to see how the result of ⍕ is formed:<br/>If Y is non-simple, and all items of Y at any depth are not scalars, then R is a matrix.<br/>By replacing spaces with ^, it is clearer to see how the result of ⍕ is formed:<br/>⎕PP is an implicit argument of Monadic Format."
Format(Monadic),⍕
Format(Monadic),"Y may be any array.  R is a simple character array which will display identically to the display produced by Y.  The result is independent of ⎕PW.  If Y is a simple character array, then R is Y.<br/>If Y is a simple numeric scalar, then R is a vector containing the formatted number without any spaces.  A floating point number is formatted according to the system variable ⎕PP.  ⎕PP is ignored when formatting integers.<br/>Scaled notation is used if the magnitude of the non-integer number is too large to represent with ⎕PP significant digits or if the number requires more than five leading zeroes after the decimal point.<br/>If Y is a simple numeric vector, then R is a character vector in which each element of Y is independently formatted with a single separating space between formatted elements.<br/>If Y is a simple numeric array rank higher than one, R is a character array with the same shape as Y except that the last dimension of Y is determined by the length of the formatted data.  The format width is determined independently for each column of Y, such that:<br/>If Y is non-simple, and all items of Y at any depth are scalars or vectors, then R is a vector.<br/>By replacing spaces with ^, it is clearer to see how the result of ⍕ is formed:<br/>If Y is non-simple, and all items of Y at any depth are not scalars, then R is a matrix.<br/>By replacing spaces with ^, it is clearer to see how the result of ⍕ is formed:<br/>⎕PP is an implicit argument of Monadic Format."
"Y may be any array.  R is a simple character array which will display identically to the display produced by Y.  The result is independent of ⎕PW.  If Y is a simple character array, then R is Y.<br/>If Y is a simple numeric scalar, then R is a vector containing the formatted number without any spaces.  A floating point number is formatted according to the system variable ⎕PP.  ⎕PP is ignored when formatting integers.<br/>Scaled notation is used if the magnitude of the non-integer number is too large to represent with ⎕PP significant digits or if the number requires more than five leading zeroes after the decimal point.<br/>If Y is a simple numeric vector, then R is a character vector in which each element of Y is independently formatted with a single separating space between formatted elements.<br/>If Y is a simple numeric array rank higher than one, R is a character array with the same shape as Y except that the last dimension of Y is determined by the length of the formatted data.  The format width is determined independently for each column of Y, such that:<br/>If Y is non-simple, and all items of Y at any depth are scalars or vectors, then R is a vector.<br/>By replacing spaces with ^, it is clearer to see how the result of ⍕ is formed:<br/>If Y is non-simple, and all items of Y at any depth are not scalars, then R is a matrix.<br/>By replacing spaces with ^, it is clearer to see how the result of ⍕ is formed:<br/>⎕PP is an implicit argument of Monadic Format.",Format(Monadic)
Dyadic: Format By Specification,⍕
"Y must be a simple real (non-complex) numeric array.  X must be a simple integer scalar or vector.  R is a character array displaying the array Y according to the specification X.  R has rank 1⌈⍴⍴Y and ¯1↓⍴R is ¯1↓⍴Y. If any element of Y is complex, dyadic ⍕ reports a DOMAIN ERROR.<br/>Conformability requires that if X has more than two elements, then ⍴X must be 2×¯1↑⍴Y. If X contains one element, it is extended to (2×¯1↑⍴Y)⍴0,X.  If X contains 2 elements, it is extended to (2×¯1↑⍴Y)⍴X.<br/>X specifies two numbers (possibly after extension) for each column in Y.  For this purpose, scalar Y is treated as a one-element vector.  Each pair of numbers in X identifies a format width (W) and a format precision (P).<br/>If P is 0, the column is to be formatted as integers.<br/>If P is positive, the format is floating point with P significant digits to be displayed after the decimal point.<br/>If P is negative, scaled format is used with |P digits in the mantissa.<br/>If W is 0 or absent, then the width of the corresponding columns of R are determined by the maximum width required by any element in the corresponding columns of Y, plus one separating space.<br/>If a formatted element exceeds its specified field width when W>0, the field width for that element is filled with asterisks.<br/>If the format precision exceeds the internal precision, low order digits are replaced by the symbol '_'.<br/>The shape of R is the same as the shape of Y except that the last dimension of R is the sum of the field widths specified in X or deduced by the function.  If Y is a scalar, the shape of R is the field width.",⍕
⍕,"Y must be a simple real (non-complex) numeric array.  X must be a simple integer scalar or vector.  R is a character array displaying the array Y according to the specification X.  R has rank 1⌈⍴⍴Y and ¯1↓⍴R is ¯1↓⍴Y. If any element of Y is complex, dyadic ⍕ reports a DOMAIN ERROR.<br/>Conformability requires that if X has more than two elements, then ⍴X must be 2×¯1↑⍴Y. If X contains one element, it is extended to (2×¯1↑⍴Y)⍴0,X.  If X contains 2 elements, it is extended to (2×¯1↑⍴Y)⍴X.<br/>X specifies two numbers (possibly after extension) for each column in Y.  For this purpose, scalar Y is treated as a one-element vector.  Each pair of numbers in X identifies a format width (W) and a format precision (P).<br/>If P is 0, the column is to be formatted as integers.<br/>If P is positive, the format is floating point with P significant digits to be displayed after the decimal point.<br/>If P is negative, scaled format is used with |P digits in the mantissa.<br/>If W is 0 or absent, then the width of the corresponding columns of R are determined by the maximum width required by any element in the corresponding columns of Y, plus one separating space.<br/>If a formatted element exceeds its specified field width when W>0, the field width for that element is filled with asterisks.<br/>If the format precision exceeds the internal precision, low order digits are replaced by the symbol '_'.<br/>The shape of R is the same as the shape of Y except that the last dimension of R is the sum of the field widths specified in X or deduced by the function.  If Y is a scalar, the shape of R is the field width."
Format(Dyadic),⍕
Format(Dyadic),"Y must be a simple real (non-complex) numeric array.  X must be a simple integer scalar or vector.  R is a character array displaying the array Y according to the specification X.  R has rank 1⌈⍴⍴Y and ¯1↓⍴R is ¯1↓⍴Y. If any element of Y is complex, dyadic ⍕ reports a DOMAIN ERROR.<br/>Conformability requires that if X has more than two elements, then ⍴X must be 2×¯1↑⍴Y. If X contains one element, it is extended to (2×¯1↑⍴Y)⍴0,X.  If X contains 2 elements, it is extended to (2×¯1↑⍴Y)⍴X.<br/>X specifies two numbers (possibly after extension) for each column in Y.  For this purpose, scalar Y is treated as a one-element vector.  Each pair of numbers in X identifies a format width (W) and a format precision (P).<br/>If P is 0, the column is to be formatted as integers.<br/>If P is positive, the format is floating point with P significant digits to be displayed after the decimal point.<br/>If P is negative, scaled format is used with |P digits in the mantissa.<br/>If W is 0 or absent, then the width of the corresponding columns of R are determined by the maximum width required by any element in the corresponding columns of Y, plus one separating space.<br/>If a formatted element exceeds its specified field width when W>0, the field width for that element is filled with asterisks.<br/>If the format precision exceeds the internal precision, low order digits are replaced by the symbol '_'.<br/>The shape of R is the same as the shape of Y except that the last dimension of R is the sum of the field widths specified in X or deduced by the function.  If Y is a scalar, the shape of R is the field width."
"Y must be a simple real (non-complex) numeric array.  X must be a simple integer scalar or vector.  R is a character array displaying the array Y according to the specification X.  R has rank 1⌈⍴⍴Y and ¯1↓⍴R is ¯1↓⍴Y. If any element of Y is complex, dyadic ⍕ reports a DOMAIN ERROR.<br/>Conformability requires that if X has more than two elements, then ⍴X must be 2×¯1↑⍴Y. If X contains one element, it is extended to (2×¯1↑⍴Y)⍴0,X.  If X contains 2 elements, it is extended to (2×¯1↑⍴Y)⍴X.<br/>X specifies two numbers (possibly after extension) for each column in Y.  For this purpose, scalar Y is treated as a one-element vector.  Each pair of numbers in X identifies a format width (W) and a format precision (P).<br/>If P is 0, the column is to be formatted as integers.<br/>If P is positive, the format is floating point with P significant digits to be displayed after the decimal point.<br/>If P is negative, scaled format is used with |P digits in the mantissa.<br/>If W is 0 or absent, then the width of the corresponding columns of R are determined by the maximum width required by any element in the corresponding columns of Y, plus one separating space.<br/>If a formatted element exceeds its specified field width when W>0, the field width for that element is filled with asterisks.<br/>If the format precision exceeds the internal precision, low order digits are replaced by the symbol '_'.<br/>The shape of R is the same as the shape of Y except that the last dimension of R is the sum of the field widths specified in X or deduced by the function.  If Y is a scalar, the shape of R is the field width.",Format(Dyadic)
⍕,Thorn<br/>Monadic: Format<br/>Dyadic: Format By Specification
Up Tack,⊥
Dyadic: Decode,⊥
"Y must be a simple numeric array.  X must be a simple numeric array.  R is the numeric array which results from the evaluation of Y in the number system with radix X.<br/>X and Y are conformable if the length of the last axis of X is the same as the length of the first axis of Y.  A scalar or 1-element vector is extended to a vector of the required length.  If the last axis of X or the first axis of Y has a length of 1, the array is extended along that axis to conform with the other argument.<br/>The shape of R is the catenation of the shape of X less the last dimension with the shape of Y less the first dimension.  That is:<br/>For vector arguments, each element of X defines the ratio between the units for corresponding pairs of elements in Y.  The first element of X has no effect on the result.<br/>This function is also known as Base Value.<br/>If X is a scalar and Y a vector of length n, decode evaluates the polynomial(Index origin 1):<br/>For higher-rank array arguments, each of the vectors along the last axis of X is taken as the radix vector for each of the vectors along the first axis of Y.<br/>Scalar extension may be applied:<br/>Extension along a unit axis may be applied:",⊥
⊥,"Y must be a simple numeric array.  X must be a simple numeric array.  R is the numeric array which results from the evaluation of Y in the number system with radix X.<br/>X and Y are conformable if the length of the last axis of X is the same as the length of the first axis of Y.  A scalar or 1-element vector is extended to a vector of the required length.  If the last axis of X or the first axis of Y has a length of 1, the array is extended along that axis to conform with the other argument.<br/>The shape of R is the catenation of the shape of X less the last dimension with the shape of Y less the first dimension.  That is:<br/>For vector arguments, each element of X defines the ratio between the units for corresponding pairs of elements in Y.  The first element of X has no effect on the result.<br/>This function is also known as Base Value.<br/>If X is a scalar and Y a vector of length n, decode evaluates the polynomial(Index origin 1):<br/>For higher-rank array arguments, each of the vectors along the last axis of X is taken as the radix vector for each of the vectors along the first axis of Y.<br/>Scalar extension may be applied:<br/>Extension along a unit axis may be applied:"
Decode,"Y must be a simple numeric array.  X must be a simple numeric array.  R is the numeric array which results from the evaluation of Y in the number system with radix X.<br/>X and Y are conformable if the length of the last axis of X is the same as the length of the first axis of Y.  A scalar or 1-element vector is extended to a vector of the required length.  If the last axis of X or the first axis of Y has a length of 1, the array is extended along that axis to conform with the other argument.<br/>The shape of R is the catenation of the shape of X less the last dimension with the shape of Y less the first dimension.  That is:<br/>For vector arguments, each element of X defines the ratio between the units for corresponding pairs of elements in Y.  The first element of X has no effect on the result.<br/>This function is also known as Base Value.<br/>If X is a scalar and Y a vector of length n, decode evaluates the polynomial(Index origin 1):<br/>For higher-rank array arguments, each of the vectors along the last axis of X is taken as the radix vector for each of the vectors along the first axis of Y.<br/>Scalar extension may be applied:<br/>Extension along a unit axis may be applied:"
"Y must be a simple numeric array.  X must be a simple numeric array.  R is the numeric array which results from the evaluation of Y in the number system with radix X.<br/>X and Y are conformable if the length of the last axis of X is the same as the length of the first axis of Y.  A scalar or 1-element vector is extended to a vector of the required length.  If the last axis of X or the first axis of Y has a length of 1, the array is extended along that axis to conform with the other argument.<br/>The shape of R is the catenation of the shape of X less the last dimension with the shape of Y less the first dimension.  That is:<br/>For vector arguments, each element of X defines the ratio between the units for corresponding pairs of elements in Y.  The first element of X has no effect on the result.<br/>This function is also known as Base Value.<br/>If X is a scalar and Y a vector of length n, decode evaluates the polynomial(Index origin 1):<br/>For higher-rank array arguments, each of the vectors along the last axis of X is taken as the radix vector for each of the vectors along the first axis of Y.<br/>Scalar extension may be applied:<br/>Extension along a unit axis may be applied:",Decode
⊥,Up Tack<br/>Dyadic: Decode
Down Tack,⊤
Dyadic: Encode,⊤
"Y must be a simple numeric array.  X must be a simple numeric array.  R is the numeric array which results from the representation of Y in the number system defined by X.<br/>The shape of R is (⍴X),⍴Y (the catenation of the shapes of X and Y).<br/>If X is a vector or a scalar, the result for each element of Y is the value of the element expressed in the number system defined by radix X.  If Y is greater than can be expressed in the number system, the result is equal to the representation of the residue (×/X)|Y.  If the first element of X is 0, the value will be fully represented.<br/>This function is also known as Representation.<br/>If X is a higher-rank array, each of the vectors along the first axis of X is used as the radix vector for each element of Y.<br/>This example shows binary, octal and hexadecimal representations of the decimal number 75.<br/>⎕IO is not an implicit argument of encode.",⊤
⊤,"Y must be a simple numeric array.  X must be a simple numeric array.  R is the numeric array which results from the representation of Y in the number system defined by X.<br/>The shape of R is (⍴X),⍴Y (the catenation of the shapes of X and Y).<br/>If X is a vector or a scalar, the result for each element of Y is the value of the element expressed in the number system defined by radix X.  If Y is greater than can be expressed in the number system, the result is equal to the representation of the residue (×/X)|Y.  If the first element of X is 0, the value will be fully represented.<br/>This function is also known as Representation.<br/>If X is a higher-rank array, each of the vectors along the first axis of X is used as the radix vector for each element of Y.<br/>This example shows binary, octal and hexadecimal representations of the decimal number 75.<br/>⎕IO is not an implicit argument of encode."
Encode,"Y must be a simple numeric array.  X must be a simple numeric array.  R is the numeric array which results from the representation of Y in the number system defined by X.<br/>The shape of R is (⍴X),⍴Y (the catenation of the shapes of X and Y).<br/>If X is a vector or a scalar, the result for each element of Y is the value of the element expressed in the number system defined by radix X.  If Y is greater than can be expressed in the number system, the result is equal to the representation of the residue (×/X)|Y.  If the first element of X is 0, the value will be fully represented.<br/>This function is also known as Representation.<br/>If X is a higher-rank array, each of the vectors along the first axis of X is used as the radix vector for each element of Y.<br/>This example shows binary, octal and hexadecimal representations of the decimal number 75.<br/>⎕IO is not an implicit argument of encode."
"Y must be a simple numeric array.  X must be a simple numeric array.  R is the numeric array which results from the representation of Y in the number system defined by X.<br/>The shape of R is (⍴X),⍴Y (the catenation of the shapes of X and Y).<br/>If X is a vector or a scalar, the result for each element of Y is the value of the element expressed in the number system defined by radix X.  If Y is greater than can be expressed in the number system, the result is equal to the representation of the residue (×/X)|Y.  If the first element of X is 0, the value will be fully represented.<br/>This function is also known as Representation.<br/>If X is a higher-rank array, each of the vectors along the first axis of X is used as the radix vector for each element of Y.<br/>This example shows binary, octal and hexadecimal representations of the decimal number 75.<br/>⎕IO is not an implicit argument of encode.",Encode
⊤,Down Tack<br/>Dyadic: Encode
Left Tack,⊣
Monadic: Same,⊣
Y may be any array.<br/>The result R is the argument Y.,⊣
⊣,Y may be any array.<br/>The result R is the argument Y.
Same,Y may be any array.<br/>The result R is the argument Y.
Y may be any array.<br/>The result R is the argument Y.,Same
Dyadic: Left,⊣
"X and Y may be any arrays.<br/>The result R is the left argument X.<br/>Note that when ⊣ is applied using reduction, the derived function selects the first sub-array of the array along the specified dimension. This is implemented as an idiom.  <br/>Similarly, with expansion:",⊣
⊣,"X and Y may be any arrays.<br/>The result R is the left argument X.<br/>Note that when ⊣ is applied using reduction, the derived function selects the first sub-array of the array along the specified dimension. This is implemented as an idiom.  <br/>Similarly, with expansion:"
Left,"X and Y may be any arrays.<br/>The result R is the left argument X.<br/>Note that when ⊣ is applied using reduction, the derived function selects the first sub-array of the array along the specified dimension. This is implemented as an idiom.  <br/>Similarly, with expansion:"
"X and Y may be any arrays.<br/>The result R is the left argument X.<br/>Note that when ⊣ is applied using reduction, the derived function selects the first sub-array of the array along the specified dimension. This is implemented as an idiom.  <br/>Similarly, with expansion:",Left
⊣,Left Tack<br/>Monadic: Same<br/>Dyadic: Left
Right Tack,⊢
Monadic: Same,⊢
Y may be any array.<br/>The result R is the argument Y.,⊢
⊢,Y may be any array.<br/>The result R is the argument Y.
Same,Y may be any array.<br/>The result R is the argument Y.
Y may be any array.<br/>The result R is the argument Y.,Same
Dyadic: Right,⊢
"X and Y may be any arrays. The result R is the right argument Y.<br/>When ⊢ is applied using reduction, the derived function selects the last sub-array of the array along the specified dimension. This is implemented as an idiom.  ",⊢
⊢,"X and Y may be any arrays. The result R is the right argument Y.<br/>When ⊢ is applied using reduction, the derived function selects the last sub-array of the array along the specified dimension. This is implemented as an idiom.  "
Right,"X and Y may be any arrays. The result R is the right argument Y.<br/>When ⊢ is applied using reduction, the derived function selects the last sub-array of the array along the specified dimension. This is implemented as an idiom.  "
"X and Y may be any arrays. The result R is the right argument Y.<br/>When ⊢ is applied using reduction, the derived function selects the last sub-array of the array along the specified dimension. This is implemented as an idiom.  ",Right
⊢,Right Tack<br/>Monadic: Same<br/>Dyadic: Right
Domino;Quad Divide,⌹
Monadic: Matrix Inverse Of,⌹
"Y must be a simple array of rank 2 or less.  Y must be non-singular.  If Y is a scalar, it is treated as a one-element matrix.  If Y is a vector, it is treated as a single-column matrix.  Y must have at least the same number of rows as columns.<br/>R is the inverse of Y if Y is a square matrix, or the left inverse of Y if Y is not a square matrix.  That is, R+.×Y is an identity matrix.<br/>The shape of R is ⌽⍴Y.<br/>Within calculation accuracy, A+.×M is the identity matrix.",⌹
⌹,"Y must be a simple array of rank 2 or less.  Y must be non-singular.  If Y is a scalar, it is treated as a one-element matrix.  If Y is a vector, it is treated as a single-column matrix.  Y must have at least the same number of rows as columns.<br/>R is the inverse of Y if Y is a square matrix, or the left inverse of Y if Y is not a square matrix.  That is, R+.×Y is an identity matrix.<br/>The shape of R is ⌽⍴Y.<br/>Within calculation accuracy, A+.×M is the identity matrix."
MatrixInverse,⌹
MatrixInverse,"Y must be a simple array of rank 2 or less.  Y must be non-singular.  If Y is a scalar, it is treated as a one-element matrix.  If Y is a vector, it is treated as a single-column matrix.  Y must have at least the same number of rows as columns.<br/>R is the inverse of Y if Y is a square matrix, or the left inverse of Y if Y is not a square matrix.  That is, R+.×Y is an identity matrix.<br/>The shape of R is ⌽⍴Y.<br/>Within calculation accuracy, A+.×M is the identity matrix."
"Y must be a simple array of rank 2 or less.  Y must be non-singular.  If Y is a scalar, it is treated as a one-element matrix.  If Y is a vector, it is treated as a single-column matrix.  Y must have at least the same number of rows as columns.<br/>R is the inverse of Y if Y is a square matrix, or the left inverse of Y if Y is not a square matrix.  That is, R+.×Y is an identity matrix.<br/>The shape of R is ⌽⍴Y.<br/>Within calculation accuracy, A+.×M is the identity matrix.",MatrixInverse
Dyadic: Matrix Division By,⌹
"Y must be a simple numeric array of rank 2 or less.  X must be a simple numeric array of rank 2 or less.  Y must be non-singular.  A scalar argument is treated as a matrix with one-element.  If Y is a vector, it is treated as a single column matrix.  If X is a vector, it is treated as a single column matrix.  The number of rows in X and Y must be the same.  Y must have at least the same number of rows as columns.<br/>R is the result of matrix division of X by Y.  That is, the matrix product Y+.×R is X.  <br/>R is determined such that (X-Y+.×R)*2 is minimised. <br/>The shape of R is (1↓⍴Y),1↓⍴X.<br/>If there are more rows than columns in the right argument, the least squares solution results.  In the following example, the constants a and b which provide the best fit for the set of equations represented by P = a + bQ are determined:<br/>(Use +⍉ instead of ⍉ for complex y.) <br/>This equivalence, familiar to mathematicians and statisticians, explains",⌹
⌹,"Y must be a simple numeric array of rank 2 or less.  X must be a simple numeric array of rank 2 or less.  Y must be non-singular.  A scalar argument is treated as a matrix with one-element.  If Y is a vector, it is treated as a single column matrix.  If X is a vector, it is treated as a single column matrix.  The number of rows in X and Y must be the same.  Y must have at least the same number of rows as columns.<br/>R is the result of matrix division of X by Y.  That is, the matrix product Y+.×R is X.  <br/>R is determined such that (X-Y+.×R)*2 is minimised. <br/>The shape of R is (1↓⍴Y),1↓⍴X.<br/>If there are more rows than columns in the right argument, the least squares solution results.  In the following example, the constants a and b which provide the best fit for the set of equations represented by P = a + bQ are determined:<br/>(Use +⍉ instead of ⍉ for complex y.) <br/>This equivalence, familiar to mathematicians and statisticians, explains"
MatrixDivide,⌹
MatrixDivide,"Y must be a simple numeric array of rank 2 or less.  X must be a simple numeric array of rank 2 or less.  Y must be non-singular.  A scalar argument is treated as a matrix with one-element.  If Y is a vector, it is treated as a single column matrix.  If X is a vector, it is treated as a single column matrix.  The number of rows in X and Y must be the same.  Y must have at least the same number of rows as columns.<br/>R is the result of matrix division of X by Y.  That is, the matrix product Y+.×R is X.  <br/>R is determined such that (X-Y+.×R)*2 is minimised. <br/>The shape of R is (1↓⍴Y),1↓⍴X.<br/>If there are more rows than columns in the right argument, the least squares solution results.  In the following example, the constants a and b which provide the best fit for the set of equations represented by P = a + bQ are determined:<br/>(Use +⍉ instead of ⍉ for complex y.) <br/>This equivalence, familiar to mathematicians and statisticians, explains"
"Y must be a simple numeric array of rank 2 or less.  X must be a simple numeric array of rank 2 or less.  Y must be non-singular.  A scalar argument is treated as a matrix with one-element.  If Y is a vector, it is treated as a single column matrix.  If X is a vector, it is treated as a single column matrix.  The number of rows in X and Y must be the same.  Y must have at least the same number of rows as columns.<br/>R is the result of matrix division of X by Y.  That is, the matrix product Y+.×R is X.  <br/>R is determined such that (X-Y+.×R)*2 is minimised. <br/>The shape of R is (1↓⍴Y),1↓⍴X.<br/>If there are more rows than columns in the right argument, the least squares solution results.  In the following example, the constants a and b which provide the best fit for the set of equations represented by P = a + bQ are determined:<br/>(Use +⍉ instead of ⍉ for complex y.) <br/>This equivalence, familiar to mathematicians and statisticians, explains",MatrixDivide
⌹,Domino;Quad Divide<br/>Monadic: Matrix Inverse Of<br/>Dyadic: Matrix Division By
Zilde;,⍬
: Zilde,⍬
The empty vector (⍳0) may be represented by the numeric constant ⍬ called ZILDE.,⍬
⍬,The empty vector (⍳0) may be represented by the numeric constant ⍬ called ZILDE.
Zilde,The empty vector (⍳0) may be represented by the numeric constant ⍬ called ZILDE.
The empty vector (⍳0) may be represented by the numeric constant ⍬ called ZILDE.,Zilde
⍬,Zilde;<br/>: Zilde
Right Arrow,→
Monadic: Branch,→
"Y may be a scalar or vector which, if not empty, has a simple numeric scalar as its first element.  The function has no explicit result.  It is used to modify the normal sequence of execution of expressions or to resume execution after a statement has been interrupted. Branch is not in the function domain of operators.<br/>The following distinct usages of the branch function occur:<br/>In a defined function, if Y is non-empty then the first element in Y specifies a statement line in the defined function to be executed next.  If the line does not exist, then execution of the function is terminated.  For this purpose, line 0 does not exist.  (Note that statement line numbers are independent of the index origin ⎕IO).<br/>If Y is empty, the branch function has no effect.  The next expression is executed on the same line, if any, or on the next line if not.  If there is no following line, the function is terminated.<br/>The :GoTo statement may be used in place of Branch in a defined function.<br/>In general it is better to branch to a LABEL than to a line number.  A label occurs in a statement followed by a colon and is assigned the value of the statement line number when the function is defined.<br/>The previous examples illustrate unconditional branching. There are numerous APL idioms which result in conditional branching. Some popular idioms are identified in the following table:<br/>A branch expression may occur within a statement including ⋄ separators:<br/>In this example, the expressions 'A←A+1' and '→END' are executed only if TEST returns the value 1.  Otherwise control branches to label NEXT.<br/>In immediate execution mode, the branch function permits execution to be continued within the most recently suspended function, if any, in the state indicator.  If the state indicator is empty, or if the argument Y is the empty vector, the branch expression has no effect.  If a statement line is specified which does not exist, the function is terminated.  Otherwise, execution is restarted from the beginning of the specified statement line in the most recently suspended function.<br/>The system constant ⎕LC returns a vector of the line numbers of statement lines in the state indicator, starting with that in the most recently suspended function.  It is convenient to restart execution in a suspended state by the expression:",→
→,"Y may be a scalar or vector which, if not empty, has a simple numeric scalar as its first element.  The function has no explicit result.  It is used to modify the normal sequence of execution of expressions or to resume execution after a statement has been interrupted. Branch is not in the function domain of operators.<br/>The following distinct usages of the branch function occur:<br/>In a defined function, if Y is non-empty then the first element in Y specifies a statement line in the defined function to be executed next.  If the line does not exist, then execution of the function is terminated.  For this purpose, line 0 does not exist.  (Note that statement line numbers are independent of the index origin ⎕IO).<br/>If Y is empty, the branch function has no effect.  The next expression is executed on the same line, if any, or on the next line if not.  If there is no following line, the function is terminated.<br/>The :GoTo statement may be used in place of Branch in a defined function.<br/>In general it is better to branch to a LABEL than to a line number.  A label occurs in a statement followed by a colon and is assigned the value of the statement line number when the function is defined.<br/>The previous examples illustrate unconditional branching. There are numerous APL idioms which result in conditional branching. Some popular idioms are identified in the following table:<br/>A branch expression may occur within a statement including ⋄ separators:<br/>In this example, the expressions 'A←A+1' and '→END' are executed only if TEST returns the value 1.  Otherwise control branches to label NEXT.<br/>In immediate execution mode, the branch function permits execution to be continued within the most recently suspended function, if any, in the state indicator.  If the state indicator is empty, or if the argument Y is the empty vector, the branch expression has no effect.  If a statement line is specified which does not exist, the function is terminated.  Otherwise, execution is restarted from the beginning of the specified statement line in the most recently suspended function.<br/>The system constant ⎕LC returns a vector of the line numbers of statement lines in the state indicator, starting with that in the most recently suspended function.  It is convenient to restart execution in a suspended state by the expression:"
Branch,"Y may be a scalar or vector which, if not empty, has a simple numeric scalar as its first element.  The function has no explicit result.  It is used to modify the normal sequence of execution of expressions or to resume execution after a statement has been interrupted. Branch is not in the function domain of operators.<br/>The following distinct usages of the branch function occur:<br/>In a defined function, if Y is non-empty then the first element in Y specifies a statement line in the defined function to be executed next.  If the line does not exist, then execution of the function is terminated.  For this purpose, line 0 does not exist.  (Note that statement line numbers are independent of the index origin ⎕IO).<br/>If Y is empty, the branch function has no effect.  The next expression is executed on the same line, if any, or on the next line if not.  If there is no following line, the function is terminated.<br/>The :GoTo statement may be used in place of Branch in a defined function.<br/>In general it is better to branch to a LABEL than to a line number.  A label occurs in a statement followed by a colon and is assigned the value of the statement line number when the function is defined.<br/>The previous examples illustrate unconditional branching. There are numerous APL idioms which result in conditional branching. Some popular idioms are identified in the following table:<br/>A branch expression may occur within a statement including ⋄ separators:<br/>In this example, the expressions 'A←A+1' and '→END' are executed only if TEST returns the value 1.  Otherwise control branches to label NEXT.<br/>In immediate execution mode, the branch function permits execution to be continued within the most recently suspended function, if any, in the state indicator.  If the state indicator is empty, or if the argument Y is the empty vector, the branch expression has no effect.  If a statement line is specified which does not exist, the function is terminated.  Otherwise, execution is restarted from the beginning of the specified statement line in the most recently suspended function.<br/>The system constant ⎕LC returns a vector of the line numbers of statement lines in the state indicator, starting with that in the most recently suspended function.  It is convenient to restart execution in a suspended state by the expression:"
"Y may be a scalar or vector which, if not empty, has a simple numeric scalar as its first element.  The function has no explicit result.  It is used to modify the normal sequence of execution of expressions or to resume execution after a statement has been interrupted. Branch is not in the function domain of operators.<br/>The following distinct usages of the branch function occur:<br/>In a defined function, if Y is non-empty then the first element in Y specifies a statement line in the defined function to be executed next.  If the line does not exist, then execution of the function is terminated.  For this purpose, line 0 does not exist.  (Note that statement line numbers are independent of the index origin ⎕IO).<br/>If Y is empty, the branch function has no effect.  The next expression is executed on the same line, if any, or on the next line if not.  If there is no following line, the function is terminated.<br/>The :GoTo statement may be used in place of Branch in a defined function.<br/>In general it is better to branch to a LABEL than to a line number.  A label occurs in a statement followed by a colon and is assigned the value of the statement line number when the function is defined.<br/>The previous examples illustrate unconditional branching. There are numerous APL idioms which result in conditional branching. Some popular idioms are identified in the following table:<br/>A branch expression may occur within a statement including ⋄ separators:<br/>In this example, the expressions 'A←A+1' and '→END' are executed only if TEST returns the value 1.  Otherwise control branches to label NEXT.<br/>In immediate execution mode, the branch function permits execution to be continued within the most recently suspended function, if any, in the state indicator.  If the state indicator is empty, or if the argument Y is the empty vector, the branch expression has no effect.  If a statement line is specified which does not exist, the function is terminated.  Otherwise, execution is restarted from the beginning of the specified statement line in the most recently suspended function.<br/>The system constant ⎕LC returns a vector of the line numbers of statement lines in the state indicator, starting with that in the most recently suspended function.  It is convenient to restart execution in a suspended state by the expression:",Branch
→,Right Arrow<br/>Monadic: Branch
Left Arrow,←
Dyadic: Naming,←
"Assignment  allocates the result of the expression Y to the name or names in X.<br/>If Y is an array expression, X must contain one or more names which are variables, system variables, or are undefined. Following assignment, the name(s) in X become variable(s) with value(s) taken from the result of the expression Y.<br/>If X contains a single name, the variable assumes the value of Y. If X contains multiple names then Y can be a single-item array of any rank (including a scalar) or  a vector. If Y is a single-item array, the scalar value ⊃Y is assigned to all names in X. Otherwise, each element of Y is assigned to the corresponding name in X.  Although not mandatory, Dyalog recommends that the names in X are enclosed in parentheses to reduce potential ambiguity in assignment statements.<br/>The assignment arrow (or specification arrow) is often read as 'Is' or 'Gets'.<br/>Implementation note: erroneous expressions such as var 3←5 will result in 5 being assigned to var, even though a SYNTAX ERROR will be generated. In the case of (var 3)←5 no assignment will be made.<br/> Pass-through assignments are permitted. The value of Y is carried through each assignment:<br/>If Y is a function expression, X must be a single name which is either undefined, or is the name of an existing function or defined operator. X may not be the name of a system function, or a primitive symbol.<br/>If an expression evaluates to a namespace reference, or ref, you may assign it to a name. A name assigned to a simple scalar ref, has name class 9, whereas one assigned to an array containing refs has name class 2.<br/>A name that already exists may be assigned a new value if the assignment will not alter its name class, or will change it from 2 to 9 or vice versa. The table of permitted re-assignments is as follows:",←
←,"Assignment  allocates the result of the expression Y to the name or names in X.<br/>If Y is an array expression, X must contain one or more names which are variables, system variables, or are undefined. Following assignment, the name(s) in X become variable(s) with value(s) taken from the result of the expression Y.<br/>If X contains a single name, the variable assumes the value of Y. If X contains multiple names then Y can be a single-item array of any rank (including a scalar) or  a vector. If Y is a single-item array, the scalar value ⊃Y is assigned to all names in X. Otherwise, each element of Y is assigned to the corresponding name in X.  Although not mandatory, Dyalog recommends that the names in X are enclosed in parentheses to reduce potential ambiguity in assignment statements.<br/>The assignment arrow (or specification arrow) is often read as 'Is' or 'Gets'.<br/>Implementation note: erroneous expressions such as var 3←5 will result in 5 being assigned to var, even though a SYNTAX ERROR will be generated. In the case of (var 3)←5 no assignment will be made.<br/> Pass-through assignments are permitted. The value of Y is carried through each assignment:<br/>If Y is a function expression, X must be a single name which is either undefined, or is the name of an existing function or defined operator. X may not be the name of a system function, or a primitive symbol.<br/>If an expression evaluates to a namespace reference, or ref, you may assign it to a name. A name assigned to a simple scalar ref, has name class 9, whereas one assigned to an array containing refs has name class 2.<br/>A name that already exists may be assigned a new value if the assignment will not alter its name class, or will change it from 2 to 9 or vice versa. The table of permitted re-assignments is as follows:"
Assignment,←
Assignment,"Assignment  allocates the result of the expression Y to the name or names in X.<br/>If Y is an array expression, X must contain one or more names which are variables, system variables, or are undefined. Following assignment, the name(s) in X become variable(s) with value(s) taken from the result of the expression Y.<br/>If X contains a single name, the variable assumes the value of Y. If X contains multiple names then Y can be a single-item array of any rank (including a scalar) or  a vector. If Y is a single-item array, the scalar value ⊃Y is assigned to all names in X. Otherwise, each element of Y is assigned to the corresponding name in X.  Although not mandatory, Dyalog recommends that the names in X are enclosed in parentheses to reduce potential ambiguity in assignment statements.<br/>The assignment arrow (or specification arrow) is often read as 'Is' or 'Gets'.<br/>Implementation note: erroneous expressions such as var 3←5 will result in 5 being assigned to var, even though a SYNTAX ERROR will be generated. In the case of (var 3)←5 no assignment will be made.<br/> Pass-through assignments are permitted. The value of Y is carried through each assignment:<br/>If Y is a function expression, X must be a single name which is either undefined, or is the name of an existing function or defined operator. X may not be the name of a system function, or a primitive symbol.<br/>If an expression evaluates to a namespace reference, or ref, you may assign it to a name. A name assigned to a simple scalar ref, has name class 9, whereas one assigned to an array containing refs has name class 2.<br/>A name that already exists may be assigned a new value if the assignment will not alter its name class, or will change it from 2 to 9 or vice versa. The table of permitted re-assignments is as follows:"
"Assignment  allocates the result of the expression Y to the name or names in X.<br/>If Y is an array expression, X must contain one or more names which are variables, system variables, or are undefined. Following assignment, the name(s) in X become variable(s) with value(s) taken from the result of the expression Y.<br/>If X contains a single name, the variable assumes the value of Y. If X contains multiple names then Y can be a single-item array of any rank (including a scalar) or  a vector. If Y is a single-item array, the scalar value ⊃Y is assigned to all names in X. Otherwise, each element of Y is assigned to the corresponding name in X.  Although not mandatory, Dyalog recommends that the names in X are enclosed in parentheses to reduce potential ambiguity in assignment statements.<br/>The assignment arrow (or specification arrow) is often read as 'Is' or 'Gets'.<br/>Implementation note: erroneous expressions such as var 3←5 will result in 5 being assigned to var, even though a SYNTAX ERROR will be generated. In the case of (var 3)←5 no assignment will be made.<br/> Pass-through assignments are permitted. The value of Y is carried through each assignment:<br/>If Y is a function expression, X must be a single name which is either undefined, or is the name of an existing function or defined operator. X may not be the name of a system function, or a primitive symbol.<br/>If an expression evaluates to a namespace reference, or ref, you may assign it to a name. A name assigned to a simple scalar ref, has name class 9, whereas one assigned to an array containing refs has name class 2.<br/>A name that already exists may be assigned a new value if the assignment will not alter its name class, or will change it from 2 to 9 or vice versa. The table of permitted re-assignments is as follows:",Assignment
: Modified Assignment,←
"Assignment  allocates the result of the expression Y to the name or names in X.<br/>If Y is an array expression, X must contain one or more names which are variables, system variables, or are undefined. Following assignment, the name(s) in X become variable(s) with value(s) taken from the result of the expression Y.<br/>If X contains a single name, the variable assumes the value of Y. If X contains multiple names then Y can be a single-item array of any rank (including a scalar) or  a vector. If Y is a single-item array, the scalar value ⊃Y is assigned to all names in X. Otherwise, each element of Y is assigned to the corresponding name in X.  Although not mandatory, Dyalog recommends that the names in X are enclosed in parentheses to reduce potential ambiguity in assignment statements.<br/>The assignment arrow (or specification arrow) is often read as 'Is' or 'Gets'.<br/>Implementation note: erroneous expressions such as var 3←5 will result in 5 being assigned to var, even though a SYNTAX ERROR will be generated. In the case of (var 3)←5 no assignment will be made.<br/> Pass-through assignments are permitted. The value of Y is carried through each assignment:<br/>If Y is a function expression, X must be a single name which is either undefined, or is the name of an existing function or defined operator. X may not be the name of a system function, or a primitive symbol.<br/>If an expression evaluates to a namespace reference, or ref, you may assign it to a name. A name assigned to a simple scalar ref, has name class 9, whereas one assigned to an array containing refs has name class 2.<br/>A name that already exists may be assigned a new value if the assignment will not alter its name class, or will change it from 2 to 9 or vice versa. The table of permitted re-assignments is as follows:",←
←,"Assignment  allocates the result of the expression Y to the name or names in X.<br/>If Y is an array expression, X must contain one or more names which are variables, system variables, or are undefined. Following assignment, the name(s) in X become variable(s) with value(s) taken from the result of the expression Y.<br/>If X contains a single name, the variable assumes the value of Y. If X contains multiple names then Y can be a single-item array of any rank (including a scalar) or  a vector. If Y is a single-item array, the scalar value ⊃Y is assigned to all names in X. Otherwise, each element of Y is assigned to the corresponding name in X.  Although not mandatory, Dyalog recommends that the names in X are enclosed in parentheses to reduce potential ambiguity in assignment statements.<br/>The assignment arrow (or specification arrow) is often read as 'Is' or 'Gets'.<br/>Implementation note: erroneous expressions such as var 3←5 will result in 5 being assigned to var, even though a SYNTAX ERROR will be generated. In the case of (var 3)←5 no assignment will be made.<br/> Pass-through assignments are permitted. The value of Y is carried through each assignment:<br/>If Y is a function expression, X must be a single name which is either undefined, or is the name of an existing function or defined operator. X may not be the name of a system function, or a primitive symbol.<br/>If an expression evaluates to a namespace reference, or ref, you may assign it to a name. A name assigned to a simple scalar ref, has name class 9, whereas one assigned to an array containing refs has name class 2.<br/>A name that already exists may be assigned a new value if the assignment will not alter its name class, or will change it from 2 to 9 or vice versa. The table of permitted re-assignments is as follows:"
Assignment,"Assignment  allocates the result of the expression Y to the name or names in X.<br/>If Y is an array expression, X must contain one or more names which are variables, system variables, or are undefined. Following assignment, the name(s) in X become variable(s) with value(s) taken from the result of the expression Y.<br/>If X contains a single name, the variable assumes the value of Y. If X contains multiple names then Y can be a single-item array of any rank (including a scalar) or  a vector. If Y is a single-item array, the scalar value ⊃Y is assigned to all names in X. Otherwise, each element of Y is assigned to the corresponding name in X.  Although not mandatory, Dyalog recommends that the names in X are enclosed in parentheses to reduce potential ambiguity in assignment statements.<br/>The assignment arrow (or specification arrow) is often read as 'Is' or 'Gets'.<br/>Implementation note: erroneous expressions such as var 3←5 will result in 5 being assigned to var, even though a SYNTAX ERROR will be generated. In the case of (var 3)←5 no assignment will be made.<br/> Pass-through assignments are permitted. The value of Y is carried through each assignment:<br/>If Y is a function expression, X must be a single name which is either undefined, or is the name of an existing function or defined operator. X may not be the name of a system function, or a primitive symbol.<br/>If an expression evaluates to a namespace reference, or ref, you may assign it to a name. A name assigned to a simple scalar ref, has name class 9, whereas one assigned to an array containing refs has name class 2.<br/>A name that already exists may be assigned a new value if the assignment will not alter its name class, or will change it from 2 to 9 or vice versa. The table of permitted re-assignments is as follows:"
"Assignment  allocates the result of the expression Y to the name or names in X.<br/>If Y is an array expression, X must contain one or more names which are variables, system variables, or are undefined. Following assignment, the name(s) in X become variable(s) with value(s) taken from the result of the expression Y.<br/>If X contains a single name, the variable assumes the value of Y. If X contains multiple names then Y can be a single-item array of any rank (including a scalar) or  a vector. If Y is a single-item array, the scalar value ⊃Y is assigned to all names in X. Otherwise, each element of Y is assigned to the corresponding name in X.  Although not mandatory, Dyalog recommends that the names in X are enclosed in parentheses to reduce potential ambiguity in assignment statements.<br/>The assignment arrow (or specification arrow) is often read as 'Is' or 'Gets'.<br/>Implementation note: erroneous expressions such as var 3←5 will result in 5 being assigned to var, even though a SYNTAX ERROR will be generated. In the case of (var 3)←5 no assignment will be made.<br/> Pass-through assignments are permitted. The value of Y is carried through each assignment:<br/>If Y is a function expression, X must be a single name which is either undefined, or is the name of an existing function or defined operator. X may not be the name of a system function, or a primitive symbol.<br/>If an expression evaluates to a namespace reference, or ref, you may assign it to a name. A name assigned to a simple scalar ref, has name class 9, whereas one assigned to an array containing refs has name class 2.<br/>A name that already exists may be assigned a new value if the assignment will not alter its name class, or will change it from 2 to 9 or vice versa. The table of permitted re-assignments is as follows:",Assignment
←,Left Arrow<br/>Dyadic: Naming<br/>: Modified Assignment
Diaeresis,¨
Monadic: Each (with monadic operand) or Each (with dyadic operand),¨
"f may be any monadic function.  Y may be any array, each of whose items are separately appropriate to function f.<br/>The derived function applies function f separately to each item of Y.  The derived function need not return a result.  If a result is returned, R has the same shape as Y, and its elements are the items produced by the application of function f to the corresponding items of Y.<br/>If Y is empty, the prototype of R is determined by applying the operand function once to the prototype of Y.",¨
¨,"f may be any monadic function.  Y may be any array, each of whose items are separately appropriate to function f.<br/>The derived function applies function f separately to each item of Y.  The derived function need not return a result.  If a result is returned, R has the same shape as Y, and its elements are the items produced by the application of function f to the corresponding items of Y.<br/>If Y is empty, the prototype of R is determined by applying the operand function once to the prototype of Y."
Each(withMonadicOperand),¨
Each(withMonadicOperand),"f may be any monadic function.  Y may be any array, each of whose items are separately appropriate to function f.<br/>The derived function applies function f separately to each item of Y.  The derived function need not return a result.  If a result is returned, R has the same shape as Y, and its elements are the items produced by the application of function f to the corresponding items of Y.<br/>If Y is empty, the prototype of R is determined by applying the operand function once to the prototype of Y."
"f may be any monadic function.  Y may be any array, each of whose items are separately appropriate to function f.<br/>The derived function applies function f separately to each item of Y.  The derived function need not return a result.  If a result is returned, R has the same shape as Y, and its elements are the items produced by the application of function f to the corresponding items of Y.<br/>If Y is empty, the prototype of R is determined by applying the operand function once to the prototype of Y.",Each(withMonadicOperand)
: Each (with monadic operand) or Each (with dyadic operand),¨
"f may be any monadic function.  Y may be any array, each of whose items are separately appropriate to function f.<br/>The derived function applies function f separately to each item of Y.  The derived function need not return a result.  If a result is returned, R has the same shape as Y, and its elements are the items produced by the application of function f to the corresponding items of Y.<br/>If Y is empty, the prototype of R is determined by applying the operand function once to the prototype of Y.",¨
¨,"f may be any monadic function.  Y may be any array, each of whose items are separately appropriate to function f.<br/>The derived function applies function f separately to each item of Y.  The derived function need not return a result.  If a result is returned, R has the same shape as Y, and its elements are the items produced by the application of function f to the corresponding items of Y.<br/>If Y is empty, the prototype of R is determined by applying the operand function once to the prototype of Y."
Each(withMonadicOperand),¨
Each(withMonadicOperand),"f may be any monadic function.  Y may be any array, each of whose items are separately appropriate to function f.<br/>The derived function applies function f separately to each item of Y.  The derived function need not return a result.  If a result is returned, R has the same shape as Y, and its elements are the items produced by the application of function f to the corresponding items of Y.<br/>If Y is empty, the prototype of R is determined by applying the operand function once to the prototype of Y."
"f may be any monadic function.  Y may be any array, each of whose items are separately appropriate to function f.<br/>The derived function applies function f separately to each item of Y.  The derived function need not return a result.  If a result is returned, R has the same shape as Y, and its elements are the items produced by the application of function f to the corresponding items of Y.<br/>If Y is empty, the prototype of R is determined by applying the operand function once to the prototype of Y.",Each(withMonadicOperand)
¨,Diaeresis<br/>Monadic: Each (with monadic operand) or Each (with dyadic operand)<br/>: Each (with monadic operand) or Each (with dyadic operand)
Tilde Diaeresis,⍨
MonadicDyadic: Commute,⍨
"f may be any dyadic function.  X and Y may be any arrays whose items are appropriate to function f.<br/>The derived function is equivalent to YfX.  The derived function need not return a result.<br/>If left argument X is omitted, the right argument Y is duplicated in its place, i.e.<br/>The following statements are equivalent:<br/>Commute often eliminates the need for parentheses",⍨
⍨,"f may be any dyadic function.  X and Y may be any arrays whose items are appropriate to function f.<br/>The derived function is equivalent to YfX.  The derived function need not return a result.<br/>If left argument X is omitted, the right argument Y is duplicated in its place, i.e.<br/>The following statements are equivalent:<br/>Commute often eliminates the need for parentheses"
Commute,"f may be any dyadic function.  X and Y may be any arrays whose items are appropriate to function f.<br/>The derived function is equivalent to YfX.  The derived function need not return a result.<br/>If left argument X is omitted, the right argument Y is duplicated in its place, i.e.<br/>The following statements are equivalent:<br/>Commute often eliminates the need for parentheses"
"f may be any dyadic function.  X and Y may be any arrays whose items are appropriate to function f.<br/>The derived function is equivalent to YfX.  The derived function need not return a result.<br/>If left argument X is omitted, the right argument Y is duplicated in its place, i.e.<br/>The following statements are equivalent:<br/>Commute often eliminates the need for parentheses",Commute
: Commute,⍨
"f may be any dyadic function.  X and Y may be any arrays whose items are appropriate to function f.<br/>The derived function is equivalent to YfX.  The derived function need not return a result.<br/>If left argument X is omitted, the right argument Y is duplicated in its place, i.e.<br/>The following statements are equivalent:<br/>Commute often eliminates the need for parentheses",⍨
⍨,"f may be any dyadic function.  X and Y may be any arrays whose items are appropriate to function f.<br/>The derived function is equivalent to YfX.  The derived function need not return a result.<br/>If left argument X is omitted, the right argument Y is duplicated in its place, i.e.<br/>The following statements are equivalent:<br/>Commute often eliminates the need for parentheses"
Commute,"f may be any dyadic function.  X and Y may be any arrays whose items are appropriate to function f.<br/>The derived function is equivalent to YfX.  The derived function need not return a result.<br/>If left argument X is omitted, the right argument Y is duplicated in its place, i.e.<br/>The following statements are equivalent:<br/>Commute often eliminates the need for parentheses"
"f may be any dyadic function.  X and Y may be any arrays whose items are appropriate to function f.<br/>The derived function is equivalent to YfX.  The derived function need not return a result.<br/>If left argument X is omitted, the right argument Y is duplicated in its place, i.e.<br/>The following statements are equivalent:<br/>Commute often eliminates the need for parentheses",Commute
⍨,Tilde Diaeresis<br/>MonadicDyadic: Commute<br/>: Commute
Jot,∘
Dyadic: Beside or Bind,∘
"g can be any monadic function which returns a result.  Y can be any array appropriate to function g with gY being suitable as the right argument to function f.<br/>If X is omitted, f must be a monadic function. If X is specified, f must be a dyadic function and X can be any array that is suitable as the left argument to function f.<br/>The derived function is equivalent to fgY or XfgY and need not return a result.<br/>The Beside operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition.",∘
∘,"g can be any monadic function which returns a result.  Y can be any array appropriate to function g with gY being suitable as the right argument to function f.<br/>If X is omitted, f must be a monadic function. If X is specified, f must be a dyadic function and X can be any array that is suitable as the left argument to function f.<br/>The derived function is equivalent to fgY or XfgY and need not return a result.<br/>The Beside operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition."
Beside,"g can be any monadic function which returns a result.  Y can be any array appropriate to function g with gY being suitable as the right argument to function f.<br/>If X is omitted, f must be a monadic function. If X is specified, f must be a dyadic function and X can be any array that is suitable as the left argument to function f.<br/>The derived function is equivalent to fgY or XfgY and need not return a result.<br/>The Beside operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition."
"g can be any monadic function which returns a result.  Y can be any array appropriate to function g with gY being suitable as the right argument to function f.<br/>If X is omitted, f must be a monadic function. If X is specified, f must be a dyadic function and X can be any array that is suitable as the left argument to function f.<br/>The derived function is equivalent to fgY or XfgY and need not return a result.<br/>The Beside operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition.",Beside
: Beside or Bind,∘
"g can be any monadic function which returns a result.  Y can be any array appropriate to function g with gY being suitable as the right argument to function f.<br/>If X is omitted, f must be a monadic function. If X is specified, f must be a dyadic function and X can be any array that is suitable as the left argument to function f.<br/>The derived function is equivalent to fgY or XfgY and need not return a result.<br/>The Beside operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition.",∘
∘,"g can be any monadic function which returns a result.  Y can be any array appropriate to function g with gY being suitable as the right argument to function f.<br/>If X is omitted, f must be a monadic function. If X is specified, f must be a dyadic function and X can be any array that is suitable as the left argument to function f.<br/>The derived function is equivalent to fgY or XfgY and need not return a result.<br/>The Beside operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition."
Beside,"g can be any monadic function which returns a result.  Y can be any array appropriate to function g with gY being suitable as the right argument to function f.<br/>If X is omitted, f must be a monadic function. If X is specified, f must be a dyadic function and X can be any array that is suitable as the left argument to function f.<br/>The derived function is equivalent to fgY or XfgY and need not return a result.<br/>The Beside operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition."
"g can be any monadic function which returns a result.  Y can be any array appropriate to function g with gY being suitable as the right argument to function f.<br/>If X is omitted, f must be a monadic function. If X is specified, f must be a dyadic function and X can be any array that is suitable as the left argument to function f.<br/>The derived function is equivalent to fgY or XfgY and need not return a result.<br/>The Beside operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition.",Beside
∘,Jot<br/>Dyadic: Beside or Bind<br/>: Beside or Bind
Dot,.
DyadicDyadic: Inner Product,.
"f and g are dyadic functions. The last axis of X must have the same length as the first axis of Y, or one of X and Y is single (^/1=⍴X or ^/1=⍴Y).<br/>The result of the derived function has shape (¯1↓⍴X),1↓⍴Y; each item is f/x g¨y where x and y are vectors taken from all the combinations of vectors along the last axis of X and the first axis of Y.",.
.,"f and g are dyadic functions. The last axis of X must have the same length as the first axis of Y, or one of X and Y is single (^/1=⍴X or ^/1=⍴Y).<br/>The result of the derived function has shape (¯1↓⍴X),1↓⍴Y; each item is f/x g¨y where x and y are vectors taken from all the combinations of vectors along the last axis of X and the first axis of Y."
InnerProduct,.
InnerProduct,"f and g are dyadic functions. The last axis of X must have the same length as the first axis of Y, or one of X and Y is single (^/1=⍴X or ^/1=⍴Y).<br/>The result of the derived function has shape (¯1↓⍴X),1↓⍴Y; each item is f/x g¨y where x and y are vectors taken from all the combinations of vectors along the last axis of X and the first axis of Y."
"f and g are dyadic functions. The last axis of X must have the same length as the first axis of Y, or one of X and Y is single (^/1=⍴X or ^/1=⍴Y).<br/>The result of the derived function has shape (¯1↓⍴X),1↓⍴Y; each item is f/x g¨y where x and y are vectors taken from all the combinations of vectors along the last axis of X and the first axis of Y.",InnerProduct
: Inner Product,.
"f and g are dyadic functions. The last axis of X must have the same length as the first axis of Y, or one of X and Y is single (^/1=⍴X or ^/1=⍴Y).<br/>The result of the derived function has shape (¯1↓⍴X),1↓⍴Y; each item is f/x g¨y where x and y are vectors taken from all the combinations of vectors along the last axis of X and the first axis of Y.",.
.,"f and g are dyadic functions. The last axis of X must have the same length as the first axis of Y, or one of X and Y is single (^/1=⍴X or ^/1=⍴Y).<br/>The result of the derived function has shape (¯1↓⍴X),1↓⍴Y; each item is f/x g¨y where x and y are vectors taken from all the combinations of vectors along the last axis of X and the first axis of Y."
InnerProduct,.
InnerProduct,"f and g are dyadic functions. The last axis of X must have the same length as the first axis of Y, or one of X and Y is single (^/1=⍴X or ^/1=⍴Y).<br/>The result of the derived function has shape (¯1↓⍴X),1↓⍴Y; each item is f/x g¨y where x and y are vectors taken from all the combinations of vectors along the last axis of X and the first axis of Y."
"f and g are dyadic functions. The last axis of X must have the same length as the first axis of Y, or one of X and Y is single (^/1=⍴X or ^/1=⍴Y).<br/>The result of the derived function has shape (¯1↓⍴X),1↓⍴Y; each item is f/x g¨y where x and y are vectors taken from all the combinations of vectors along the last axis of X and the first axis of Y.",InnerProduct
: Outer Product,.
"g may be any dyadic function.  The left operand of the operator is the symbol ∘.  X and Y may be any arrays whose elements are appropriate to the function g.<br/>Function g is applied to all combinations of the elements of X and Y.  If function g returns a result, the shape of R is (⍴X),⍴Y.  Each element of R is the item returned by function g when applied to the particular combination of elements of X and Y.<br/>If X or Y is empty, the result R is a conformable empty array, and the operand function is applied once between the first items of X and Y to determine the prototype of R.",.
.,"g may be any dyadic function.  The left operand of the operator is the symbol ∘.  X and Y may be any arrays whose elements are appropriate to the function g.<br/>Function g is applied to all combinations of the elements of X and Y.  If function g returns a result, the shape of R is (⍴X),⍴Y.  Each element of R is the item returned by function g when applied to the particular combination of elements of X and Y.<br/>If X or Y is empty, the result R is a conformable empty array, and the operand function is applied once between the first items of X and Y to determine the prototype of R."
OuterProduct,.
OuterProduct,"g may be any dyadic function.  The left operand of the operator is the symbol ∘.  X and Y may be any arrays whose elements are appropriate to the function g.<br/>Function g is applied to all combinations of the elements of X and Y.  If function g returns a result, the shape of R is (⍴X),⍴Y.  Each element of R is the item returned by function g when applied to the particular combination of elements of X and Y.<br/>If X or Y is empty, the result R is a conformable empty array, and the operand function is applied once between the first items of X and Y to determine the prototype of R."
"g may be any dyadic function.  The left operand of the operator is the symbol ∘.  X and Y may be any arrays whose elements are appropriate to the function g.<br/>Function g is applied to all combinations of the elements of X and Y.  If function g returns a result, the shape of R is (⍴X),⍴Y.  Each element of R is the item returned by function g when applied to the particular combination of elements of X and Y.<br/>If X or Y is empty, the result R is a conformable empty array, and the operand function is applied once between the first items of X and Y to determine the prototype of R.",OuterProduct
.,Dot<br/>DyadicDyadic: Inner Product<br/>: Inner Product<br/>: Outer Product
Star Diaeresis,⍣
Dyadic: Power Operator,⍣
"If right operand g is a numeric integer scalar, power applies its left operand function f cumulatively g times to its argument. In particular, g may be Boolean 0 or 1 for conditional function application.<br/>If right operand g is a scalar-returning dyadic function, then left operand function f is applied repeatedly until ((f Y) g Y) or until a strong interrupt occurs. Notice that power calls its dyadic right operand g with the next (f Y) and current (Y) values of the iteration as left and right arguments. In particular, if g is = or вүЎ, the result is sometimes termed a fixpoint of f.<br/>If a left argument X is present, it is bound as left argument to left operand function f:<br/>A negative right operand g applies the inverse of the operand function f, (|g)times. In this case, f may be a primitive function or an expression of primitive functions combined with primitive operators:<br/>If the function does not have an inverse, a negative argument g generates DOMAIN ERROR.<br/>Some expressions, such as the following, will cause an infinite internal loop and APL will appear to hang. In most cases this can be resolved by issuing a hard INTERRUPT.<br/>One can ensure that weak interrupts and вҺ•TKILL can interrupt by packaging the вҚЈ within the dop      {вҚәвҶҗвҠў вӢ„ вҚә (вҚәвҚә{вҚәвҶҗвҠў вӢ„ вҚә вҚәвҚә вҚө}вҚЈвҚөвҚө) вҚө}.",⍣
⍣,"If right operand g is a numeric integer scalar, power applies its left operand function f cumulatively g times to its argument. In particular, g may be Boolean 0 or 1 for conditional function application.<br/>If right operand g is a scalar-returning dyadic function, then left operand function f is applied repeatedly until ((f Y) g Y) or until a strong interrupt occurs. Notice that power calls its dyadic right operand g with the next (f Y) and current (Y) values of the iteration as left and right arguments. In particular, if g is = or вүЎ, the result is sometimes termed a fixpoint of f.<br/>If a left argument X is present, it is bound as left argument to left operand function f:<br/>A negative right operand g applies the inverse of the operand function f, (|g)times. In this case, f may be a primitive function or an expression of primitive functions combined with primitive operators:<br/>If the function does not have an inverse, a negative argument g generates DOMAIN ERROR.<br/>Some expressions, such as the following, will cause an infinite internal loop and APL will appear to hang. In most cases this can be resolved by issuing a hard INTERRUPT.<br/>One can ensure that weak interrupts and вҺ•TKILL can interrupt by packaging the вҚЈ within the dop      {вҚәвҶҗвҠў вӢ„ вҚә (вҚәвҚә{вҚәвҶҗвҠў вӢ„ вҚә вҚәвҚә вҚө}вҚЈвҚөвҚө) вҚө}."
PowerOperator,⍣
PowerOperator,"If right operand g is a numeric integer scalar, power applies its left operand function f cumulatively g times to its argument. In particular, g may be Boolean 0 or 1 for conditional function application.<br/>If right operand g is a scalar-returning dyadic function, then left operand function f is applied repeatedly until ((f Y) g Y) or until a strong interrupt occurs. Notice that power calls its dyadic right operand g with the next (f Y) and current (Y) values of the iteration as left and right arguments. In particular, if g is = or вүЎ, the result is sometimes termed a fixpoint of f.<br/>If a left argument X is present, it is bound as left argument to left operand function f:<br/>A negative right operand g applies the inverse of the operand function f, (|g)times. In this case, f may be a primitive function or an expression of primitive functions combined with primitive operators:<br/>If the function does not have an inverse, a negative argument g generates DOMAIN ERROR.<br/>Some expressions, such as the following, will cause an infinite internal loop and APL will appear to hang. In most cases this can be resolved by issuing a hard INTERRUPT.<br/>One can ensure that weak interrupts and вҺ•TKILL can interrupt by packaging the вҚЈ within the dop      {вҚәвҶҗвҠў вӢ„ вҚә (вҚәвҚә{вҚәвҶҗвҠў вӢ„ вҚә вҚәвҚә вҚө}вҚЈвҚөвҚө) вҚө}."
"If right operand g is a numeric integer scalar, power applies its left operand function f cumulatively g times to its argument. In particular, g may be Boolean 0 or 1 for conditional function application.<br/>If right operand g is a scalar-returning dyadic function, then left operand function f is applied repeatedly until ((f Y) g Y) or until a strong interrupt occurs. Notice that power calls its dyadic right operand g with the next (f Y) and current (Y) values of the iteration as left and right arguments. In particular, if g is = or вүЎ, the result is sometimes termed a fixpoint of f.<br/>If a left argument X is present, it is bound as left argument to left operand function f:<br/>A negative right operand g applies the inverse of the operand function f, (|g)times. In this case, f may be a primitive function or an expression of primitive functions combined with primitive operators:<br/>If the function does not have an inverse, a negative argument g generates DOMAIN ERROR.<br/>Some expressions, such as the following, will cause an infinite internal loop and APL will appear to hang. In most cases this can be resolved by issuing a hard INTERRUPT.<br/>One can ensure that weak interrupts and вҺ•TKILL can interrupt by packaging the вҚЈ within the dop      {вҚәвҶҗвҠў вӢ„ вҚә (вҚәвҚә{вҚәвҶҗвҠў вӢ„ вҚә вҚәвҚә вҚө}вҚЈвҚөвҚө) вҚө}.",PowerOperator
: Power Operator,⍣
"If right operand g is a numeric integer scalar, power applies its left operand function f cumulatively g times to its argument. In particular, g may be Boolean 0 or 1 for conditional function application.<br/>If right operand g is a scalar-returning dyadic function, then left operand function f is applied repeatedly until ((f Y) g Y) or until a strong interrupt occurs. Notice that power calls its dyadic right operand g with the next (f Y) and current (Y) values of the iteration as left and right arguments. In particular, if g is = or вүЎ, the result is sometimes termed a fixpoint of f.<br/>If a left argument X is present, it is bound as left argument to left operand function f:<br/>A negative right operand g applies the inverse of the operand function f, (|g)times. In this case, f may be a primitive function or an expression of primitive functions combined with primitive operators:<br/>If the function does not have an inverse, a negative argument g generates DOMAIN ERROR.<br/>Some expressions, such as the following, will cause an infinite internal loop and APL will appear to hang. In most cases this can be resolved by issuing a hard INTERRUPT.<br/>One can ensure that weak interrupts and вҺ•TKILL can interrupt by packaging the вҚЈ within the dop      {вҚәвҶҗвҠў вӢ„ вҚә (вҚәвҚә{вҚәвҶҗвҠў вӢ„ вҚә вҚәвҚә вҚө}вҚЈвҚөвҚө) вҚө}.",⍣
⍣,"If right operand g is a numeric integer scalar, power applies its left operand function f cumulatively g times to its argument. In particular, g may be Boolean 0 or 1 for conditional function application.<br/>If right operand g is a scalar-returning dyadic function, then left operand function f is applied repeatedly until ((f Y) g Y) or until a strong interrupt occurs. Notice that power calls its dyadic right operand g with the next (f Y) and current (Y) values of the iteration as left and right arguments. In particular, if g is = or вүЎ, the result is sometimes termed a fixpoint of f.<br/>If a left argument X is present, it is bound as left argument to left operand function f:<br/>A negative right operand g applies the inverse of the operand function f, (|g)times. In this case, f may be a primitive function or an expression of primitive functions combined with primitive operators:<br/>If the function does not have an inverse, a negative argument g generates DOMAIN ERROR.<br/>Some expressions, such as the following, will cause an infinite internal loop and APL will appear to hang. In most cases this can be resolved by issuing a hard INTERRUPT.<br/>One can ensure that weak interrupts and вҺ•TKILL can interrupt by packaging the вҚЈ within the dop      {вҚәвҶҗвҠў вӢ„ вҚә (вҚәвҚә{вҚәвҶҗвҠў вӢ„ вҚә вҚәвҚә вҚө}вҚЈвҚөвҚө) вҚө}."
PowerOperator,⍣
PowerOperator,"If right operand g is a numeric integer scalar, power applies its left operand function f cumulatively g times to its argument. In particular, g may be Boolean 0 or 1 for conditional function application.<br/>If right operand g is a scalar-returning dyadic function, then left operand function f is applied repeatedly until ((f Y) g Y) or until a strong interrupt occurs. Notice that power calls its dyadic right operand g with the next (f Y) and current (Y) values of the iteration as left and right arguments. In particular, if g is = or вүЎ, the result is sometimes termed a fixpoint of f.<br/>If a left argument X is present, it is bound as left argument to left operand function f:<br/>A negative right operand g applies the inverse of the operand function f, (|g)times. In this case, f may be a primitive function or an expression of primitive functions combined with primitive operators:<br/>If the function does not have an inverse, a negative argument g generates DOMAIN ERROR.<br/>Some expressions, such as the following, will cause an infinite internal loop and APL will appear to hang. In most cases this can be resolved by issuing a hard INTERRUPT.<br/>One can ensure that weak interrupts and вҺ•TKILL can interrupt by packaging the вҚЈ within the dop      {вҚәвҶҗвҠў вӢ„ вҚә (вҚәвҚә{вҚәвҶҗвҠў вӢ„ вҚә вҚәвҚә вҚө}вҚЈвҚөвҚө) вҚө}."
"If right operand g is a numeric integer scalar, power applies its left operand function f cumulatively g times to its argument. In particular, g may be Boolean 0 or 1 for conditional function application.<br/>If right operand g is a scalar-returning dyadic function, then left operand function f is applied repeatedly until ((f Y) g Y) or until a strong interrupt occurs. Notice that power calls its dyadic right operand g with the next (f Y) and current (Y) values of the iteration as left and right arguments. In particular, if g is = or вүЎ, the result is sometimes termed a fixpoint of f.<br/>If a left argument X is present, it is bound as left argument to left operand function f:<br/>A negative right operand g applies the inverse of the operand function f, (|g)times. In this case, f may be a primitive function or an expression of primitive functions combined with primitive operators:<br/>If the function does not have an inverse, a negative argument g generates DOMAIN ERROR.<br/>Some expressions, such as the following, will cause an infinite internal loop and APL will appear to hang. In most cases this can be resolved by issuing a hard INTERRUPT.<br/>One can ensure that weak interrupts and вҺ•TKILL can interrupt by packaging the вҚЈ within the dop      {вҚәвҶҗвҠў вӢ„ вҚә (вҚәвҚә{вҚәвҶҗвҠў вӢ„ вҚә вҚәвҚә вҚө}вҚЈвҚөвҚө) вҚө}.",PowerOperator
⍣,Star Diaeresis<br/>Dyadic: Power Operator<br/>: Power Operator
Ampersand,&
Monadic: Spawn,&
"& is a monadic operator with an ambivalent derived function. & spawns a new thread in which f is applied to its argument Y (monadic case) or between its arguments X and Y (dyadic case). The shy result of this application is the number of the newly created thread.<br/>When function f terminates, its result (if any), the thread result, is returned. If the thread number is the subject of an active ⎕TSYNC, the thread result appears as the result of ⎕TSYNC. If no ⎕TSYNC is in effect, the thread result is displayed in the session in the normal fashion.<br/>Note that & can be used in conjunction with the each operator ¨ to launch many threads in parallel.",&
&,"& is a monadic operator with an ambivalent derived function. & spawns a new thread in which f is applied to its argument Y (monadic case) or between its arguments X and Y (dyadic case). The shy result of this application is the number of the newly created thread.<br/>When function f terminates, its result (if any), the thread result, is returned. If the thread number is the subject of an active ⎕TSYNC, the thread result appears as the result of ⎕TSYNC. If no ⎕TSYNC is in effect, the thread result is displayed in the session in the normal fashion.<br/>Note that & can be used in conjunction with the each operator ¨ to launch many threads in parallel."
Spawn,"& is a monadic operator with an ambivalent derived function. & spawns a new thread in which f is applied to its argument Y (monadic case) or between its arguments X and Y (dyadic case). The shy result of this application is the number of the newly created thread.<br/>When function f terminates, its result (if any), the thread result, is returned. If the thread number is the subject of an active ⎕TSYNC, the thread result appears as the result of ⎕TSYNC. If no ⎕TSYNC is in effect, the thread result is displayed in the session in the normal fashion.<br/>Note that & can be used in conjunction with the each operator ¨ to launch many threads in parallel."
"& is a monadic operator with an ambivalent derived function. & spawns a new thread in which f is applied to its argument Y (monadic case) or between its arguments X and Y (dyadic case). The shy result of this application is the number of the newly created thread.<br/>When function f terminates, its result (if any), the thread result, is returned. If the thread number is the subject of an active ⎕TSYNC, the thread result appears as the result of ⎕TSYNC. If no ⎕TSYNC is in effect, the thread result is displayed in the session in the normal fashion.<br/>Note that & can be used in conjunction with the each operator ¨ to launch many threads in parallel.",Spawn
: Spawn,&
"& is a monadic operator with an ambivalent derived function. & spawns a new thread in which f is applied to its argument Y (monadic case) or between its arguments X and Y (dyadic case). The shy result of this application is the number of the newly created thread.<br/>When function f terminates, its result (if any), the thread result, is returned. If the thread number is the subject of an active ⎕TSYNC, the thread result appears as the result of ⎕TSYNC. If no ⎕TSYNC is in effect, the thread result is displayed in the session in the normal fashion.<br/>Note that & can be used in conjunction with the each operator ¨ to launch many threads in parallel.",&
&,"& is a monadic operator with an ambivalent derived function. & spawns a new thread in which f is applied to its argument Y (monadic case) or between its arguments X and Y (dyadic case). The shy result of this application is the number of the newly created thread.<br/>When function f terminates, its result (if any), the thread result, is returned. If the thread number is the subject of an active ⎕TSYNC, the thread result appears as the result of ⎕TSYNC. If no ⎕TSYNC is in effect, the thread result is displayed in the session in the normal fashion.<br/>Note that & can be used in conjunction with the each operator ¨ to launch many threads in parallel."
Spawn,"& is a monadic operator with an ambivalent derived function. & spawns a new thread in which f is applied to its argument Y (monadic case) or between its arguments X and Y (dyadic case). The shy result of this application is the number of the newly created thread.<br/>When function f terminates, its result (if any), the thread result, is returned. If the thread number is the subject of an active ⎕TSYNC, the thread result appears as the result of ⎕TSYNC. If no ⎕TSYNC is in effect, the thread result is displayed in the session in the normal fashion.<br/>Note that & can be used in conjunction with the each operator ¨ to launch many threads in parallel."
"& is a monadic operator with an ambivalent derived function. & spawns a new thread in which f is applied to its argument Y (monadic case) or between its arguments X and Y (dyadic case). The shy result of this application is the number of the newly created thread.<br/>When function f terminates, its result (if any), the thread result, is returned. If the thread number is the subject of an active ⎕TSYNC, the thread result appears as the result of ⎕TSYNC. If no ⎕TSYNC is in effect, the thread result is displayed in the session in the normal fashion.<br/>Note that & can be used in conjunction with the each operator ¨ to launch many threads in parallel.",Spawn
&,Ampersand<br/>Monadic: Spawn<br/>: Spawn
I-Beam,⌶
": Monadic operator:  I-Beam

Provides a system-related service
determined by the left-operand value.<![CDATA[
]]>",⌶
Table 26: Primitive Operators<br/>Table 27: Other Language Elements,⌶
⌶,Table 26: Primitive Operators<br/>Table 27: Other Language Elements
⌶,"I-Beam<br/>: Monadic operator:  I-Beam

Provides a system-related service
determined by the left-operand value.<![CDATA[
]]>"
Variant,⍠
⍠,Variant
Quad Equal,⌸
Monadic: Key,⌸
"Classic Edition: the symbol ⌸ is not available in Classic Edition, and the Key operator is instead represented by ⎕U2338.<br/>f may be any dyadic function that returns a result.<br/>If X is specified, it is an array whose major cells specify keys for corresponding major cells of Y.  The Key operator ⌸ applies the function f to each unique key in X and the major cells of Y having that key.<br/>If X is omitted, Y is an array whose major cells represent keys. In this case, the Key operator applies the function f to each unique key in  Y and the  elements of ⍳≢Y having that key.  f⌸Y is the same as Y f⌸⍳≢Y.<br/>The elements of R appear in the order in which they first appear in Y.<br/>Key is similar to the GROUP BY clause in SQL.<br/>⎕CT and ⎕DCT are  implicit arguments of the Key operator.<br/>In this example, both arrays are vectors so their major cells are their elements. The function {⍺':'⍵} is applied between the unique elements in suits ('Spades' 'Hearts' 'Clubs') and the elements in cards grouped according to their corresponding elements in suits, i.e. ('2' 'Ace'), ('Queen' 'Jack') and (,'4').<br/>x is a vector of stock codes, y is a corresponding matrix of values.<br/>If we apply the function {⍺ ⍵} to x and y using the ⌸ operator, we can see how the rows (its major cells) of y are grouped according to the corresponding elements (its major cells) of x.<br/>More usefully, we can apply the function {⍺(+⌿⍵)}, which delivers the stock codes and the corresponding totals in y:<br/>There is no need for the function to use its left argument. So to obtain just the totals in y grouped by the stock codes in x:<br/>This example appends the data for a stock into a component file named by the symbol.<br/>Given a list of names and scores., the problem is to sum the scores for each unique name. A solution is presented first without using the Key operator, and then with the Key operator.",⌸
⌸,"Classic Edition: the symbol ⌸ is not available in Classic Edition, and the Key operator is instead represented by ⎕U2338.<br/>f may be any dyadic function that returns a result.<br/>If X is specified, it is an array whose major cells specify keys for corresponding major cells of Y.  The Key operator ⌸ applies the function f to each unique key in X and the major cells of Y having that key.<br/>If X is omitted, Y is an array whose major cells represent keys. In this case, the Key operator applies the function f to each unique key in  Y and the  elements of ⍳≢Y having that key.  f⌸Y is the same as Y f⌸⍳≢Y.<br/>The elements of R appear in the order in which they first appear in Y.<br/>Key is similar to the GROUP BY clause in SQL.<br/>⎕CT and ⎕DCT are  implicit arguments of the Key operator.<br/>In this example, both arrays are vectors so their major cells are their elements. The function {⍺':'⍵} is applied between the unique elements in suits ('Spades' 'Hearts' 'Clubs') and the elements in cards grouped according to their corresponding elements in suits, i.e. ('2' 'Ace'), ('Queen' 'Jack') and (,'4').<br/>x is a vector of stock codes, y is a corresponding matrix of values.<br/>If we apply the function {⍺ ⍵} to x and y using the ⌸ operator, we can see how the rows (its major cells) of y are grouped according to the corresponding elements (its major cells) of x.<br/>More usefully, we can apply the function {⍺(+⌿⍵)}, which delivers the stock codes and the corresponding totals in y:<br/>There is no need for the function to use its left argument. So to obtain just the totals in y grouped by the stock codes in x:<br/>This example appends the data for a stock into a component file named by the symbol.<br/>Given a list of names and scores., the problem is to sum the scores for each unique name. A solution is presented first without using the Key operator, and then with the Key operator."
Key,"Classic Edition: the symbol ⌸ is not available in Classic Edition, and the Key operator is instead represented by ⎕U2338.<br/>f may be any dyadic function that returns a result.<br/>If X is specified, it is an array whose major cells specify keys for corresponding major cells of Y.  The Key operator ⌸ applies the function f to each unique key in X and the major cells of Y having that key.<br/>If X is omitted, Y is an array whose major cells represent keys. In this case, the Key operator applies the function f to each unique key in  Y and the  elements of ⍳≢Y having that key.  f⌸Y is the same as Y f⌸⍳≢Y.<br/>The elements of R appear in the order in which they first appear in Y.<br/>Key is similar to the GROUP BY clause in SQL.<br/>⎕CT and ⎕DCT are  implicit arguments of the Key operator.<br/>In this example, both arrays are vectors so their major cells are their elements. The function {⍺':'⍵} is applied between the unique elements in suits ('Spades' 'Hearts' 'Clubs') and the elements in cards grouped according to their corresponding elements in suits, i.e. ('2' 'Ace'), ('Queen' 'Jack') and (,'4').<br/>x is a vector of stock codes, y is a corresponding matrix of values.<br/>If we apply the function {⍺ ⍵} to x and y using the ⌸ operator, we can see how the rows (its major cells) of y are grouped according to the corresponding elements (its major cells) of x.<br/>More usefully, we can apply the function {⍺(+⌿⍵)}, which delivers the stock codes and the corresponding totals in y:<br/>There is no need for the function to use its left argument. So to obtain just the totals in y grouped by the stock codes in x:<br/>This example appends the data for a stock into a component file named by the symbol.<br/>Given a list of names and scores., the problem is to sum the scores for each unique name. A solution is presented first without using the Key operator, and then with the Key operator."
"Classic Edition: the symbol ⌸ is not available in Classic Edition, and the Key operator is instead represented by ⎕U2338.<br/>f may be any dyadic function that returns a result.<br/>If X is specified, it is an array whose major cells specify keys for corresponding major cells of Y.  The Key operator ⌸ applies the function f to each unique key in X and the major cells of Y having that key.<br/>If X is omitted, Y is an array whose major cells represent keys. In this case, the Key operator applies the function f to each unique key in  Y and the  elements of ⍳≢Y having that key.  f⌸Y is the same as Y f⌸⍳≢Y.<br/>The elements of R appear in the order in which they first appear in Y.<br/>Key is similar to the GROUP BY clause in SQL.<br/>⎕CT and ⎕DCT are  implicit arguments of the Key operator.<br/>In this example, both arrays are vectors so their major cells are their elements. The function {⍺':'⍵} is applied between the unique elements in suits ('Spades' 'Hearts' 'Clubs') and the elements in cards grouped according to their corresponding elements in suits, i.e. ('2' 'Ace'), ('Queen' 'Jack') and (,'4').<br/>x is a vector of stock codes, y is a corresponding matrix of values.<br/>If we apply the function {⍺ ⍵} to x and y using the ⌸ operator, we can see how the rows (its major cells) of y are grouped according to the corresponding elements (its major cells) of x.<br/>More usefully, we can apply the function {⍺(+⌿⍵)}, which delivers the stock codes and the corresponding totals in y:<br/>There is no need for the function to use its left argument. So to obtain just the totals in y grouped by the stock codes in x:<br/>This example appends the data for a stock into a component file named by the symbol.<br/>Given a list of names and scores., the problem is to sum the scores for each unique name. A solution is presented first without using the Key operator, and then with the Key operator.",Key
: Key,⌸
"Classic Edition: the symbol ⌸ is not available in Classic Edition, and the Key operator is instead represented by ⎕U2338.<br/>f may be any dyadic function that returns a result.<br/>If X is specified, it is an array whose major cells specify keys for corresponding major cells of Y.  The Key operator ⌸ applies the function f to each unique key in X and the major cells of Y having that key.<br/>If X is omitted, Y is an array whose major cells represent keys. In this case, the Key operator applies the function f to each unique key in  Y and the  elements of ⍳≢Y having that key.  f⌸Y is the same as Y f⌸⍳≢Y.<br/>The elements of R appear in the order in which they first appear in Y.<br/>Key is similar to the GROUP BY clause in SQL.<br/>⎕CT and ⎕DCT are  implicit arguments of the Key operator.<br/>In this example, both arrays are vectors so their major cells are their elements. The function {⍺':'⍵} is applied between the unique elements in suits ('Spades' 'Hearts' 'Clubs') and the elements in cards grouped according to their corresponding elements in suits, i.e. ('2' 'Ace'), ('Queen' 'Jack') and (,'4').<br/>x is a vector of stock codes, y is a corresponding matrix of values.<br/>If we apply the function {⍺ ⍵} to x and y using the ⌸ operator, we can see how the rows (its major cells) of y are grouped according to the corresponding elements (its major cells) of x.<br/>More usefully, we can apply the function {⍺(+⌿⍵)}, which delivers the stock codes and the corresponding totals in y:<br/>There is no need for the function to use its left argument. So to obtain just the totals in y grouped by the stock codes in x:<br/>This example appends the data for a stock into a component file named by the symbol.<br/>Given a list of names and scores., the problem is to sum the scores for each unique name. A solution is presented first without using the Key operator, and then with the Key operator.",⌸
⌸,"Classic Edition: the symbol ⌸ is not available in Classic Edition, and the Key operator is instead represented by ⎕U2338.<br/>f may be any dyadic function that returns a result.<br/>If X is specified, it is an array whose major cells specify keys for corresponding major cells of Y.  The Key operator ⌸ applies the function f to each unique key in X and the major cells of Y having that key.<br/>If X is omitted, Y is an array whose major cells represent keys. In this case, the Key operator applies the function f to each unique key in  Y and the  elements of ⍳≢Y having that key.  f⌸Y is the same as Y f⌸⍳≢Y.<br/>The elements of R appear in the order in which they first appear in Y.<br/>Key is similar to the GROUP BY clause in SQL.<br/>⎕CT and ⎕DCT are  implicit arguments of the Key operator.<br/>In this example, both arrays are vectors so their major cells are their elements. The function {⍺':'⍵} is applied between the unique elements in suits ('Spades' 'Hearts' 'Clubs') and the elements in cards grouped according to their corresponding elements in suits, i.e. ('2' 'Ace'), ('Queen' 'Jack') and (,'4').<br/>x is a vector of stock codes, y is a corresponding matrix of values.<br/>If we apply the function {⍺ ⍵} to x and y using the ⌸ operator, we can see how the rows (its major cells) of y are grouped according to the corresponding elements (its major cells) of x.<br/>More usefully, we can apply the function {⍺(+⌿⍵)}, which delivers the stock codes and the corresponding totals in y:<br/>There is no need for the function to use its left argument. So to obtain just the totals in y grouped by the stock codes in x:<br/>This example appends the data for a stock into a component file named by the symbol.<br/>Given a list of names and scores., the problem is to sum the scores for each unique name. A solution is presented first without using the Key operator, and then with the Key operator."
Key,"Classic Edition: the symbol ⌸ is not available in Classic Edition, and the Key operator is instead represented by ⎕U2338.<br/>f may be any dyadic function that returns a result.<br/>If X is specified, it is an array whose major cells specify keys for corresponding major cells of Y.  The Key operator ⌸ applies the function f to each unique key in X and the major cells of Y having that key.<br/>If X is omitted, Y is an array whose major cells represent keys. In this case, the Key operator applies the function f to each unique key in  Y and the  elements of ⍳≢Y having that key.  f⌸Y is the same as Y f⌸⍳≢Y.<br/>The elements of R appear in the order in which they first appear in Y.<br/>Key is similar to the GROUP BY clause in SQL.<br/>⎕CT and ⎕DCT are  implicit arguments of the Key operator.<br/>In this example, both arrays are vectors so their major cells are their elements. The function {⍺':'⍵} is applied between the unique elements in suits ('Spades' 'Hearts' 'Clubs') and the elements in cards grouped according to their corresponding elements in suits, i.e. ('2' 'Ace'), ('Queen' 'Jack') and (,'4').<br/>x is a vector of stock codes, y is a corresponding matrix of values.<br/>If we apply the function {⍺ ⍵} to x and y using the ⌸ operator, we can see how the rows (its major cells) of y are grouped according to the corresponding elements (its major cells) of x.<br/>More usefully, we can apply the function {⍺(+⌿⍵)}, which delivers the stock codes and the corresponding totals in y:<br/>There is no need for the function to use its left argument. So to obtain just the totals in y grouped by the stock codes in x:<br/>This example appends the data for a stock into a component file named by the symbol.<br/>Given a list of names and scores., the problem is to sum the scores for each unique name. A solution is presented first without using the Key operator, and then with the Key operator."
"Classic Edition: the symbol ⌸ is not available in Classic Edition, and the Key operator is instead represented by ⎕U2338.<br/>f may be any dyadic function that returns a result.<br/>If X is specified, it is an array whose major cells specify keys for corresponding major cells of Y.  The Key operator ⌸ applies the function f to each unique key in X and the major cells of Y having that key.<br/>If X is omitted, Y is an array whose major cells represent keys. In this case, the Key operator applies the function f to each unique key in  Y and the  elements of ⍳≢Y having that key.  f⌸Y is the same as Y f⌸⍳≢Y.<br/>The elements of R appear in the order in which they first appear in Y.<br/>Key is similar to the GROUP BY clause in SQL.<br/>⎕CT and ⎕DCT are  implicit arguments of the Key operator.<br/>In this example, both arrays are vectors so their major cells are their elements. The function {⍺':'⍵} is applied between the unique elements in suits ('Spades' 'Hearts' 'Clubs') and the elements in cards grouped according to their corresponding elements in suits, i.e. ('2' 'Ace'), ('Queen' 'Jack') and (,'4').<br/>x is a vector of stock codes, y is a corresponding matrix of values.<br/>If we apply the function {⍺ ⍵} to x and y using the ⌸ operator, we can see how the rows (its major cells) of y are grouped according to the corresponding elements (its major cells) of x.<br/>More usefully, we can apply the function {⍺(+⌿⍵)}, which delivers the stock codes and the corresponding totals in y:<br/>There is no need for the function to use its left argument. So to obtain just the totals in y grouped by the stock codes in x:<br/>This example appends the data for a stock into a component file named by the symbol.<br/>Given a list of names and scores., the problem is to sum the scores for each unique name. A solution is presented first without using the Key operator, and then with the Key operator.",Key
⌸,Quad Equal<br/>Monadic: Key<br/>: Key
Quad Diamond,⌺
Dyadic: Stencil,⌺
"Classic Edition: the symbol ⌺ is not available in Classic Edition, and the Stencil operator is instead represented by ⎕U233A.<br/>Stencil is used in image processing, artificial neural networks, computational fluid dynamics, cellular automata, and many other fields of application. The computation is sometimes referred to as tessellation, moving window, or stencil code. This operator applies the left operand function f to a series of (possibly overlapping) rectangles in the array Y.<br/>In general, the right operand g is a 2- row matrix of positive non-zero integers with up to ⍴⍴Y columns. The first row contains the rectangle sizes, the second row the movements i.e. how much to move the rectangle in each step. If g is a scalar or vector it specifies the rectangle size and the movement defaults to 1.<br/>The predominant case uses a rectangle size which is odd and a movement of 1.<br/>Rectangles are centred on successive elements of Y and (unless the rectangle size is 1), padded with fill elements.<br/>The first rectangle is centred on the first element of Y preceded by the appropriate number of fill elements. Subsequent rectangles are centred on subsequent elements of Y according to the size of the movement, and padded before or after as appropriate. When the movement is 1, each element of Y in its turn is the middle of a rectangle.<br/>f is invoked dyadically with a vector left argument indicating for each axis the number of fill elements and on what side; positive values mean that the padding precedes the array values,
negative values mean that the padding follows the array values.<br/>In the first expression above, the left operand function {⊂⍺ ⍵} simply displays its left and right arguments to illustrate the mechanics of the operation. The right operand (3 3) specifies that each rectangle contains 3 rows and 3 columns, and the movement is 1. <br/>In order for the first element of Y (1) to be centred, the first rectangle is padded with a row above and a column to the left, as indicated by the left argument (1 1) to the function.<br/>Another way to think about the way Stencil operates is that it portions the array into sections or neighbourhoods in which elements can be analysed with respect to their immediate neighbours. Stencil  has uses in image processing applications.<br/>You can see that the result identifies where there are clusters in y.<br/>If the movement is greater than one, corresponding portions are skipped as shown below.<br/>For even rectangle sizes, the ""middle"" consists of two elements which are moved according to the movement parameter (equal to 1 in these examples).",⌺
⌺,"Classic Edition: the symbol ⌺ is not available in Classic Edition, and the Stencil operator is instead represented by ⎕U233A.<br/>Stencil is used in image processing, artificial neural networks, computational fluid dynamics, cellular automata, and many other fields of application. The computation is sometimes referred to as tessellation, moving window, or stencil code. This operator applies the left operand function f to a series of (possibly overlapping) rectangles in the array Y.<br/>In general, the right operand g is a 2- row matrix of positive non-zero integers with up to ⍴⍴Y columns. The first row contains the rectangle sizes, the second row the movements i.e. how much to move the rectangle in each step. If g is a scalar or vector it specifies the rectangle size and the movement defaults to 1.<br/>The predominant case uses a rectangle size which is odd and a movement of 1.<br/>Rectangles are centred on successive elements of Y and (unless the rectangle size is 1), padded with fill elements.<br/>The first rectangle is centred on the first element of Y preceded by the appropriate number of fill elements. Subsequent rectangles are centred on subsequent elements of Y according to the size of the movement, and padded before or after as appropriate. When the movement is 1, each element of Y in its turn is the middle of a rectangle.<br/>f is invoked dyadically with a vector left argument indicating for each axis the number of fill elements and on what side; positive values mean that the padding precedes the array values,
negative values mean that the padding follows the array values.<br/>In the first expression above, the left operand function {⊂⍺ ⍵} simply displays its left and right arguments to illustrate the mechanics of the operation. The right operand (3 3) specifies that each rectangle contains 3 rows and 3 columns, and the movement is 1. <br/>In order for the first element of Y (1) to be centred, the first rectangle is padded with a row above and a column to the left, as indicated by the left argument (1 1) to the function.<br/>Another way to think about the way Stencil operates is that it portions the array into sections or neighbourhoods in which elements can be analysed with respect to their immediate neighbours. Stencil  has uses in image processing applications.<br/>You can see that the result identifies where there are clusters in y.<br/>If the movement is greater than one, corresponding portions are skipped as shown below.<br/>For even rectangle sizes, the ""middle"" consists of two elements which are moved according to the movement parameter (equal to 1 in these examples)."
Stencil,"Classic Edition: the symbol ⌺ is not available in Classic Edition, and the Stencil operator is instead represented by ⎕U233A.<br/>Stencil is used in image processing, artificial neural networks, computational fluid dynamics, cellular automata, and many other fields of application. The computation is sometimes referred to as tessellation, moving window, or stencil code. This operator applies the left operand function f to a series of (possibly overlapping) rectangles in the array Y.<br/>In general, the right operand g is a 2- row matrix of positive non-zero integers with up to ⍴⍴Y columns. The first row contains the rectangle sizes, the second row the movements i.e. how much to move the rectangle in each step. If g is a scalar or vector it specifies the rectangle size and the movement defaults to 1.<br/>The predominant case uses a rectangle size which is odd and a movement of 1.<br/>Rectangles are centred on successive elements of Y and (unless the rectangle size is 1), padded with fill elements.<br/>The first rectangle is centred on the first element of Y preceded by the appropriate number of fill elements. Subsequent rectangles are centred on subsequent elements of Y according to the size of the movement, and padded before or after as appropriate. When the movement is 1, each element of Y in its turn is the middle of a rectangle.<br/>f is invoked dyadically with a vector left argument indicating for each axis the number of fill elements and on what side; positive values mean that the padding precedes the array values,
negative values mean that the padding follows the array values.<br/>In the first expression above, the left operand function {⊂⍺ ⍵} simply displays its left and right arguments to illustrate the mechanics of the operation. The right operand (3 3) specifies that each rectangle contains 3 rows and 3 columns, and the movement is 1. <br/>In order for the first element of Y (1) to be centred, the first rectangle is padded with a row above and a column to the left, as indicated by the left argument (1 1) to the function.<br/>Another way to think about the way Stencil operates is that it portions the array into sections or neighbourhoods in which elements can be analysed with respect to their immediate neighbours. Stencil  has uses in image processing applications.<br/>You can see that the result identifies where there are clusters in y.<br/>If the movement is greater than one, corresponding portions are skipped as shown below.<br/>For even rectangle sizes, the ""middle"" consists of two elements which are moved according to the movement parameter (equal to 1 in these examples)."
"Classic Edition: the symbol ⌺ is not available in Classic Edition, and the Stencil operator is instead represented by ⎕U233A.<br/>Stencil is used in image processing, artificial neural networks, computational fluid dynamics, cellular automata, and many other fields of application. The computation is sometimes referred to as tessellation, moving window, or stencil code. This operator applies the left operand function f to a series of (possibly overlapping) rectangles in the array Y.<br/>In general, the right operand g is a 2- row matrix of positive non-zero integers with up to ⍴⍴Y columns. The first row contains the rectangle sizes, the second row the movements i.e. how much to move the rectangle in each step. If g is a scalar or vector it specifies the rectangle size and the movement defaults to 1.<br/>The predominant case uses a rectangle size which is odd and a movement of 1.<br/>Rectangles are centred on successive elements of Y and (unless the rectangle size is 1), padded with fill elements.<br/>The first rectangle is centred on the first element of Y preceded by the appropriate number of fill elements. Subsequent rectangles are centred on subsequent elements of Y according to the size of the movement, and padded before or after as appropriate. When the movement is 1, each element of Y in its turn is the middle of a rectangle.<br/>f is invoked dyadically with a vector left argument indicating for each axis the number of fill elements and on what side; positive values mean that the padding precedes the array values,
negative values mean that the padding follows the array values.<br/>In the first expression above, the left operand function {⊂⍺ ⍵} simply displays its left and right arguments to illustrate the mechanics of the operation. The right operand (3 3) specifies that each rectangle contains 3 rows and 3 columns, and the movement is 1. <br/>In order for the first element of Y (1) to be centred, the first rectangle is padded with a row above and a column to the left, as indicated by the left argument (1 1) to the function.<br/>Another way to think about the way Stencil operates is that it portions the array into sections or neighbourhoods in which elements can be analysed with respect to their immediate neighbours. Stencil  has uses in image processing applications.<br/>You can see that the result identifies where there are clusters in y.<br/>If the movement is greater than one, corresponding portions are skipped as shown below.<br/>For even rectangle sizes, the ""middle"" consists of two elements which are moved according to the movement parameter (equal to 1 in these examples).",Stencil
: Stencil,⌺
"Classic Edition: the symbol ⌺ is not available in Classic Edition, and the Stencil operator is instead represented by ⎕U233A.<br/>Stencil is used in image processing, artificial neural networks, computational fluid dynamics, cellular automata, and many other fields of application. The computation is sometimes referred to as tessellation, moving window, or stencil code. This operator applies the left operand function f to a series of (possibly overlapping) rectangles in the array Y.<br/>In general, the right operand g is a 2- row matrix of positive non-zero integers with up to ⍴⍴Y columns. The first row contains the rectangle sizes, the second row the movements i.e. how much to move the rectangle in each step. If g is a scalar or vector it specifies the rectangle size and the movement defaults to 1.<br/>The predominant case uses a rectangle size which is odd and a movement of 1.<br/>Rectangles are centred on successive elements of Y and (unless the rectangle size is 1), padded with fill elements.<br/>The first rectangle is centred on the first element of Y preceded by the appropriate number of fill elements. Subsequent rectangles are centred on subsequent elements of Y according to the size of the movement, and padded before or after as appropriate. When the movement is 1, each element of Y in its turn is the middle of a rectangle.<br/>f is invoked dyadically with a vector left argument indicating for each axis the number of fill elements and on what side; positive values mean that the padding precedes the array values,
negative values mean that the padding follows the array values.<br/>In the first expression above, the left operand function {⊂⍺ ⍵} simply displays its left and right arguments to illustrate the mechanics of the operation. The right operand (3 3) specifies that each rectangle contains 3 rows and 3 columns, and the movement is 1. <br/>In order for the first element of Y (1) to be centred, the first rectangle is padded with a row above and a column to the left, as indicated by the left argument (1 1) to the function.<br/>Another way to think about the way Stencil operates is that it portions the array into sections or neighbourhoods in which elements can be analysed with respect to their immediate neighbours. Stencil  has uses in image processing applications.<br/>You can see that the result identifies where there are clusters in y.<br/>If the movement is greater than one, corresponding portions are skipped as shown below.<br/>For even rectangle sizes, the ""middle"" consists of two elements which are moved according to the movement parameter (equal to 1 in these examples).",⌺
⌺,"Classic Edition: the symbol ⌺ is not available in Classic Edition, and the Stencil operator is instead represented by ⎕U233A.<br/>Stencil is used in image processing, artificial neural networks, computational fluid dynamics, cellular automata, and many other fields of application. The computation is sometimes referred to as tessellation, moving window, or stencil code. This operator applies the left operand function f to a series of (possibly overlapping) rectangles in the array Y.<br/>In general, the right operand g is a 2- row matrix of positive non-zero integers with up to ⍴⍴Y columns. The first row contains the rectangle sizes, the second row the movements i.e. how much to move the rectangle in each step. If g is a scalar or vector it specifies the rectangle size and the movement defaults to 1.<br/>The predominant case uses a rectangle size which is odd and a movement of 1.<br/>Rectangles are centred on successive elements of Y and (unless the rectangle size is 1), padded with fill elements.<br/>The first rectangle is centred on the first element of Y preceded by the appropriate number of fill elements. Subsequent rectangles are centred on subsequent elements of Y according to the size of the movement, and padded before or after as appropriate. When the movement is 1, each element of Y in its turn is the middle of a rectangle.<br/>f is invoked dyadically with a vector left argument indicating for each axis the number of fill elements and on what side; positive values mean that the padding precedes the array values,
negative values mean that the padding follows the array values.<br/>In the first expression above, the left operand function {⊂⍺ ⍵} simply displays its left and right arguments to illustrate the mechanics of the operation. The right operand (3 3) specifies that each rectangle contains 3 rows and 3 columns, and the movement is 1. <br/>In order for the first element of Y (1) to be centred, the first rectangle is padded with a row above and a column to the left, as indicated by the left argument (1 1) to the function.<br/>Another way to think about the way Stencil operates is that it portions the array into sections or neighbourhoods in which elements can be analysed with respect to their immediate neighbours. Stencil  has uses in image processing applications.<br/>You can see that the result identifies where there are clusters in y.<br/>If the movement is greater than one, corresponding portions are skipped as shown below.<br/>For even rectangle sizes, the ""middle"" consists of two elements which are moved according to the movement parameter (equal to 1 in these examples)."
Stencil,"Classic Edition: the symbol ⌺ is not available in Classic Edition, and the Stencil operator is instead represented by ⎕U233A.<br/>Stencil is used in image processing, artificial neural networks, computational fluid dynamics, cellular automata, and many other fields of application. The computation is sometimes referred to as tessellation, moving window, or stencil code. This operator applies the left operand function f to a series of (possibly overlapping) rectangles in the array Y.<br/>In general, the right operand g is a 2- row matrix of positive non-zero integers with up to ⍴⍴Y columns. The first row contains the rectangle sizes, the second row the movements i.e. how much to move the rectangle in each step. If g is a scalar or vector it specifies the rectangle size and the movement defaults to 1.<br/>The predominant case uses a rectangle size which is odd and a movement of 1.<br/>Rectangles are centred on successive elements of Y and (unless the rectangle size is 1), padded with fill elements.<br/>The first rectangle is centred on the first element of Y preceded by the appropriate number of fill elements. Subsequent rectangles are centred on subsequent elements of Y according to the size of the movement, and padded before or after as appropriate. When the movement is 1, each element of Y in its turn is the middle of a rectangle.<br/>f is invoked dyadically with a vector left argument indicating for each axis the number of fill elements and on what side; positive values mean that the padding precedes the array values,
negative values mean that the padding follows the array values.<br/>In the first expression above, the left operand function {⊂⍺ ⍵} simply displays its left and right arguments to illustrate the mechanics of the operation. The right operand (3 3) specifies that each rectangle contains 3 rows and 3 columns, and the movement is 1. <br/>In order for the first element of Y (1) to be centred, the first rectangle is padded with a row above and a column to the left, as indicated by the left argument (1 1) to the function.<br/>Another way to think about the way Stencil operates is that it portions the array into sections or neighbourhoods in which elements can be analysed with respect to their immediate neighbours. Stencil  has uses in image processing applications.<br/>You can see that the result identifies where there are clusters in y.<br/>If the movement is greater than one, corresponding portions are skipped as shown below.<br/>For even rectangle sizes, the ""middle"" consists of two elements which are moved according to the movement parameter (equal to 1 in these examples)."
"Classic Edition: the symbol ⌺ is not available in Classic Edition, and the Stencil operator is instead represented by ⎕U233A.<br/>Stencil is used in image processing, artificial neural networks, computational fluid dynamics, cellular automata, and many other fields of application. The computation is sometimes referred to as tessellation, moving window, or stencil code. This operator applies the left operand function f to a series of (possibly overlapping) rectangles in the array Y.<br/>In general, the right operand g is a 2- row matrix of positive non-zero integers with up to ⍴⍴Y columns. The first row contains the rectangle sizes, the second row the movements i.e. how much to move the rectangle in each step. If g is a scalar or vector it specifies the rectangle size and the movement defaults to 1.<br/>The predominant case uses a rectangle size which is odd and a movement of 1.<br/>Rectangles are centred on successive elements of Y and (unless the rectangle size is 1), padded with fill elements.<br/>The first rectangle is centred on the first element of Y preceded by the appropriate number of fill elements. Subsequent rectangles are centred on subsequent elements of Y according to the size of the movement, and padded before or after as appropriate. When the movement is 1, each element of Y in its turn is the middle of a rectangle.<br/>f is invoked dyadically with a vector left argument indicating for each axis the number of fill elements and on what side; positive values mean that the padding precedes the array values,
negative values mean that the padding follows the array values.<br/>In the first expression above, the left operand function {⊂⍺ ⍵} simply displays its left and right arguments to illustrate the mechanics of the operation. The right operand (3 3) specifies that each rectangle contains 3 rows and 3 columns, and the movement is 1. <br/>In order for the first element of Y (1) to be centred, the first rectangle is padded with a row above and a column to the left, as indicated by the left argument (1 1) to the function.<br/>Another way to think about the way Stencil operates is that it portions the array into sections or neighbourhoods in which elements can be analysed with respect to their immediate neighbours. Stencil  has uses in image processing applications.<br/>You can see that the result identifies where there are clusters in y.<br/>If the movement is greater than one, corresponding portions are skipped as shown below.<br/>For even rectangle sizes, the ""middle"" consists of two elements which are moved according to the movement parameter (equal to 1 in these examples).",Stencil
⌺,Quad Diamond<br/>Dyadic: Stencil<br/>: Stencil
Jot Diaeresis,⍤
Dyadic: Atop,⍤
"Classic Edition: the symbol ⍤ is not available in Classic Edition, and the Atop operator is instead represented by ⎕U2364.<br/>f can be any monadic function.  Y can be any array that is suitable as the right argument to function g with the result of g being appropriate to function f.<br/>If X is omitted, g must be a monadic function. If X is specified, g must be a dyadic function and X can be any array that is suitable as the left argument to function g.<br/>The derived function is equivalent to fgY or fXgY and need not return a result.<br/>The Atop operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition.",⍤
⍤,"Classic Edition: the symbol ⍤ is not available in Classic Edition, and the Atop operator is instead represented by ⎕U2364.<br/>f can be any monadic function.  Y can be any array that is suitable as the right argument to function g with the result of g being appropriate to function f.<br/>If X is omitted, g must be a monadic function. If X is specified, g must be a dyadic function and X can be any array that is suitable as the left argument to function g.<br/>The derived function is equivalent to fgY or fXgY and need not return a result.<br/>The Atop operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition."
Atop,"Classic Edition: the symbol ⍤ is not available in Classic Edition, and the Atop operator is instead represented by ⎕U2364.<br/>f can be any monadic function.  Y can be any array that is suitable as the right argument to function g with the result of g being appropriate to function f.<br/>If X is omitted, g must be a monadic function. If X is specified, g must be a dyadic function and X can be any array that is suitable as the left argument to function g.<br/>The derived function is equivalent to fgY or fXgY and need not return a result.<br/>The Atop operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition."
"Classic Edition: the symbol ⍤ is not available in Classic Edition, and the Atop operator is instead represented by ⎕U2364.<br/>f can be any monadic function.  Y can be any array that is suitable as the right argument to function g with the result of g being appropriate to function f.<br/>If X is omitted, g must be a monadic function. If X is specified, g must be a dyadic function and X can be any array that is suitable as the left argument to function g.<br/>The derived function is equivalent to fgY or fXgY and need not return a result.<br/>The Atop operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition.",Atop
: Atop,⍤
"Classic Edition: the symbol ⍤ is not available in Classic Edition, and the Atop operator is instead represented by ⎕U2364.<br/>f can be any monadic function.  Y can be any array that is suitable as the right argument to function g with the result of g being appropriate to function f.<br/>If X is omitted, g must be a monadic function. If X is specified, g must be a dyadic function and X can be any array that is suitable as the left argument to function g.<br/>The derived function is equivalent to fgY or fXgY and need not return a result.<br/>The Atop operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition.",⍤
⍤,"Classic Edition: the symbol ⍤ is not available in Classic Edition, and the Atop operator is instead represented by ⎕U2364.<br/>f can be any monadic function.  Y can be any array that is suitable as the right argument to function g with the result of g being appropriate to function f.<br/>If X is omitted, g must be a monadic function. If X is specified, g must be a dyadic function and X can be any array that is suitable as the left argument to function g.<br/>The derived function is equivalent to fgY or fXgY and need not return a result.<br/>The Atop operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition."
Atop,"Classic Edition: the symbol ⍤ is not available in Classic Edition, and the Atop operator is instead represented by ⎕U2364.<br/>f can be any monadic function.  Y can be any array that is suitable as the right argument to function g with the result of g being appropriate to function f.<br/>If X is omitted, g must be a monadic function. If X is specified, g must be a dyadic function and X can be any array that is suitable as the left argument to function g.<br/>The derived function is equivalent to fgY or fXgY and need not return a result.<br/>The Atop operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition."
"Classic Edition: the symbol ⍤ is not available in Classic Edition, and the Atop operator is instead represented by ⎕U2364.<br/>f can be any monadic function.  Y can be any array that is suitable as the right argument to function g with the result of g being appropriate to function f.<br/>If X is omitted, g must be a monadic function. If X is specified, g must be a dyadic function and X can be any array that is suitable as the left argument to function g.<br/>The derived function is equivalent to fgY or fXgY and need not return a result.<br/>The Atop operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition.",Atop
⍤,Jot Diaeresis<br/>Dyadic: Atop<br/>: Atop
Circle Dieresis,⍥
Dyadic: Over,⍥
"Classic Edition: the symbol ⍥ is not available in Classic Edition, and the Over operator is instead represented by ⎕U2365.<br/>g can be any monadic function which returns a result.  Y can be any array that is suitable as the argument to function g with gY being suitable as the right argument to function f.<br/>If X is omitted, f must be a monadic function. If X is specified, f must be a dyadic function and X can be any array that is suitable as argument to function g with gX being suitable as the left argument to function f.<br/>The derived function is equivalent to fgY or (gX)f(gY) and need not return a result.<br/>The Over operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition.",⍥
⍥,"Classic Edition: the symbol ⍥ is not available in Classic Edition, and the Over operator is instead represented by ⎕U2365.<br/>g can be any monadic function which returns a result.  Y can be any array that is suitable as the argument to function g with gY being suitable as the right argument to function f.<br/>If X is omitted, f must be a monadic function. If X is specified, f must be a dyadic function and X can be any array that is suitable as argument to function g with gX being suitable as the left argument to function f.<br/>The derived function is equivalent to fgY or (gX)f(gY) and need not return a result.<br/>The Over operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition."
Over,"Classic Edition: the symbol ⍥ is not available in Classic Edition, and the Over operator is instead represented by ⎕U2365.<br/>g can be any monadic function which returns a result.  Y can be any array that is suitable as the argument to function g with gY being suitable as the right argument to function f.<br/>If X is omitted, f must be a monadic function. If X is specified, f must be a dyadic function and X can be any array that is suitable as argument to function g with gX being suitable as the left argument to function f.<br/>The derived function is equivalent to fgY or (gX)f(gY) and need not return a result.<br/>The Over operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition."
"Classic Edition: the symbol ⍥ is not available in Classic Edition, and the Over operator is instead represented by ⎕U2365.<br/>g can be any monadic function which returns a result.  Y can be any array that is suitable as the argument to function g with gY being suitable as the right argument to function f.<br/>If X is omitted, f must be a monadic function. If X is specified, f must be a dyadic function and X can be any array that is suitable as argument to function g with gX being suitable as the left argument to function f.<br/>The derived function is equivalent to fgY or (gX)f(gY) and need not return a result.<br/>The Over operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition.",Over
: Over,⍥
"Classic Edition: the symbol ⍥ is not available in Classic Edition, and the Over operator is instead represented by ⎕U2365.<br/>g can be any monadic function which returns a result.  Y can be any array that is suitable as the argument to function g with gY being suitable as the right argument to function f.<br/>If X is omitted, f must be a monadic function. If X is specified, f must be a dyadic function and X can be any array that is suitable as argument to function g with gX being suitable as the left argument to function f.<br/>The derived function is equivalent to fgY or (gX)f(gY) and need not return a result.<br/>The Over operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition.",⍥
⍥,"Classic Edition: the symbol ⍥ is not available in Classic Edition, and the Over operator is instead represented by ⎕U2365.<br/>g can be any monadic function which returns a result.  Y can be any array that is suitable as the argument to function g with gY being suitable as the right argument to function f.<br/>If X is omitted, f must be a monadic function. If X is specified, f must be a dyadic function and X can be any array that is suitable as argument to function g with gX being suitable as the left argument to function f.<br/>The derived function is equivalent to fgY or (gX)f(gY) and need not return a result.<br/>The Over operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition."
Over,"Classic Edition: the symbol ⍥ is not available in Classic Edition, and the Over operator is instead represented by ⎕U2365.<br/>g can be any monadic function which returns a result.  Y can be any array that is suitable as the argument to function g with gY being suitable as the right argument to function f.<br/>If X is omitted, f must be a monadic function. If X is specified, f must be a dyadic function and X can be any array that is suitable as argument to function g with gX being suitable as the left argument to function f.<br/>The derived function is equivalent to fgY or (gX)f(gY) and need not return a result.<br/>The Over operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition."
"Classic Edition: the symbol ⍥ is not available in Classic Edition, and the Over operator is instead represented by ⎕U2365.<br/>g can be any monadic function which returns a result.  Y can be any array that is suitable as the argument to function g with gY being suitable as the right argument to function f.<br/>If X is omitted, f must be a monadic function. If X is specified, f must be a dyadic function and X can be any array that is suitable as argument to function g with gX being suitable as the left argument to function f.<br/>The derived function is equivalent to fgY or (gX)f(gY) and need not return a result.<br/>The Over operator allows functions to be glued together to build up more complex functions. For further information, see Function Composition.",Over
⍥,Circle Dieresis<br/>Dyadic: Over<br/>: Over
At,@
Dyadic: At,@
This operator substitutes selected items in Y with new values or applies a function to modify selected items in Y.<br/>The right operand g  identifies which items of array Y are to be substituted or modified. It is either:<br/>The left operand f is either:<br/>The result R is the same as Y but with the items specified by g substituted or modified by f.<br/>Replace the 2nd and 4th items of ⍳5:<br/>Replace the 2nd and 4th items  of nested vector with ⍬:<br/>Replace the 2nd and 4th rows (major cells) of a matrix:<br/>Replace first and last elements with 0 using Choose Indexing:<br/>Replace nested items using Reach Indexing:<br/>Replace the 2nd and 4th items of ⍳5 with their reciprocals:<br/>Replace the 2nd and 4th items of ⍳5 with their reversal:<br/>Multiply the 2nd and 4th items of ⍳5 by 10:<br/>Replace the 2nd and 4th items by their totals:<br/>Replace the 2nd and 4th rows (major cells) of a matrix with their accumulatives:<br/>Replace odd elements with 0:<br/>Replace multiples of 3 (note              that masked items are substituted in ravel order):<br/>Replace odd elements with their reciprocals:<br/>Replace odd items of ⍳5 with themselves reversed:,@
@,This operator substitutes selected items in Y with new values or applies a function to modify selected items in Y.<br/>The right operand g  identifies which items of array Y are to be substituted or modified. It is either:<br/>The left operand f is either:<br/>The result R is the same as Y but with the items specified by g substituted or modified by f.<br/>Replace the 2nd and 4th items of ⍳5:<br/>Replace the 2nd and 4th items  of nested vector with ⍬:<br/>Replace the 2nd and 4th rows (major cells) of a matrix:<br/>Replace first and last elements with 0 using Choose Indexing:<br/>Replace nested items using Reach Indexing:<br/>Replace the 2nd and 4th items of ⍳5 with their reciprocals:<br/>Replace the 2nd and 4th items of ⍳5 with their reversal:<br/>Multiply the 2nd and 4th items of ⍳5 by 10:<br/>Replace the 2nd and 4th items by their totals:<br/>Replace the 2nd and 4th rows (major cells) of a matrix with their accumulatives:<br/>Replace odd elements with 0:<br/>Replace multiples of 3 (note              that masked items are substituted in ravel order):<br/>Replace odd elements with their reciprocals:<br/>Replace odd items of ⍳5 with themselves reversed:
At,This operator substitutes selected items in Y with new values or applies a function to modify selected items in Y.<br/>The right operand g  identifies which items of array Y are to be substituted or modified. It is either:<br/>The left operand f is either:<br/>The result R is the same as Y but with the items specified by g substituted or modified by f.<br/>Replace the 2nd and 4th items of ⍳5:<br/>Replace the 2nd and 4th items  of nested vector with ⍬:<br/>Replace the 2nd and 4th rows (major cells) of a matrix:<br/>Replace first and last elements with 0 using Choose Indexing:<br/>Replace nested items using Reach Indexing:<br/>Replace the 2nd and 4th items of ⍳5 with their reciprocals:<br/>Replace the 2nd and 4th items of ⍳5 with their reversal:<br/>Multiply the 2nd and 4th items of ⍳5 by 10:<br/>Replace the 2nd and 4th items by their totals:<br/>Replace the 2nd and 4th rows (major cells) of a matrix with their accumulatives:<br/>Replace odd elements with 0:<br/>Replace multiples of 3 (note              that masked items are substituted in ravel order):<br/>Replace odd elements with their reciprocals:<br/>Replace odd items of ⍳5 with themselves reversed:
This operator substitutes selected items in Y with new values or applies a function to modify selected items in Y.<br/>The right operand g  identifies which items of array Y are to be substituted or modified. It is either:<br/>The left operand f is either:<br/>The result R is the same as Y but with the items specified by g substituted or modified by f.<br/>Replace the 2nd and 4th items of ⍳5:<br/>Replace the 2nd and 4th items  of nested vector with ⍬:<br/>Replace the 2nd and 4th rows (major cells) of a matrix:<br/>Replace first and last elements with 0 using Choose Indexing:<br/>Replace nested items using Reach Indexing:<br/>Replace the 2nd and 4th items of ⍳5 with their reciprocals:<br/>Replace the 2nd and 4th items of ⍳5 with their reversal:<br/>Multiply the 2nd and 4th items of ⍳5 by 10:<br/>Replace the 2nd and 4th items by their totals:<br/>Replace the 2nd and 4th rows (major cells) of a matrix with their accumulatives:<br/>Replace odd elements with 0:<br/>Replace multiples of 3 (note              that masked items are substituted in ravel order):<br/>Replace odd elements with their reciprocals:<br/>Replace odd items of ⍳5 with themselves reversed:,At
: At,@
This operator substitutes selected items in Y with new values or applies a function to modify selected items in Y.<br/>The right operand g  identifies which items of array Y are to be substituted or modified. It is either:<br/>The left operand f is either:<br/>The result R is the same as Y but with the items specified by g substituted or modified by f.<br/>Replace the 2nd and 4th items of ⍳5:<br/>Replace the 2nd and 4th items  of nested vector with ⍬:<br/>Replace the 2nd and 4th rows (major cells) of a matrix:<br/>Replace first and last elements with 0 using Choose Indexing:<br/>Replace nested items using Reach Indexing:<br/>Replace the 2nd and 4th items of ⍳5 with their reciprocals:<br/>Replace the 2nd and 4th items of ⍳5 with their reversal:<br/>Multiply the 2nd and 4th items of ⍳5 by 10:<br/>Replace the 2nd and 4th items by their totals:<br/>Replace the 2nd and 4th rows (major cells) of a matrix with their accumulatives:<br/>Replace odd elements with 0:<br/>Replace multiples of 3 (note              that masked items are substituted in ravel order):<br/>Replace odd elements with their reciprocals:<br/>Replace odd items of ⍳5 with themselves reversed:,@
@,This operator substitutes selected items in Y with new values or applies a function to modify selected items in Y.<br/>The right operand g  identifies which items of array Y are to be substituted or modified. It is either:<br/>The left operand f is either:<br/>The result R is the same as Y but with the items specified by g substituted or modified by f.<br/>Replace the 2nd and 4th items of ⍳5:<br/>Replace the 2nd and 4th items  of nested vector with ⍬:<br/>Replace the 2nd and 4th rows (major cells) of a matrix:<br/>Replace first and last elements with 0 using Choose Indexing:<br/>Replace nested items using Reach Indexing:<br/>Replace the 2nd and 4th items of ⍳5 with their reciprocals:<br/>Replace the 2nd and 4th items of ⍳5 with their reversal:<br/>Multiply the 2nd and 4th items of ⍳5 by 10:<br/>Replace the 2nd and 4th items by their totals:<br/>Replace the 2nd and 4th rows (major cells) of a matrix with their accumulatives:<br/>Replace odd elements with 0:<br/>Replace multiples of 3 (note              that masked items are substituted in ravel order):<br/>Replace odd elements with their reciprocals:<br/>Replace odd items of ⍳5 with themselves reversed:
At,This operator substitutes selected items in Y with new values or applies a function to modify selected items in Y.<br/>The right operand g  identifies which items of array Y are to be substituted or modified. It is either:<br/>The left operand f is either:<br/>The result R is the same as Y but with the items specified by g substituted or modified by f.<br/>Replace the 2nd and 4th items of ⍳5:<br/>Replace the 2nd and 4th items  of nested vector with ⍬:<br/>Replace the 2nd and 4th rows (major cells) of a matrix:<br/>Replace first and last elements with 0 using Choose Indexing:<br/>Replace nested items using Reach Indexing:<br/>Replace the 2nd and 4th items of ⍳5 with their reciprocals:<br/>Replace the 2nd and 4th items of ⍳5 with their reversal:<br/>Multiply the 2nd and 4th items of ⍳5 by 10:<br/>Replace the 2nd and 4th items by their totals:<br/>Replace the 2nd and 4th rows (major cells) of a matrix with their accumulatives:<br/>Replace odd elements with 0:<br/>Replace multiples of 3 (note              that masked items are substituted in ravel order):<br/>Replace odd elements with their reciprocals:<br/>Replace odd items of ⍳5 with themselves reversed:
This operator substitutes selected items in Y with new values or applies a function to modify selected items in Y.<br/>The right operand g  identifies which items of array Y are to be substituted or modified. It is either:<br/>The left operand f is either:<br/>The result R is the same as Y but with the items specified by g substituted or modified by f.<br/>Replace the 2nd and 4th items of ⍳5:<br/>Replace the 2nd and 4th items  of nested vector with ⍬:<br/>Replace the 2nd and 4th rows (major cells) of a matrix:<br/>Replace first and last elements with 0 using Choose Indexing:<br/>Replace nested items using Reach Indexing:<br/>Replace the 2nd and 4th items of ⍳5 with their reciprocals:<br/>Replace the 2nd and 4th items of ⍳5 with their reversal:<br/>Multiply the 2nd and 4th items of ⍳5 by 10:<br/>Replace the 2nd and 4th items by their totals:<br/>Replace the 2nd and 4th rows (major cells) of a matrix with their accumulatives:<br/>Replace odd elements with 0:<br/>Replace multiples of 3 (note              that masked items are substituted in ravel order):<br/>Replace odd elements with their reciprocals:<br/>Replace odd items of ⍳5 with themselves reversed:,At
@,At<br/>Dyadic: At<br/>: At
Brackets,Brackets
: Round brackets or parentheses are used in APL expressions to control the order of execution.  They are also used in function/operator headers to indicate Namelists.  A right parenthesis is also used to introduce a System Command.,Brackets
: Square brackets have three distinct meanings in Dyalog APL. They are used to select sub-arrays from an n-dimensional array and to indicate an axis along which a function (operand) is to apply. See Bracket Indexing and Bracket Axis Operator. A right bracket is also used to introduce a User Command.,Brackets
"X may be  any array. Y must be a valid index specification. R is an array composed of elements indexed from X and the shape of X is determined by the index specification.<br/>This form of Indexing, using brackets, does not follow the normal syntax of a dyadic function. For an alternative method of indexing, see Index.<br/>⎕IO is an implicit argument of Indexing.<br/>Three forms of indexing are permitted. The form used is determined by context.<br/>For vector X, Y is a simple integer array composed of items from the set ⍳⍴X. <br/>R consists of elements selected according to index positions in Y. R has the same shape as Y.<br/>For matrix X, Y is composed of two simple integer arrays separated by the semicolon character (;). The arrays select indices from the rows and columns of X respectively.<br/>For higher-rank array X, Y is composed of a simple integer array for each axis of X with adjacent arrays separated by a single semicolon character (;). The arrays select indices from the respective axes of X, taken in row-major order.<br/>If an indexing array is omitted for the Kth axis, the index vector ⍳(⍴X)[K] is assumed for that axis.<br/>The index specification Y is a non-simple array. Each item identifies a single element of X by a set of indices with one element per axis of X in row-major order.<br/>A scalar may be indexed by the enclosed empty vector:<br/>Simple and Choose indexing are indistinguishable for vector X:<br/>The index specification Y is a non-simple integer array, each of whose items reach down to a nested element of X. The items of an item of Y are simple vectors (or scalars) forming sets of indices that index arrays at successive levels of X starting at the top-most level. A set of indices has one element per axis at the respective level of nesting of X in row-major order.<br/>If Y is a ref to an instance of a Class with a Default property, indexing is applied to the Default property. Similarly, indexing applied to a .NET collection returns the appropriate item(s) of the collection.<br/>See also: Indexing  Classes.",Brackets
Brackets,"X may be  any array. Y must be a valid index specification. R is an array composed of elements indexed from X and the shape of X is determined by the index specification.<br/>This form of Indexing, using brackets, does not follow the normal syntax of a dyadic function. For an alternative method of indexing, see Index.<br/>⎕IO is an implicit argument of Indexing.<br/>Three forms of indexing are permitted. The form used is determined by context.<br/>For vector X, Y is a simple integer array composed of items from the set ⍳⍴X. <br/>R consists of elements selected according to index positions in Y. R has the same shape as Y.<br/>For matrix X, Y is composed of two simple integer arrays separated by the semicolon character (;). The arrays select indices from the rows and columns of X respectively.<br/>For higher-rank array X, Y is composed of a simple integer array for each axis of X with adjacent arrays separated by a single semicolon character (;). The arrays select indices from the respective axes of X, taken in row-major order.<br/>If an indexing array is omitted for the Kth axis, the index vector ⍳(⍴X)[K] is assumed for that axis.<br/>The index specification Y is a non-simple array. Each item identifies a single element of X by a set of indices with one element per axis of X in row-major order.<br/>A scalar may be indexed by the enclosed empty vector:<br/>Simple and Choose indexing are indistinguishable for vector X:<br/>The index specification Y is a non-simple integer array, each of whose items reach down to a nested element of X. The items of an item of Y are simple vectors (or scalars) forming sets of indices that index arrays at successive levels of X starting at the top-most level. A set of indices has one element per axis at the respective level of nesting of X in row-major order.<br/>If Y is a ref to an instance of a Class with a Default property, indexing is applied to the Default property. Similarly, indexing applied to a .NET collection returns the appropriate item(s) of the collection.<br/>See also: Indexing  Classes."
Indexing,"X may be  any array. Y must be a valid index specification. R is an array composed of elements indexed from X and the shape of X is determined by the index specification.<br/>This form of Indexing, using brackets, does not follow the normal syntax of a dyadic function. For an alternative method of indexing, see Index.<br/>⎕IO is an implicit argument of Indexing.<br/>Three forms of indexing are permitted. The form used is determined by context.<br/>For vector X, Y is a simple integer array composed of items from the set ⍳⍴X. <br/>R consists of elements selected according to index positions in Y. R has the same shape as Y.<br/>For matrix X, Y is composed of two simple integer arrays separated by the semicolon character (;). The arrays select indices from the rows and columns of X respectively.<br/>For higher-rank array X, Y is composed of a simple integer array for each axis of X with adjacent arrays separated by a single semicolon character (;). The arrays select indices from the respective axes of X, taken in row-major order.<br/>If an indexing array is omitted for the Kth axis, the index vector ⍳(⍴X)[K] is assumed for that axis.<br/>The index specification Y is a non-simple array. Each item identifies a single element of X by a set of indices with one element per axis of X in row-major order.<br/>A scalar may be indexed by the enclosed empty vector:<br/>Simple and Choose indexing are indistinguishable for vector X:<br/>The index specification Y is a non-simple integer array, each of whose items reach down to a nested element of X. The items of an item of Y are simple vectors (or scalars) forming sets of indices that index arrays at successive levels of X starting at the top-most level. A set of indices has one element per axis at the respective level of nesting of X in row-major order.<br/>If Y is a ref to an instance of a Class with a Default property, indexing is applied to the Default property. Similarly, indexing applied to a .NET collection returns the appropriate item(s) of the collection.<br/>See also: Indexing  Classes."
"X may be  any array. Y must be a valid index specification. R is an array composed of elements indexed from X and the shape of X is determined by the index specification.<br/>This form of Indexing, using brackets, does not follow the normal syntax of a dyadic function. For an alternative method of indexing, see Index.<br/>⎕IO is an implicit argument of Indexing.<br/>Three forms of indexing are permitted. The form used is determined by context.<br/>For vector X, Y is a simple integer array composed of items from the set ⍳⍴X. <br/>R consists of elements selected according to index positions in Y. R has the same shape as Y.<br/>For matrix X, Y is composed of two simple integer arrays separated by the semicolon character (;). The arrays select indices from the rows and columns of X respectively.<br/>For higher-rank array X, Y is composed of a simple integer array for each axis of X with adjacent arrays separated by a single semicolon character (;). The arrays select indices from the respective axes of X, taken in row-major order.<br/>If an indexing array is omitted for the Kth axis, the index vector ⍳(⍴X)[K] is assumed for that axis.<br/>The index specification Y is a non-simple array. Each item identifies a single element of X by a set of indices with one element per axis of X in row-major order.<br/>A scalar may be indexed by the enclosed empty vector:<br/>Simple and Choose indexing are indistinguishable for vector X:<br/>The index specification Y is a non-simple integer array, each of whose items reach down to a nested element of X. The items of an item of Y are simple vectors (or scalars) forming sets of indices that index arrays at successive levels of X starting at the top-most level. A set of indices has one element per axis at the respective level of nesting of X in row-major order.<br/>If Y is a ref to an instance of a Class with a Default property, indexing is applied to the Default property. Similarly, indexing applied to a .NET collection returns the appropriate item(s) of the collection.<br/>See also: Indexing  Classes.",Indexing
: Curly brackets have three distinct meanings in Dyalog APL. They are used to indicate shy results and optional left arguments in defined functions. They are also used to enclose the definition of a dfn and a dop. See Model Syntax and Dfns & Dops.,Brackets
"Note: the right argument Y and/or the result R may be represented by a single name, or as a blank-delimited list of names surrounded by parentheses. For further details, see Namelists.",Brackets
Brackets,"Note: the right argument Y and/or the result R may be represented by a single name, or as a blank-delimited list of names surrounded by parentheses. For further details, see Namelists."
Brackets,Brackets<br/>: Round brackets or parentheses are used in APL expressions to control the order of execution.  They are also used in function/operator headers to indicate Namelists.  A right parenthesis is also used to introduce a System Command.<br/>: Square brackets have three distinct meanings in Dyalog APL. They are used to select sub-arrays from an n-dimensional array and to indicate an axis along which a function (operand) is to apply. See Bracket Indexing and Bracket Axis Operator. A right bracket is also used to introduce a User Command.<br/>: Curly brackets have three distinct meanings in Dyalog APL. They are used to indicate shy results and optional left arguments in defined functions. They are also used to enclose the definition of a dfn and a dop. See Model Syntax and Dfns & Dops.
Hash is a namespace identifier.,Special Syntax
Special Syntax,Hash is a namespace identifier.
